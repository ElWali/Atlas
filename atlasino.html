<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="referrer" content="origin">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Atlas.js - Lightweight JavaScript Mapping Library</title>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; width: 100%; overflow: hidden; font-family: 'Google Sans', system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    #map-container { position: relative; width: 100%; height: 100%; overflow: hidden; background: #000; cursor: grab; }
    #map-container.dragging { cursor: grabbing; }
    #map-container.selecting { cursor: crosshair; }
    #map { width: 100%; height: 100%; display: block; }
    .atlas-control-container {
      position: absolute;
      z-index: 1000;
      pointer-events: none;
    }
    .atlas-control-container > * { pointer-events: auto; }
    .atlas-control-top-left { top: 10px; left: 10px; }
    .atlas-control-top-right { top: 10px; right: 10px; }
    .atlas-control-bottom-left { bottom: 10px; left: 10px; }
    .atlas-control-bottom-right { bottom: 10px; right: 10px; }
    .atlas-control-vertical { display: flex; flex-direction: column; gap: 8px; }
    .atlas-control-horizontal { display: flex; flex-direction: row; gap: 8px; }
    .control-btn {
      background: rgba(255,255,255,0.92);
      border: none;
      font-size: 18px;
      padding: 8px;
      cursor: pointer;
      border-radius: 50%;
      user-select: none;
      box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      min-width: 40px;
      min-height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #1a73e8;
    }
    .control-btn:hover { 
      background: rgba(255,255,255,0.98); 
      box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);
      transform: translateY(-1px);
    }
    .control-btn:active { 
      background: rgba(245,245,245,0.98); 
      transform: translateY(0px) scale(0.97);
      box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
    }
    .control-btn:focus { 
      outline: 2px solid #1a73e8; 
      outline-offset: 2px; 
      box-shadow: 0 0 0 3px rgba(26, 115, 232, 0.3);
    }
    .control-btn:disabled { 
      background: rgba(245,245,245,0.8); 
      color: #b0b0b0; 
      cursor: not-allowed; 
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }
    #loading {
      position: absolute; top: 10px; right: 10px;
      background: rgba(255,255,255,0.9); padding: 6px 12px; border-radius: 20px;
      font-size: 12px; display: none; box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      font-family: 'Google Sans', Roboto, Arial, sans-serif;
    }
    #loading.visible { display: flex; align-items: center; gap: 6px; }
    #attribution {
      position: absolute;
      bottom: 12px;
      left: 12px;
      background: rgba(255, 255, 255, 0.85);
      color: #5f6368;
      font-size: 12px;
      padding: 8px 12px;
      border-radius: 20px;
      white-space: nowrap;
      overflow-x: auto;
      scrollbar-width: thin;
      scrollbar-color: rgba(95, 99, 104, 0.3) rgba(255, 255, 255, 0.85);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.24);
      z-index: 1000;
      backdrop-filter: blur(8px);
      font-family: 'Google Sans', Roboto, Arial, sans-serif;
    }
    #attribution::-webkit-scrollbar { height: 6px; }
    #attribution::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.85); border-radius: 3px; }
    #attribution::-webkit-scrollbar-thumb { background: rgba(95, 99, 104, 0.3); border-radius: 3px; }
    #attribution a { color: #1a73e8; text-decoration: none; font-weight: 500; margin-right: 8px; transition: all 0.2s ease; font-size: 12px; }
    #attribution a:hover { text-decoration: underline; opacity: 0.9; }
    .atlas-search-input:focus {
      border-color: #1a73e8;
      box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.2);
    }
    .atlas-search-result-item:hover,
    .atlas-search-result-item.active {
      background-color: #f8f9fa;
    }
    .atlas-search-result-item:last-child {
      border-bottom: none;
    }
    @keyframes zoom-indicator {
      0% { transform: scale(0.2); opacity: 0.8; }
      100% { transform: scale(1.2); opacity: 0; }
    }
    .atlas-overlay-pane {
      position: absolute;
      left: 0; top: 0; right: 0; bottom: 0;
      z-index: 900;
      pointer-events: none;
    }
    .atlas-popup-pane {
      position: absolute;
      left: 0; top: 0; right: 0; bottom: 0;
      z-index: 1200;
      pointer-events: none;
    }
    
    /* GOOGLE MAPS EXACT MARKER REPLICA */
    .atlas-marker {
      position: absolute;
      transform: translate(-50%, -100%);
      will-change: transform, left, top;
      pointer-events: auto;
      cursor: pointer;
      user-select: none;
      transition: transform 0.15s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 1000;
    }
    .atlas-marker:hover { 
      transform: translate(-50%, -100%) scale(1.1);
      z-index: 1100;
    }
    .atlas-marker:active { 
      transform: translate(-50%, -100%) scale(0.95);
    }
    .atlas-marker:focus-visible { 
      outline: 2px solid rgba(26,115,232,0.6); 
      outline-offset: 4px; 
      border-radius: 50%;
      box-shadow: 0 0 0 3px rgba(26, 115, 232, 0.3);
    }
    
    /* EXACT GOOGLE MAPS MARKER DESIGN */
    .atlas-marker-google {
      width: 27px;
      height: 43px;
      position: relative;
      background: linear-gradient(135deg, #EA4335 0%, #FBBC05 25%, #34A853 50%, #4285F4 75%, #9AA0A6 100%);
      background: #EA4335;
      border-radius: 50% 50% 50% 0;
      transform: rotate(-45deg);
      box-shadow: 0 2px 6px rgba(0,0,0,0.3), 0 1px 3px rgba(0,0,0,0.15);
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    /* Inner white circle - exact Google Maps style */
    .atlas-marker-google::after {
      content: '';
      position: absolute;
      width: 15px;
      height: 15px;
      background: white;
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) rotate(45deg);
      box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
    }
    
    /* Shadow dot at the bottom - exact Google Maps style */
    .atlas-marker-google::before {
      content: '';
      position: absolute;
      bottom: -6px;
      left: 50%;
      transform: translateX(-50%) rotate(45deg);
      width: 8px;
      height: 8px;
      background: rgba(0,0,0,0.2);
      border-radius: 50%;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    }
    
    /* Color variants - exact Google Maps colors */
    .atlas-marker-red { background: #EA4335; }
    .atlas-marker-red::before { background: rgba(234, 67, 53, 0.3); }
    
    .atlas-marker-blue { background: #4285F4; }
    .atlas-marker-blue::before { background: rgba(66, 133, 244, 0.3); }
    
    .atlas-marker-green { background: #34A853; }
    .atlas-marker-green::before { background: rgba(52, 168, 83, 0.3); }
    
    .atlas-marker-yellow { background: #FBBC05; }
    .atlas-marker-yellow::before { background: rgba(251, 188, 5, 0.3); }
    
    .atlas-marker-purple { background: #9C27B0; }
    .atlas-marker-purple::before { background: rgba(156, 39, 176, 0.3); }
    
    /* Google Maps ripple effect */
    .atlas-ripple-google {
      position: absolute;
      border-radius: 50%;
      transform: scale(0);
      pointer-events: none;
      background: rgba(66, 133, 244, 0.2);
      animation: atlas-ripple-google 600ms cubic-bezier(0.4, 0, 0.2, 1) forwards;
    }
    @keyframes atlas-ripple-google {
      0% { transform: scale(0); opacity: 0.8; }
      100% { transform: scale(2.5); opacity: 0; }
    }
    
    /* EXACT GOOGLE MAPS POPUP DESIGN */
    .atlas-popup {
      position: absolute;
      pointer-events: auto;
      max-width: min(90vw, 320px);
      z-index: 1201;
      filter: drop-shadow(0 4px 12px rgba(0,0,0,0.15)) drop-shadow(0 2px 4px rgba(0,0,0,0.12));
    }
    
    .atlas-popup-card {
      background: #ffffff;
      color: #202124;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15), 0 2px 4px rgba(0,0,0,0.12);
      border: 1px solid rgba(0,0,0,0.04);
      padding: 16px 20px;
      position: relative;
      transform-origin: bottom center;
      font-family: 'Google Sans', Roboto, Arial, sans-serif;
      min-width: 200px;
    }
    
    /* Popup animations - exact Google Maps style */
    @keyframes atlas-popup-in-top {
      from { transform: scale(0.9) translateY(-8px); opacity: 0; }
      to { transform: scale(1) translateY(0); opacity: 1; }
    }
    @keyframes atlas-popup-in-bottom {
      from { transform: scale(0.9) translateY(8px); opacity: 0; }
      to { transform: scale(1) translateY(0); opacity: 1; }
    }
    @keyframes atlas-popup-in-left {
      from { transform: scale(0.9) translateX(-8px); opacity: 0; }
      to { transform: scale(1) translateX(0); opacity: 1; }
    }
    @keyframes atlas-popup-in-right {
      from { transform: scale(0.9) translateX(8px); opacity: 0; }
      to { transform: scale(1) translateX(0); opacity: 1; }
    }
    
    .atlas-popup-close {
      position: absolute;
      top: 8px; 
      right: 8px;
      border: none; 
      background: transparent; 
      color: #5f6368;
      width: 32px; 
      height: 32px; 
      border-radius: 50%;
      cursor: pointer; 
      font-size: 18px; 
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    }
    .atlas-popup-close:hover { 
      background: rgba(95, 99, 104, 0.08);
      color: #202124;
    }
    .atlas-popup-close:active { 
      transform: scale(0.95);
      background: rgba(95, 99, 104, 0.12);
    }
    
    .atlas-popup-header {
      font-weight: 500;
      font-size: 16px;
      margin-bottom: 8px;
      color: #202124;
      line-height: 1.4;
      padding-right: 24px;
    }
    
    .atlas-popup-content {
      font-size: 14px;
      line-height: 1.5;
      color: #5f6368;
      overscroll-behavior: contain;
    }
    
    /* EXACT GOOGLE MAPS POPUP ARROW */
    .atlas-popup-arrow {
      width: 14px; 
      height: 14px;
      background: #ffffff;
      position: absolute;
      transform: rotate(45deg);
      border: 1px solid rgba(0,0,0,0.04);
      border-top: none;
      border-left: none;
      box-shadow: 2px 2px 4px rgba(0,0,0,0.08);
    }
    
    /* Popup positions - exact Google Maps positioning */
    .atlas-popup.top { transform: translate(-50%, -100%); }
    .atlas-popup.top .atlas-popup-arrow {
      bottom: -7px; 
      left: calc(50% - 7px);
    }
    .atlas-popup.top .atlas-popup-card {
      animation: atlas-popup-in-top 0.2s cubic-bezier(0.4, 0, 0.2, 1) forwards;
      margin-bottom: 8px;
    }
    
    .atlas-popup.bottom { transform: translate(-50%, 0%); }
    .atlas-popup.bottom .atlas-popup-arrow {
      top: -7px; 
      left: calc(50% - 7px);
    }
    .atlas-popup.bottom .atlas-popup-card {
      animation: atlas-popup-in-bottom 0.2s cubic-bezier(0.4, 0, 0.2, 1) forwards;
      margin-top: 8px;
    }
    
    .atlas-popup.left { transform: translate(-100%, -50%); }
    .atlas-popup.left .atlas-popup-arrow {
      right: -7px; 
      top: calc(50% - 7px);
    }
    .atlas-popup.left .atlas-popup-card {
      animation: atlas-popup-in-left 0.2s cubic-bezier(0.4, 0, 0.2, 1) forwards;
      margin-right: 8px;
    }
    
    .atlas-popup.right { transform: translate(0%, -50%); }
    .atlas-popup.right .atlas-popup-arrow {
      left: -7px; 
      top: calc(50% - 7px);
    }
    .atlas-popup.right .atlas-popup-card {
      animation: atlas-popup-in-right 0.2s cubic-bezier(0.4, 0, 0.2, 1) forwards;
      margin-left: 8px;
    }
    
    /* Animated markers with Material Design motion */
    .atlas-marker-bounce {
      animation: atlas-bounce 2s cubic-bezier(0.4, 0, 0.2, 1) infinite;
    }
    @keyframes atlas-bounce {
      0%, 100% { transform: translate(-50%, -100%) rotate(-45deg); }
      50% { transform: translate(-50%, -110%) rotate(-45deg) scale(1.05); }
    }
    .atlas-marker-pulse {
      animation: atlas-pulse 1.5s cubic-bezier(0.4, 0, 0.2, 1) infinite;
    }
    @keyframes atlas-pulse {
      0% { box-shadow: 0 2px 6px rgba(0,0,0,0.3), 0 1px 3px rgba(0,0,0,0.15); }
      50% { box-shadow: 0 4px 12px rgba(66, 133, 244, 0.4), 0 2px 6px rgba(66, 133, 244, 0.3); }
      100% { box-shadow: 0 2px 6px rgba(0,0,0,0.3), 0 1px 3px rgba(0,0,0,0.15); }
    }
  </style>
</head>
<body>
  <div id="map-container">
    <canvas id="map"></canvas>
    <div id="loading">Loading: <span id="loading-count">0</span></div>
    <div id="attribution"></div>
  </div>
  <script>
    const EARTH_RADIUS = 6378137;
    const EARTH_CIRCUMFERENCE = 2 * Math.PI * EARTH_RADIUS;
    const MAX_LATITUDE = 85.05112878;
    const MIN_LATITUDE = -85.05112878;
    const TILE_SIZE = 256;
    const TILE_TTL = 86400000;
    const TILE_LOAD_TIMEOUT_MS = 8000;
    const INERTIA_DECEL = 0.0025;
    const INERTIA_STOP_SPEED = 0.02;
    const VELOCITY_WINDOW_MS = 120;
    const DOUBLE_TAP_MAX_DELAY = 300;
    const DOUBLE_TAP_MAX_MOVE = 16;
    const TWO_FINGER_TAP_MAX_DELAY = 250;
    const TWO_FINGER_TAP_MOVE_THRESH = 10;
    const ROTATE_MOVE_THRESH_RAD = 0.08;
    const WHEEL_ZOOM_STEP = 0.25;
    const WHEEL_ZOOM_DURATION = 220;
    const TAP_ZOOM_DURATION = 280;
    const SNAP_DURATION = 300;
    const FLYTO_DURATION = 800;
    const LAYERS = {
      OSM: {
        name: "OpenStreetMap",
        minZoom: 0,
        maxZoom: 19,
        tileServers: ["https://a.tile.openstreetmap.org", "https://b.tile.openstreetmap.org", "https://c.tile.openstreetmap.org"],
        attribution: '© <a href="https://www.openstreetmap.org/copyright" target="_blank" rel="noopener noreferrer">OpenStreetMap contributors</a>',
        background: "#e6e6e6",
        supportsRetina: true,
        maxCacheSize: 800
      },
      ESRI: {
        name: "Esri Satellite",
        minZoom: 0,
        maxZoom: 19,
        tileServers: ["https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile"],
        attribution: 'Tiles © <a href="https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer" target="_blank" rel="noopener noreferrer">Esri World Imagery</a>',
        background: "#000000",
        supportsRetina: false,
        maxCacheSize: 600
      },
      ESRI_TOPO: {
        name: "Esri Topographic",
        minZoom: 0,
        maxZoom: 19,
        tileServers: ["https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile"],
        attribution: 'Tiles © <a href="https://services.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer" target="_blank" rel="noopener noreferrer">Esri World Topographic Map</a>',
        background: "#f5f5f0",
        supportsRetina: false,
        maxCacheSize: 600
      }
    };
    const CONFIG = {
      defaultLayer: "OSM",
      defaultCenter: { lon: 0, lat: 0 },
      defaultZoom: 3,
      retina: "auto",
      retinaSuffix: "@2x",
      adaptiveBuffering: true,
      fixedTileBuffer: 3,
      debugTileBuffer: false
    };
    const EASING = {
      easeInOutCubic: t => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2,
      easeOutCubic: t => 1 - Math.pow(1 - t, 3),
      linear: t => t,
      easeInOutQuint: t => t < 0.5 ? 16 * t * t * t * t * t : 1 - Math.pow(-2 * t + 2, 5) / 2
    };
    const RAD2DEG = 180 / Math.PI;
    const DEG2RAD = Math.PI / 180;
    function normalizeAngle(rad) { return Math.atan2(Math.sin(rad), Math.cos(rad)); }
    function shortestAngleDiff(from, to) { return normalizeAngle(to - from); }
    function wrapDeltaLon(delta) { delta = ((delta + 180) % 360 + 360) % 360 - 180; return delta; }
    function rot(x, y, rad) { const c = Math.cos(rad), s = Math.sin(rad); return { x: x * c - y * s, y: x * s + y * c }; }
    const GISUtils = {
      wrapLongitude: lon => ((lon + 180) % 360 + 360) % 360 - 180,
      clampLatitude: lat => Math.max(MIN_LATITUDE, Math.min(MAX_LATITUDE, lat)),
      getResolution: (lat, zoom) => Math.cos(lat * DEG2RAD) * EARTH_CIRCUMFERENCE / Math.pow(2, zoom + 8)
    };
    const DEFAULT_PROJECTION = {
      latLngToTile: (latlng, z) => {
        const lat = GISUtils.clampLatitude(latlng.lat);
        const lon = GISUtils.wrapLongitude(latlng.lon);
        const scale = Math.pow(2, z);
        const x = (lon + 180) / 360 * scale;
        const y = (1 - Math.log(Math.tan(lat * DEG2RAD) + 1 / Math.cos(lat * DEG2RAD)) / Math.PI) / 2 * scale;
        return { x, y };
      },
      tileToLatLng: (x, y, z) => {
        const scale = Math.pow(2, z);
        const lon = x / scale * 360 - 180;
        const n = Math.PI - 2 * Math.PI * y / scale;
        const lat = Math.atan(Math.sinh(n)) * RAD2DEG;
        return { lat: GISUtils.clampLatitude(lat), lon: GISUtils.wrapLongitude(lon) };
      }
    };
    class EventEmitter {
      constructor() { this._events = {}; }
      on(type, fn) { if (!this._events[type]) this._events[type] = []; this._events[type].push(fn); return this; }
      off(type, fn) { if (!this._events[type]) return this; this._events[type] = this._events[type].filter(cb => cb !== fn); return this; }
      fire(type, data = {}) { if (!this._events[type]) return; data.type = type; data.target = this; this._events[type].forEach(fn => fn(data)); }
    }
    class Layer extends EventEmitter {
      constructor(options = {}) { super(); this.options = options; this._map = null; }
      addTo(map) { map.addLayer(this); return this; }
      remove() { if (this._map) this._map.removeLayer(this); return this; }
      fire(type, data = {}) { if (!this._events[type]) return; data.type = type; data.target = this; this._events[type].forEach(fn => fn(data)); }
      onAdd() {}
      onRemove() {}
      render() {}
    }
    class TileLayer extends Layer {
      constructor(urlTemplate, options = {}) {
        super(options);
        this.urlTemplate = urlTemplate;
        this.options = { minZoom: options.minZoom || 0, maxZoom: options.maxZoom || 18, attribution: options.attribution || '', background: options.background || '#ffffff', supportsRetina: options.supportsRetina || false, maxCacheSize: options.maxCacheSize || 800, ...options };
        this.tileCache = new Map();
        this.loadingTiles = new Set();
        this.loadingControllers = new Map();
        this._retinaAvailable = true;
        this._lastRenderedCenter = null;
        this._lastRenderedZoom = null;
        this._lastRenderedBearing = null;
        this._lastVelocity = { x: 0, y: 0 };
        this._lastVelocityTime = 0;
        this._isPanningFast = false;
        this._loadingQueue = [];
        this._maxConcurrentLoads = 6;
        this._concurrencyResetTimer = null;
      }
      _getTileUrl(x, y, z) {
        const scale = Math.pow(2, z);
        let wrappedX = ((x % scale) + scale) % scale;
        const intX = Math.floor(wrappedX);
        const intY = Math.max(0, Math.min(scale - 1, Math.floor(y)));
        let url = this.urlTemplate.replace('{z}', z).replace('{x}', intX).replace('{y}', intY);
        if (this.options.supportsRetina && this._shouldRequestRetina()) url += CONFIG.retinaSuffix;
        return url;
      }
      _shouldRequestRetina() {
        const mode = CONFIG.retina;
        return (mode === true) || (mode === "auto" && (window.devicePixelRatio || 1) > 1.5);
      }
      async _loadTile(key, url) {
        if (this.tileCache.has(key)) return this.tileCache.get(key);
        const controller = new AbortController();
        const signal = controller.signal;
        this.loadingControllers.set(key, controller);
        const img = new Image();
        img.crossOrigin = "anonymous";
        const tile = { img, loaded: false, loadedAt: Date.now(), lastUsed: Date.now(), controller };
        this.tileCache.set(key, tile);
        this.loadingTiles.add(key);
        const loadPromise = new Promise((resolve, reject) => {
          img.onload = () => {
            tile.loaded = true;
            tile.loadedAt = Date.now();
            this.loadingTiles.delete(key);
            this.loadingControllers.delete(key);
            if (this._map) {
              this._map.debouncedRender(16);
            }
            this.fire('tileload', { tile: key, url });
            resolve(tile);
          };
          img.onerror = (e) => {
            if (signal.aborted) return;
            console.warn(`[Atlas] Failed to load tile: ${url}`, e);
            if (this.options.supportsRetina && url.includes(CONFIG.retinaSuffix)) {
              this._retinaAvailable = false;
              img.src = url.replace(CONFIG.retinaSuffix, "");
              return;
            }
            this.loadingTiles.delete(key);
            this.loadingControllers.delete(key);
            this.fire('tileerror', { tile: key, url, error: e });
            reject(e);
          };
          img.src = url;
        });
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => {
            if (this.loadingTiles.has(key)) {
              controller.abort();
              console.warn(`[Atlas] Tile load timeout for: ${url}`);
              this.loadingTiles.delete(key);
              this.loadingControllers.delete(key);
              if (this.tileCache.has(key)) this.tileCache.delete(key);
              this.fire('tileerror', { tile: key, url, error: new Error('Timeout') });
              reject(new Error(`Timeout loading tile: ${url}`));
            }
          }, TILE_LOAD_TIMEOUT_MS);
        });
        try { await Promise.race([loadPromise, timeoutPromise]); }
        catch (error) { if (!signal.aborted) console.error("[Atlas] Tile loading failed or timed out:", error.message); }
        return tile;
      }
      _reloadTile(key, url) {
        const existing = this.tileCache.get(key);
        if (!existing) return;
        const token = key + "#r";
        if (this.loadingTiles.has(token)) return;
        const doReload = () => {
          const controller = new AbortController();
          const img = new Image();
          img.crossOrigin = "anonymous";
          this.loadingTiles.add(token);
          img.onload = () => {
            existing.img = img;
            existing.loaded = true;
            existing.loadedAt = Date.now();
            this.loadingTiles.delete(token);
            if (this._map) this._map.scheduleRender();
          };
          img.onerror = () => this.loadingTiles.delete(token);
          img.src = url + (url.includes("?") ? "&" : "?") + "v=" + Date.now();
        };
        if ('requestIdleCallback' in window) {
          requestIdleCallback(doReload, { timeout: 2000 });
        } else {
          setTimeout(doReload, 100);
        }
      }
      _evict() {
        if (this.tileCache.size <= this.options.maxCacheSize) return;
        if ('requestIdleCallback' in window) {
          requestIdleCallback(() => this._performEviction(), { timeout: 2000 });
        } else {
          setTimeout(() => this._performEviction(), 100);
        }
      }
      _performEviction() {
        if (this.tileCache.size <= this.options.maxCacheSize) return;
        if (!this._map) return;
        const zInt = Math.floor(this._map.zoom);
        const scaleFactor = Math.pow(2, this._map.zoom - zInt);
        const ts = TILE_SIZE;
        const w = this._map.canvas.width / this._map.dpr;
        const h = this._map.canvas.height / this._map.dpr;
        const wrappedCenterLon = GISUtils.wrapLongitude(this._map.center.lon);
        const ct = this._map.projection.latLngToTile({ lat: this._map.center.lat, lon: wrappedCenterLon }, zInt);
        const absCos = Math.abs(Math.cos(this._map.bearing)), absSin = Math.abs(Math.sin(this._map.bearing));
        const needW = w * absCos + h * absSin;
        const needH = w * absSin + h * absCos;
        const adaptiveBuffer = this._getAdaptiveTileBuffer();
        const cols = Math.ceil(needW / (ts * scaleFactor)) + adaptiveBuffer;
        const visibleLatSpan = MAX_LATITUDE - MIN_LATITUDE;
        const visibleLatPixels = h * absCos;
        const visibleLatDegrees = visibleLatSpan * (visibleLatPixels / h);
        const rows = Math.ceil(visibleLatDegrees / (TILE_SIZE * scaleFactor)) + adaptiveBuffer;
        const startX = Math.floor(ct.x - cols / 2);
        const startY = Math.floor(ct.y - rows / 2);
        const protectedKeys = new Set();
        for (let dx = 0; dx < cols; dx++) {
          for (let dy = 0; dy < rows; dy++) {
            const X = startX + dx, Y = startY + dy;
            const key = `${zInt}/${X}/${Y}`;
            protectedKeys.add(key);
          }
        }
        const entries = Array.from(this.tileCache.entries());
        const evictable = [];
        const protectedTiles = [];
        for (const [key, tile] of entries) {
          if (protectedKeys.has(key)) {
            protectedTiles.push({ key, tile });
          } else {
            evictable.push({ key, tile });
          }
        }
        evictable.sort((a, b) => a.tile.lastUsed - b.tile.lastUsed);
        protectedTiles.sort((a, b) => a.tile.lastUsed - b.tile.lastUsed);
        const removeCount = this.tileCache.size - this.options.maxCacheSize;
        let removed = 0;
        for (let i = 0; i < evictable.length && removed < removeCount; i++) {
          this.tileCache.delete(evictable[i].key);
          removed++;
        }
        if (removed < removeCount) {
          for (let i = 0; i < protectedTiles.length && removed < removeCount; i++) {
            this.tileCache.delete(protectedTiles[i].key);
            removed++;
          }
        }
      }
      _boostConcurrencyTemp(boost = 12, ms = 2000) {
        const original = this._maxConcurrentLoads;
        this._maxConcurrentLoads = Math.max(original, boost);
        if (this._concurrencyResetTimer) clearTimeout(this._concurrencyResetTimer);
        this._concurrencyResetTimer = setTimeout(() => {
          this._maxConcurrentLoads = original;
          this._concurrencyResetTimer = null;
        }, ms);
      }
      _queueTileLoad(key, url, priority = 0) {
        if (this.loadingTiles.has(key) || this._loadingQueue.some(item => item.key === key)) {
          return;
        }
        this._loadingQueue.push({ key, url, priority });
        this._loadingQueue.sort((a, b) => b.priority - a.priority);
        this._processQueue();
      }
      _processQueue() {
        while (this.loadingTiles.size < this._maxConcurrentLoads && this._loadingQueue.length > 0) {
          const next = this._loadingQueue.shift();
          this._loadTile(next.key, next.url).finally(() => {
            this._processQueue();
          });
        }
      }
      prefetchAround(center, zoom, radius = 2, includeAdjacent = true, priority = 100) {
        if (!this._map) return;
        this._boostConcurrencyTemp(12, 2000);
        const zInt = Math.floor(zoom);
        const levels = new Set([zInt]);
        if (includeAdjacent) {
          if (zInt + 1 <= this.options.maxZoom) levels.add(zInt + 1);
          if (zInt - 1 >= this.options.minZoom) levels.add(zInt - 1);
        }
        for (const z of levels) {
          const n = Math.pow(2, z);
          const ct = this._map.projection.latLngToTile(center, z);
          const cx = Math.floor(ct.x);
          const cy = Math.floor(ct.y);
          for (let dx = -radius; dx <= radius; dx++) {
            for (let dy = -radius; dy <= radius; dy++) {
              let X = ((cx + dx) % n + n) % n;
              let Y = Math.max(0, Math.min(n - 1, cy + dy));
              const key = `${z}/${X}/${Y}`;
              const url = this._getTileUrl(X, Y, z);
              this._queueTileLoad(key, url, priority);
            }
          }
        }
      }
      _preloadAdjacentZoomTiles() {
        if (!this._map) return;
        const zInt = Math.floor(this._map.zoom);
        const nextZoom = Math.min(this.options.maxZoom, zInt + 1);
        const prevZoom = Math.max(this.options.minZoom, zInt - 1);
        if (Math.abs(this._map.zoom - zInt) > 0.3) return;
        const wrappedCenterLon = GISUtils.wrapLongitude(this._map.center.lon);
        const ct = this._map.projection.latLngToTile({ lat: this._map.center.lat, lon: wrappedCenterLon }, zInt);
        const ts = TILE_SIZE;
        const w = this._map.canvas.width / this._map.dpr;
        const h = this._map.canvas.height / this._map.dpr;
        const adaptiveBuffer = this._getAdaptiveTileBuffer();
        const viewportTiles = Math.ceil(Math.max(w, h) / ts) + adaptiveBuffer;
        for (let dz of [prevZoom, nextZoom]) {
          if (dz === zInt) continue;
          const scaleDiff = Math.pow(2, Math.abs(dz - zInt));
          const startX = Math.floor(ct.x * (dz > zInt ? scaleDiff : 1 / scaleDiff) - viewportTiles / 2);
          const startY = Math.floor(ct.y * (dz > zInt ? scaleDiff : 1 / scaleDiff) - viewportTiles / 2);
          for (let dx = 0; dx < viewportTiles; dx++) {
            for (let dy = 0; dy < viewportTiles; dy++) {
              const X = startX + dx, Y = startY + dy;
              const key = `${dz}/${X}/${Y}`;
              if (!this.tileCache.has(key) && !this.loadingTiles.has(key)) {
                this._queueTileLoad(key, this._getTileUrl(X, Y, dz));
              }
            }
          }
        }
      }
      _getAdaptiveTileBuffer() {
        if (!CONFIG.adaptiveBuffering) {
          return CONFIG.fixedTileBuffer;
        }
        let buffer = 3;
        const zoom = this._map ? this._map.zoom : 3;
        const deviceMemory = navigator.deviceMemory || 4;
        if (zoom <= 5) buffer = 1;
        else if (zoom <= 12) buffer = 2;
        else if (zoom <= 16) buffer = 3;
        else buffer = 4;
        if (deviceMemory < 2) buffer = Math.max(1, buffer - 1);
        else if (deviceMemory >= 8) buffer = Math.min(5, buffer + 1);
        if (this._isPanningFast) buffer = Math.min(5, buffer + 1);
        buffer = Math.max(1, Math.min(5, buffer));
        if (CONFIG.debugTileBuffer) {
          console.log(`[Atlas Buffer] Zoom: ${zoom.toFixed(1)}, Device RAM: ${deviceMemory}GB, Panning Fast: ${this._isPanningFast}, Buffer: ${buffer}`);
        }
        return buffer;
      }
      updatePanningVelocity(vx, vy) {
        const now = performance.now();
        const speed = Math.hypot(vx, vy);
        this._isPanningFast = speed > 0.5;
        this._lastVelocity = { x: vx, y: vy };
        this._lastVelocityTime = now;
      }
      render() {
        if (!this._map) return;
        const w = this._map.canvas.width / this._map.dpr;
        const h = this._map.canvas.height / this._map.dpr;
        const zInt = Math.floor(this._map.zoom);
        const scaleFactor = Math.pow(2, this._map.zoom - zInt);
        const ts = TILE_SIZE;
        const wrappedCenterLon = GISUtils.wrapLongitude(this._map.center.lon);
        const ct = this._map.projection.latLngToTile({ lat: this._map.center.lat, lon: wrappedCenterLon }, zInt);
        const absCos = Math.abs(Math.cos(this._map.bearing)), absSin = Math.abs(Math.sin(this._map.bearing));
        const needW = w * absCos + h * absSin;
        const needH = w * absSin + h * absCos;
        const adaptiveBuffer = this._getAdaptiveTileBuffer();
        const cols = Math.ceil(needW / (ts * scaleFactor)) + adaptiveBuffer;
        const visibleLatSpan = MAX_LATITUDE - MIN_LATITUDE;
        const visibleLatPixels = h * absCos;
        const visibleLatDegrees = visibleLatSpan * (visibleLatPixels / h);
        const rows = Math.ceil(visibleLatDegrees / (TILE_SIZE * scaleFactor)) + adaptiveBuffer;
        const startX = Math.floor(ct.x - cols / 2);
        const startY = Math.floor(ct.y - rows / 2);
        if (!this._renderTilesArray) this._renderTilesArray = [];
        else this._renderTilesArray.length = 0;
        const centerX = cols / 2;
        const centerY = rows / 2;
        for (let dx = 0; dx < cols; dx++) {
          for (let dy = 0; dy < rows; dy++) {
            const X = startX + dx, Y = startY + dy;
            const distSq = (dx - centerX) * (dx - centerX) + (dy - centerY) * (dy - centerY);
            this._renderTilesArray.push({ X, Y, distSq });
          }
        }
        this._renderTilesArray.sort((a, b) => a.distSq - b.distSq);
        const ctx = this._map.ctx;
        ctx.save();
        ctx.translate(w / 2, h / 2);
        ctx.rotate(this._map.bearing);
        ctx.scale(scaleFactor, scaleFactor);
        ctx.imageSmoothingEnabled = false;
        for (const { X, Y } of this._renderTilesArray) {
          const key = `${zInt}/${X}/${Y}`;
          const url = this._getTileUrl(X, Y, zInt);
          let tile = this.tileCache.get(key);
          if (!tile) {
            this._queueTileLoad(key, url);
            continue;
          }
          if (tile.loaded) {
            ctx.drawImage(tile.img, (X - ct.x) * ts, (Y - ct.y) * ts, ts, ts);
            tile.lastUsed = Date.now();
            if (tile.loadedAt && (Date.now() - tile.loadedAt > TILE_TTL)) {
              this._reloadTile(key, url);
            }
          }
        }
        ctx.restore();
        this._evict();
        this._preloadAdjacentZoomTiles();
        this._lastRenderedCenter = { ...this._map.center };
        this._lastRenderedZoom = this._map.zoom;
        this._lastRenderedBearing = this._map.bearing;
      }
      onAdd() { this.fire('add'); }
      onRemove() {
        for (const controller of this.loadingControllers.values()) controller.abort();
        this.loadingTiles.clear();
        this.loadingControllers.clear();
        this.tileCache.clear();
        this.fire('remove');
      }
      getAttribution() { return this.options.attribution; }
      getBackground() { return this.options.background; }
      getMinZoom() { return this.options.minZoom; }
      getMaxZoom() { return this.options.maxZoom; }
    }
    class SimpleSpatialIndex {
      constructor(cellSize = 50) { this.cellSize = cellSize; this.grid = new Map(); }
      _getCellKey(x, y) { return `${Math.floor(x / this.cellSize)},${Math.floor(y / this.cellSize)}`; }
      insert(bbox, item) {
        const startX = Math.floor(bbox.minX / this.cellSize);
        const endX = Math.floor(bbox.maxX / this.cellSize);
        const startY = Math.floor(bbox.minY / this.cellSize);
        const endY = Math.floor(bbox.maxY / this.cellSize);
        for (let x = startX; x <= endX; x++) {
          for (let y = startY; y <= endY; y++) {
            const key = `${x},${y}`;
            if (!this.grid.has(key)) this.grid.set(key, []);
            this.grid.get(key).push(item);
          }
        }
      }
      query(x, y) {
        const key = this._getCellKey(x, y);
        return this.grid.get(key) || [];
      }
      clear() { this.grid.clear(); }
    }
    class GeoJSONLayer extends Layer {
      constructor(geojson, options = {}) {
        super(options);
        this._geojson = this._normalizeGeoJSON(geojson);
        this.options = {
          style: options.style || {},
          pointToLayer: options.pointToLayer || null,
          onEachFeature: options.onEachFeature || null,
          filter: options.filter || null,
          interactive: options.interactive !== false,
          draggable: options.draggable || false,
          ...options
        };
        this._features = [];
        this._featureCache = new Map();
        this._spatialIndex = null;
        this._draggingFeature = null;
        this._dragStartPoint = null;
        this._originalCoords = null;
        this._onMouseMove = this._onMouseMove.bind(this);
        this._onMouseOut = this._onMouseOut.bind(this);
        this._onClick = this._onClick.bind(this);
        this._onMouseDown = this._onMouseDown.bind(this);
        this._onMouseMoveDrag = this._onMouseMoveDrag.bind(this);
        this._onMouseUp = this._onMouseUp.bind(this);
        this._lastRenderZoom = null;
        this._lastRenderBearing = null;
        this._lastRenderCenter = null;
      }
      _normalizeGeoJSON(geojson) {
        if (!geojson) return { type: 'FeatureCollection', features: [] };
        if (geojson.type === 'Feature') return { type: 'FeatureCollection', features: [geojson] };
        if (geojson.type === 'FeatureCollection') return geojson;
        return { type: 'FeatureCollection', features: [{ type: 'Feature', geometry: geojson, properties: {} }] };
      }
      _getFeatureStyle(feature) {
        const defaultStyle = { fillColor: '#3388ff', fillOpacity: 0.2, color: '#3388ff', weight: 3, opacity: 1, radius: 10 };
        if (typeof this.options.style === 'function') return { ...defaultStyle, ...this.options.style(feature) };
        return { ...defaultStyle, ...this.options.style };
      }
      _processFeature(feature) {
        const cacheKey = JSON.stringify(feature);
        if (this._featureCache.has(cacheKey)) return this._featureCache.get(cacheKey);
        const geometry = feature.geometry;
        if (!geometry) return null;
        let processed = null;
        switch (geometry.type) {
          case 'Point':
            const pt = this._map.latLngToContainerPoint({ lat: geometry.coordinates[1], lon: geometry.coordinates[0] });
            processed = { type: 'Point', coordinates: pt };
            break;
          case 'MultiPoint':
            processed = { type: 'MultiPoint', coordinates: geometry.coordinates.map(coord => this._map.latLngToContainerPoint({ lat: coord[1], lon: coord[0] })) };
            break;
          case 'LineString':
            processed = { type: 'LineString', coordinates: geometry.coordinates.map(coord => this._map.latLngToContainerPoint({ lat: coord[1], lon: coord[0] })) };
            break;
          case 'MultiLineString':
            processed = { type: 'MultiLineString', coordinates: geometry.coordinates.map(line => line.map(coord => this._map.latLngToContainerPoint({ lat: coord[1], lon: coord[0] }))) };
            break;
          case 'Polygon':
            processed = { type: 'Polygon', coordinates: geometry.coordinates.map(ring => ring.map(coord => this._map.latLngToContainerPoint({ lat: coord[1], lon: coord[0] }))) };
            break;
          case 'MultiPolygon':
            processed = { type: 'MultiPolygon', coordinates: geometry.coordinates.map(polygon => polygon.map(ring => ring.map(coord => this._map.latLngToContainerPoint({ lat: coord[1], lon: coord[0] })))) };
            break;
        }
        if (processed) this._featureCache.set(cacheKey, processed);
        return processed;
      }
      _renderPoint(ctx, processed, style) {
        const { x, y } = processed.coordinates;
        ctx.save();
        ctx.fillStyle = style.fillColor;
        ctx.globalAlpha = style.fillOpacity;
        ctx.beginPath();
        ctx.arc(x, y, style.radius, 0, 2 * Math.PI);
        ctx.fill();
        ctx.globalAlpha = style.opacity;
        ctx.strokeStyle = style.color;
        ctx.lineWidth = style.weight;
        ctx.stroke();
        ctx.restore();
      }
      _renderLineString(ctx, processed, style) {
        if (processed.coordinates.length < 2) return;
        ctx.save();
        ctx.strokeStyle = style.color;
        ctx.lineWidth = style.weight;
        ctx.globalAlpha = style.opacity;
        ctx.beginPath();
        ctx.moveTo(processed.coordinates[0].x, processed.coordinates[0].y);
        for (let i = 1; i < processed.coordinates.length; i++) {
          ctx.lineTo(processed.coordinates[i].x, processed.coordinates[i].y);
        }
        ctx.stroke();
        ctx.restore();
      }
      _renderPolygon(ctx, processed, style) {
        ctx.save();
        for (const ring of processed.coordinates) {
          if (ring.length < 3) continue;
          ctx.beginPath();
          ctx.moveTo(ring[0].x, ring[0].y);
          for (let i = 1; i < ring.length; i++) {
            ctx.lineTo(ring[i].x, ring[i].y);
          }
          ctx.closePath();
          if (style.fillColor && style.fillOpacity > 0) {
            ctx.fillStyle = style.fillColor;
            ctx.globalAlpha = style.fillOpacity;
            ctx.fill();
          }
          if (style.color && style.opacity > 0 && style.weight > 0) {
            ctx.strokeStyle = style.color;
            ctx.lineWidth = style.weight;
            ctx.globalAlpha = style.opacity;
            ctx.stroke();
          }
        }
        ctx.restore();
      }
      _pointInPolygon(x, y, ring) {
        let inside = false;
        for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
          if (((ring[i].y > y) !== (ring[j].y > y)) && (x < (ring[j].x - ring[i].x) * (y - ring[i].y) / (ring[j].y - ring[i].y) + ring[i].x)) {
            inside = !inside;
          }
        }
        return inside;
      }
      _hitDetect(x, y) {
        if (!this._spatialIndex) return null;
        const candidates = this._spatialIndex.query(x, y);
        for (const feature of candidates) {
          const processed = this._processFeature(feature);
          if (!processed) continue;
          const style = this._getFeatureStyle(feature);
          switch (processed.type) {
            case 'Point':
              const dx = x - processed.coordinates.x;
              const dy = y - processed.coordinates.y;
              if (Math.sqrt(dx * dx + dy * dy) <= style.radius) {
                return feature;
              }
              break;
            case 'LineString':
              for (let i = 0; i < processed.coordinates.length - 1; i++) {
                const p1 = processed.coordinates[i];
                const p2 = processed.coordinates[i + 1];
                const dist = this._pointToLineDistance(x, y, p1.x, p1.y, p2.x, p2.y);
                if (dist <= style.weight / 2 + 2) {
                  return feature;
                }
              }
              break;
            case 'Polygon':
              for (const ring of processed.coordinates) {
                if (this._pointInPolygon(x, y, ring)) {
                  return feature;
                }
              }
              break;
          }
        }
        return null;
      }
      _pointToLineDistance(px, py, x1, y1, x2, y2) {
        const A = px - x1;
        const B = py - y1;
        const C = x2 - x1;
        const D = y2 - y1;
        const dot = A * C + B * D;
        const lenSq = C * C + D * D;
        let param = -1;
        if (lenSq !== 0) param = dot / lenSq;
        let xx, yy;
        if (param < 0) {
          xx = x1;
          yy = y1;
        } else if (param > 1) {
          xx = x2;
          yy = y2;
        } else {
          xx = x1 + param * C;
          yy = y1 + param * D;
        }
        const dx = px - xx;
        const dy = py - yy;
        return Math.sqrt(dx * dx + dy * dy);
      }
      _getFeatureBBox(feature) {
        const processed = this._processFeature(feature);
        if (!processed) return null;
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        const updateBounds = (point) => {
          minX = Math.min(minX, point.x);
          minY = Math.min(minY, point.y);
          maxX = Math.max(maxX, point.x);
          maxY = Math.max(maxY, point.y);
        };
        switch (processed.type) {
          case 'Point': updateBounds(processed.coordinates); break;
          case 'MultiPoint':
          case 'LineString': processed.coordinates.forEach(updateBounds); break;
          case 'MultiLineString':
          case 'Polygon': processed.coordinates.forEach(ring => ring.forEach(updateBounds)); break;
          case 'MultiPolygon': processed.coordinates.forEach(p => p.forEach(ring => ring.forEach(updateBounds))); break;
        }
        return { minX, minY, maxX, maxY };
      }
      _buildSpatialIndex() {
        if (this._spatialIndex) {
          this._spatialIndex.clear();
        } else {
          this._spatialIndex = new SimpleSpatialIndex(50);
        }
        for (const feature of this._features) {
          const bbox = this._getFeatureBBox(feature);
          if (bbox) {
            this._spatialIndex.insert(bbox, feature);
          }
        }
      }
      _onMouseMove(e) {
        if (this._draggingFeature) return;
        const rect = this._map.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const feature = this._hitDetect(x, y);
        if (feature) {
          this._map.canvas.style.cursor = 'pointer';
          this.fire('mousemove', { originalEvent: e, feature });
        } else {
          this._map.canvas.style.cursor = 'grab';
          this.fire('mouseout', { originalEvent: e });
        }
      }
      _onMouseOut(e) {
        this._map.canvas.style.cursor = 'grab';
        this.fire('mouseout', { originalEvent: e });
      }
      _onClick(e) {
        const rect = this._map.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const feature = this._hitDetect(x, y);
        if (feature) this.fire('click', { originalEvent: e, feature });
      }
      _onMouseDown(e) {
        if (!this.options.draggable || e.button !== 0) return;
        const rect = this._map.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const feature = this._hitDetect(x, y);
        if (feature && feature.geometry.type === 'Point') {
          e.preventDefault();
          this._startDrag(feature, x, y);
        }
      }
      _startDrag(feature, clientX, clientY) {
        this._draggingFeature = feature;
        this._dragStartPoint = { x: clientX, y: clientY };
        this._originalCoords = [...feature.geometry.coordinates];
        this._map.canvas.style.cursor = 'grabbing';
        this._map.container.classList.add('dragging');
        document.addEventListener('mousemove', this._onMouseMoveDrag);
        document.addEventListener('mouseup', this._onMouseUp);
      }
      _onMouseMoveDrag(e) {
        if (!this._draggingFeature) return;
        e.preventDefault();
        const rect = this._map.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const newLatLng = this._map.screenToLatLon(x, y);
        this._draggingFeature.geometry.coordinates = [newLatLng.lon, newLatLng.lat];
        this._featureCache.clear();
        this._buildSpatialIndex();
        if (this._map) this._map.render();
        this.fire('drag', { originalEvent: e, feature: this._draggingFeature, latlng: newLatLng });
      }
      _onMouseUp(e) {
        if (!this._draggingFeature) return;
        const rect = this._map.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const finalLatLng = this._map.screenToLatLon(x, y);
        this._draggingFeature.geometry.coordinates = [finalLatLng.lon, finalLatLng.lat];
        this._featureCache.clear();
        this._buildSpatialIndex();
        this._draggingFeature = null;
        this._dragStartPoint = null;
        this._originalCoords = null;
        this._map.canvas.style.cursor = 'grab';
        this._map.container.classList.remove('dragging');
        document.removeEventListener('mousemove', this._onMouseMoveDrag);
        document.removeEventListener('mouseup', this._onMouseUp);
        this.fire('dragend', { originalEvent: e, feature: this._draggingFeature, latlng: finalLatLng });
        if (this._map) this._map.render();
      }
      onAdd() {
        this._features = this._geojson.features || [];
        this._buildSpatialIndex();
        if (this.options.interactive) {
          this._map.canvas.addEventListener('mousemove', this._onMouseMove);
          this._map.canvas.addEventListener('mouseout', this._onMouseOut);
          this._map.canvas.addEventListener('click', this._onClick);
          if (this.options.draggable) {
            this._map.canvas.addEventListener('mousedown', this._onMouseDown);
          }
        }
        this.fire('add');
      }
      onRemove() {
        if (this.options.interactive) {
          this._map.canvas.removeEventListener('mousemove', this._onMouseMove);
          this._map.canvas.removeEventListener('mouseout', this._onMouseOut);
          this._map.canvas.removeEventListener('click', this._onClick);
          if (this.options.draggable) {
            this._map.canvas.removeEventListener('mousedown', this._onMouseDown);
            document.removeEventListener('mousemove', this._onMouseMoveDrag);
            document.removeEventListener('mouseup', this._onMouseUp);
          }
        }
        this._featureCache.clear();
        if (this._spatialIndex) this._spatialIndex.clear();
        this.fire('remove');
      }
      render() {
        if (!this._map) return;
        const ctx = this._map.ctx;
        ctx.save();
        const needsRebuild = (
          this._lastRenderZoom !== this._map.zoom ||
          this._lastRenderBearing !== this._map.bearing ||
          this._lastRenderCenter?.lon !== this._map.center.lon ||
          this._lastRenderCenter?.lat !== this._map.center.lat
        );
        if (needsRebuild) {
          this._featureCache.clear();
          this._buildSpatialIndex();
          this._lastRenderZoom = this._map.zoom;
          this._lastRenderBearing = this._map.bearing;
          this._lastRenderCenter = { ...this._map.center };
        }
        for (const feature of this._features) {
          const processed = this._processFeature(feature);
          if (!processed) continue;
          const style = this._getFeatureStyle(feature);
          switch (processed.type) {
            case 'Point': this._renderPoint(ctx, processed, style); break;
            case 'LineString': this._renderLineString(ctx, processed, style); break;
            case 'Polygon': this._renderPolygon(ctx, processed, style); break;
          }
        }
        ctx.restore();
      }
      setData(geojson) {
        this._geojson = this._normalizeGeoJSON(geojson);
        this._features = this._geojson.features || [];
        this._featureCache.clear();
        this._buildSpatialIndex();
        if (this._map) this._map.render();
        return this;
      }
      getData() { return this._geojson; }
    }
    class Control {
      constructor(options = {}) { this.options = { position: options.position || 'top-left' }; this._map = null; this._container = null; this._events = {}; }
      on(type, fn) { if (!this._events[type]) this._events[type] = []; this._events[type].push(fn); return this; }
      off(type, fn) { if (!this._events[type]) return this; this._events[type] = this._events[type].filter(cb => cb !== fn); return this; }
      fire(type, data = {}) { if (!this._events[type]) return; data.type = type; data.target = this; this._events[type].forEach(fn => fn(data)); }
      onAdd() { return document.createElement('div'); }
      onRemove() {}
      addTo(map) {
        this.remove();
        this._map = map;
        this._container = this.onAdd();
        this._container.controlInstance = this;
        this._addToContainer();
        return this;
      }
      remove() {
        if (!this._map) return this;
        this.onRemove();
        if (this._container && this._container.parentNode) this._container.parentNode.removeChild(this._container);
        this._map = null;
        this._container = null;
        return this;
      }
      getContainer() { return this._container; }
      _addToContainer() {
        if (!this._map || !this._container) return;
        const position = this.options.position;
        let container = this._map._controlCorners[position];
        if (!container) {
          container = document.createElement('div');
          container.className = `atlas-control-container atlas-control-${position}`;
          if (position.includes('top') || position.includes('bottom')) container.classList.add('atlas-control-vertical');
          else container.classList.add('atlas-control-horizontal');
          this._map.container.appendChild(container);
          this._map._controlCorners[position] = container;
        }
        container.appendChild(this._container);
      }
    }
    class ZoomControl extends Control {
      constructor(options = {}) { super(options); this.options = { ...this.options, zoomInTitle: options.zoomInTitle || 'Zoom in', zoomOutTitle: options.zoomOutTitle || 'Zoom out' }; }
      onAdd() {
        const container = document.createElement('div');
        container.className = 'atlas-zoom-control';
        const zoomInBtn = document.createElement('button');
        zoomInBtn.className = 'control-btn';
        zoomInBtn.title = this.options.zoomInTitle;
        zoomInBtn.setAttribute('aria-label', this.options.zoomInTitle);
        zoomInBtn.innerHTML = '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M19 13H13V19H11V13H5V11H11V5H13V11H19V13Z" fill="currentColor"/></svg>';
        zoomInBtn.onclick = () => { if (this._map) { this._map.stopAnimations(); this._map.setZoom(this._map.getZoom() + 1); } };
        const zoomOutBtn = document.createElement('button');
        zoomOutBtn.className = 'control-btn';
        zoomOutBtn.title = this.options.zoomOutTitle;
        zoomOutBtn.setAttribute('aria-label', this.options.zoomOutTitle);
        zoomOutBtn.innerHTML = '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M19 13H5V11H19V13Z" fill="currentColor"/></svg>';
        zoomOutBtn.onclick = () => { if (this._map) { this._map.stopAnimations(); this._map.setZoom(this._map.getZoom() - 1); } };
        container.appendChild(zoomInBtn);
        container.appendChild(zoomOutBtn);
        this._zoomInBtn = zoomInBtn;
        this._zoomOutBtn = zoomOutBtn;
        return container;
      }
      _update() {
        if (!this._map || !this._zoomInBtn || !this._zoomOutBtn) return;
        const minZoom = this._map.getBaseLayer() ? this._map.getBaseLayer().getMinZoom() : 0;
        const maxZoom = this._map.getBaseLayer() ? this._map.getBaseLayer().getMaxZoom() : 18;
        const currentZoom = this._map.getZoom();
        this._zoomInBtn.disabled = currentZoom >= maxZoom;
        this._zoomOutBtn.disabled = currentZoom <= minZoom;
      }
    }
    class LayerControl extends Control {
      constructor(options = {}) { super(options); this.options = { ...this.options, title: options.title || 'Toggle layer' }; }
      onAdd() {
        const container = document.createElement('div');
        container.className = 'atlas-layer-control';
        const toggleBtn = document.createElement('button');
        toggleBtn.className = 'control-btn';
        toggleBtn.title = this.options.title;
        toggleBtn.setAttribute('aria-label', this.options.title);
        toggleBtn.innerHTML = '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 2L2 7L12 12L22 7L12 2ZM2 17L12 22L22 17M2 12L12 17L22 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>';
        toggleBtn.onclick = () => {
          if (this._map) {
            const current = this._map.getBaseLayer();
            let newLayerKey;
            if (!current || (current.urlTemplate && current.urlTemplate.includes('openstreetmap'))) newLayerKey = 'ESRI';
            else if (current.urlTemplate && current.urlTemplate.includes('World_Imagery')) newLayerKey = 'ESRI_TOPO';
            else newLayerKey = 'OSM';
            const layerConfig = LAYERS[newLayerKey];
            if (layerConfig) {
              let urlTemplate;
              if (newLayerKey === "ESRI") urlTemplate = "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}";
              else if (newLayerKey === "ESRI_TOPO") urlTemplate = "https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}";
              else {
                const subdomains = ['a', 'b', 'c'];
                const randomSubdomain = subdomains[Math.floor(Math.random() * subdomains.length)];
                urlTemplate = `https://${randomSubdomain}.tile.openstreetmap.org/{z}/{x}/{y}.png`;
              }
              const newLayer = new TileLayer(urlTemplate, {
                minZoom: layerConfig.minZoom,
                maxZoom: layerConfig.maxZoom,
                attribution: layerConfig.attribution,
                background: layerConfig.background,
                supportsRetina: layerConfig.supportsRetina,
                maxCacheSize: layerConfig.maxCacheSize
              });
              this._map.setBaseLayer(newLayer);
            }
          }
        };
        container.appendChild(toggleBtn);
        this._toggleBtn = toggleBtn;
        return container;
      }
    }
    class FullscreenControl extends Control {
      constructor(options = {}) { super(options); this.options = { ...this.options, title: options.title || 'Toggle fullscreen' }; }
      onAdd() {
        const container = document.createElement('div');
        container.className = 'atlas-fullscreen-control';
        const fullscreenBtn = document.createElement('button');
        fullscreenBtn.className = 'control-btn';
        fullscreenBtn.title = this.options.title;
        fullscreenBtn.setAttribute('aria-label', this.options.title);
        fullscreenBtn.innerHTML = '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M7 14H5V19H10V17H7V14ZM5 10H7V7H10V5H5V10ZM17 17H14V19H19V14H17V17ZM14 5V7H17V10H19V5H14Z" fill="currentColor"/></svg>';
        fullscreenBtn.onclick = () => {
          if (!document.fullscreenElement) {
            this._map.container.requestFullscreen().catch(err => console.warn(`[Atlas] Error enabling fullscreen: ${err.message}`));
          } else {
            document.exitFullscreen().catch(err => console.warn(`[Atlas] Error exiting fullscreen: ${err.message}`));
          }
        };
        container.appendChild(fullscreenBtn);
        this._fullscreenBtn = fullscreenBtn;
        return container;
      }
    }
    class AttributionControl extends Control {
      constructor(options = {}) { super(options); this.options = { ...this.options, prefix: options.prefix || '' }; }
      onAdd() {
        const container = document.createElement('div');
        container.className = 'atlas-attribution-control';
        container.id = 'attribution';
        container.innerHTML = '';
        this._container = container;
        return container;
      }
      _update() {
        if (!this._map || !this._container) return;
        const attributions = [];
        const baseLayer = this._map.getBaseLayer();
        if (baseLayer && baseLayer instanceof TileLayer) {
          const attribution = baseLayer.getAttribution();
          if (attribution) attributions.push(attribution);
        }
        if (this.options.prefix) attributions.unshift(this.options.prefix);
        this._container.innerHTML = attributions.join(' | ');
      }
    }
    class CompassControl extends Control {
      constructor(options = {}) { super(options); this.options = { ...this.options, title: options.title || 'Reset bearing' }; }
      onAdd() {
        const container = document.createElement('div');
        container.className = 'atlas-compass-control';
        const compassBtn = document.createElement('button');
        compassBtn.className = 'control-btn';
        compassBtn.title = this.options.title;
        compassBtn.setAttribute('aria-label', this.options.title);
        compassBtn.innerHTML = '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 2L13.09 8.26L22 12L13.09 15.74L12 22L10.91 15.74L2 12L10.91 8.26L12 2Z" fill="currentColor"/></svg>';
        compassBtn.onclick = () => { if (this._map) { this._map.setBearing(0); } };
        container.appendChild(compassBtn);
        this._compassBtn = compassBtn;
        return container;
      }
      _update() {
        if (!this._map || !this._compassBtn) return;
        const bearing = this._map.getBearing();
        this._compassBtn.style.transform = `rotate(${bearing * RAD2DEG}deg)`;
        this._compassBtn.style.display = Math.abs(bearing) < 0.01 ? 'none' : 'flex';
      }
    }
    class SearchProvider {
      async search(query) { throw new Error('SearchProvider.search() must be implemented'); }
      formatResult(result) { throw new Error('SearchProvider.formatResult() must be implemented'); }
    }
    class NominatimSearchProvider extends SearchProvider {
      constructor(options = {}) {
        super();
        this.options = { baseUrl: options.baseUrl || 'https://nominatim.openstreetmap.org', limit: options.limit || 5, ...options };
      }
      async search(query) {
        const url = `${this.options.baseUrl}/search?format=json&limit=${this.options.limit}&q=${encodeURIComponent(query)}`;
        const response = await fetch(url);
        if (!response.ok) throw new Error(`Search request failed: ${response.status}`);
        return await response.json();
      }
      formatResult(result) {
        return { displayName: result.display_name, lat: result.lat, lng: result.lon };
      }
    }
    class SearchControl extends Control {
      constructor(options = {}) {
        super(options);
        this.options = {
          ...this.options,
          placeholder: options.placeholder || 'Search...',
          provider: options.provider || new NominatimSearchProvider(),
          noResultsMessage: options.noResultsMessage || 'No results found',
          messageHideDelay: options.messageHideDelay || 3000
        };
        this._currentResults = [];
        this._activeResultIndex = -1;
        this._abortController = null;
        this._debounceTimer = null;
        this._searchMarker = null;
        this._resultItemCleanup = null;
        this._onInputChangeBound = this._onInputChange.bind(this);
        this._onInputKeyDownBound = this._onInputKeyDown.bind(this);
        this._onDocumentClickBound = this._onDocumentClick.bind(this);
      }
      onAdd() {
        const container = document.createElement('div');
        container.className = 'atlas-search-control';
        container.style.cssText = 'position: relative; width: 300px; max-width: 90vw;';
        const input = document.createElement('input');
        input.type = 'text';
        input.placeholder = this.options.placeholder;
        input.className = 'atlas-search-input';
        input.style.cssText = 'width: 100%; padding: 12px 16px; border: 1px solid rgba(0,0,0,0.12); border-radius: 24px; font-size: 14px; font-family: inherit; background: rgba(255,255,255,0.95); box-shadow: 0 2px 4px rgba(0,0,0,0.1); transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1); outline: none;';
        const resultsContainer = document.createElement('div');
        resultsContainer.className = 'atlas-search-results';
        resultsContainer.style.cssText = 'position: absolute; top: 100%; left: 0; right: 0; background: white; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); max-height: 200px; overflow-y: auto; z-index: 1000; display: none; margin-top: 4px;';
        const messageContainer = document.createElement('div');
        messageContainer.className = 'atlas-search-message';
        messageContainer.style.cssText = 'position: absolute; top: 100%; left: 0; right: 0; background: white; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); padding: 12px 16px; z-index: 1000; display: none; margin-top: 4px; font-size: 14px; color: #5f6368;';
        container.appendChild(input);
        container.appendChild(resultsContainer);
        container.appendChild(messageContainer);
        this._input = input;
        this._resultsContainer = resultsContainer;
        this._messageContainer = messageContainer;
        input.addEventListener('input', this._onInputChangeBound);
        input.addEventListener('keydown', this._onInputKeyDownBound);
        document.addEventListener('click', this._onDocumentClickBound);
        return container;
      }
      onRemove() {
        if (this._abortController) { this._abortController.abort(); this._abortController = null; }
        if (this._input) {
          this._input.removeEventListener('input', this._onInputChangeBound);
          this._input.removeEventListener('keydown', this._onInputKeyDownBound);
        }
        document.removeEventListener('click', this._onDocumentClickBound);
        if (this._resultItemCleanup) { this._resultItemCleanup.forEach(cleanup => cleanup()); this._resultItemCleanup = null; }
        if (this._debounceTimer) { clearTimeout(this._debounceTimer); this._debounceTimer = null; }
        if (this._resultsContainer) this._resultsContainer.style.display = 'none';
        if (this._messageContainer) this._messageContainer.style.display = 'none';
      }
      _onDocumentClick(event) {
        if (!this._container.contains(event.target)) {
          this._hideResults();
          this._hideMessage();
        }
      }
      _onInputChange(event) {
        const query = event.target.value.trim();
        if (query.length === 0) { this._hideResults(); this._hideMessage(); return; }
        if (this._debounceTimer) clearTimeout(this._debounceTimer);
        this._debounceTimer = setTimeout(() => { this._performSearch(query); }, 300);
      }
      _onInputKeyDown(event) {
        const key = event.key;
        if (key === 'ArrowDown') {
          event.preventDefault();
          this._activeResultIndex = Math.min(this._activeResultIndex + 1, this._currentResults.length - 1);
          this._updateResultHighlight();
        } else if (key === 'ArrowUp') {
          event.preventDefault();
          this._activeResultIndex = Math.max(this._activeResultIndex - 1, -1);
          this._updateResultHighlight();
        } else if (key === 'Enter' && this._activeResultIndex >= 0) {
          event.preventDefault();
          this._selectResult(this._currentResults[this._activeResultIndex]);
        } else if (key === 'Escape') {
          this._input.blur();
          this._hideResults();
          this._hideMessage();
        }
      }
      _updateResultHighlight() {
        const resultItems = this._resultsContainer.querySelectorAll('.atlas-search-result-item');
        resultItems.forEach(item => item.classList.remove('active'));
        if (this._activeResultIndex >= 0 && resultItems[this._activeResultIndex]) resultItems[this._activeResultIndex].classList.add('active');
      }
      _performSearch(query) {
        if (!query) return;
        if (this._abortController) { this._abortController.abort(); }
        this._abortController = new AbortController();
        this._showMessage('Searching...');
        this.options.provider.search(query)
          .then(data => {
            if (this._abortController.signal.aborted) return;
            this._hideMessage();
            this._displayResults(data);
          })
          .catch(error => {
            if (error.name === 'AbortError') return;
            console.error('[Atlas Search] Error fetching results:', error);
            this._showMessage('Search failed. Please try again.');
          });
      }
      _displayResults(results) {
        this._currentResults = results;
        this._activeResultIndex = -1;
        if (this._resultItemCleanup) { this._resultItemCleanup.forEach(cleanup => cleanup()); this._resultItemCleanup = []; }
        if (results.length === 0) { this._showMessage(this.options.noResultsMessage); this._hideResults(); return; }
        this._resultsContainer.innerHTML = '';
        results.forEach((result, index) => {
          const item = document.createElement('div');
          item.className = 'atlas-search-result-item';
          item.style.padding = '12px 16px';
          item.style.cursor = 'pointer';
          item.style.borderBottom = '1px solid rgba(0,0,0,0.05)';
          item.style.fontSize = '14px';
          item.style.color = '#202124';
          item.style.transition = 'background-color 0.2s cubic-bezier(0.4, 0, 0.2, 1)';
          const onMouseEnter = () => { this._activeResultIndex = index; this._updateResultHighlight(); };
          const onClick = () => { this._selectResult(result); };
          item.onmouseenter = onMouseEnter;
          item.onclick = onClick;
          const formatted = this.options.provider.formatResult(result);
          item.textContent = formatted.displayName;
          this._resultsContainer.appendChild(item);
          this._resultItemCleanup.push(() => { item.onmouseenter = null; item.onclick = null; });
        });
        const lastItem = this._resultsContainer.lastElementChild;
        if (lastItem) lastItem.style.borderBottom = 'none';
        this._resultsContainer.style.display = 'block';
      }
      _selectResult(result) {
        if (!result || !this._map) return;
        const formatted = this.options.provider.formatResult(result);
        const lat = parseFloat(formatted.lat);
        const lon = parseFloat(formatted.lng);
        if (isNaN(lat) || isNaN(lon)) { console.warn('[Atlas Search] Invalid coordinates in result:', result); return; }
        if (typeof this._map.flyToQuick === 'function') {
          this._map.flyToQuick({ center: { lat, lon }, zoom: 14, duration: 420, easing: EASING.easeInOutQuint });
        } else {
          this._map.flyTo({ center: { lat, lon }, zoom: 14, duration: 420, easing: EASING.easeInOutQuint });
        }
        if (!this._searchMarker) {
          this._searchMarker = new Marker({ position: { lat, lon }, color: 'blue', title: 'Search result', zIndex: 1100 }).addTo(this._map);
        } else {
          this._searchMarker.setLatLng({ lat, lon });
        }
        this._searchMarker.bindPopup(`<div class="atlas-popup-header">Search Result</div><div class="atlas-popup-content">${formatted.displayName}</div>`).openPopup();
        this._input.value = '';
        this._hideResults();
        this._hideMessage();
        this.fire('search:select', { result: formatted, latlng: { lat, lon } });
      }
      _showMessage(text) {
        this._hideResults();
        this._messageContainer.textContent = text;
        this._messageContainer.style.display = 'block';
        setTimeout(() => { this._hideMessage(); }, this.options.messageHideDelay);
      }
      _hideMessage() { this._messageContainer.style.display = 'none'; }
      _hideResults() { this._resultsContainer.style.display = 'none'; this._activeResultIndex = -1; }
    }
    class Handler {
      constructor(map) { this._map = map; this._enabled = false; this._eventListeners = {}; }
      enable() { if (this._enabled) return this; this._enabled = true; this._addEvents(); return this; }
      disable() { if (!this._enabled) return this; this._enabled = false; this._removeEvents(); return this; }
      toggle() { return this._enabled ? this.disable() : this.enable(); }
      isEnabled() { return this._enabled; }
      _addEvents() {}
      _removeEvents() {}
      destroy() { this.disable(); this._eventListeners = {}; }
    }
    class DragPanHandler extends Handler {
      constructor(map) { super(map); this._isDragging = false; this._dragStart = null; this._moveSamples = []; }
      _addEvents() {
        this._map.canvas.addEventListener('mousedown', this._onMouseDown = this._onMouseDown.bind(this));
        this._map.canvas.addEventListener('touchstart', this._onTouchStart = this._onTouchStart.bind(this), { passive: false });
      }
      _removeEvents() {
        this._map.canvas.removeEventListener('mousedown', this._onMouseDown);
        this._map.canvas.removeEventListener('touchstart', this._onTouchStart);
        this._removeMoveEvents();
      }
      _removeMoveEvents() {
        document.removeEventListener('mousemove', this._onMouseMove);
        document.removeEventListener('mouseup', this._onMouseUp);
        document.removeEventListener('touchmove', this._onTouchMove, { passive: false });
        document.removeEventListener('touchend', this._onTouchEnd);
        document.removeEventListener('touchcancel', this._onTouchEnd);
      }
      _onMouseDown(e) {
        if (e.button !== 0) return;
        this._startDrag(e.clientX, e.clientY);
        document.addEventListener('mousemove', this._onMouseMove = this._onMouseMove.bind(this));
        document.addEventListener('mouseup', this._onMouseUp = this._onMouseUp.bind(this));
      }
      _onMouseMove(e) {
        if (!this._isDragging) return;
        e.preventDefault();
        const dx = e.clientX - this._dragStart.x;
        const dy = e.clientY - this._dragStart.y;
        const w = this._map.canvas.width / this._map.dpr;
        const h = this._map.canvas.height / this._map.dpr;
        this._map.center = this._map.screenToLatLon(w / 2 - dx, h / 2 - dy, this._map.zoom, this._map.bearing, this._dragStart.center);
        this._pushVelocitySample(e.clientX, e.clientY);
        this._map.render();
      }
      _onMouseUp() { this._endDrag(); }
      _onTouchStart(e) {
        if (e.touches.length !== 1) return;
        e.preventDefault();
        this._startDrag(e.touches[0].clientX, e.touches[0].clientY);
        document.addEventListener('touchmove', this._onTouchMove = this._onTouchMove.bind(this), { passive: false });
        document.addEventListener('touchend', this._onTouchEnd = this._onTouchEnd.bind(this));
        document.addEventListener('touchcancel', this._onTouchEnd);
      }
      _onTouchMove(e) {
        if (!this._isDragging || e.touches.length !== 1) return;
        e.preventDefault();
        const dx = e.touches[0].clientX - this._dragStart.x;
        const dy = e.touches[0].clientY - this._dragStart.y;
        const w = this._map.canvas.width / this._map.dpr;
        const h = this._map.canvas.height / this._map.dpr;
        this._map.center = this._map.screenToLatLon(w / 2 - dx, h / 2 - dy, this._map.zoom, this._map.bearing, this._dragStart.center);
        this._pushVelocitySample(e.touches[0].clientX, e.touches[0].clientY);
        this._map.render();
      }
      _onTouchEnd() { this._endDrag(); }
      _startDrag(clientX, clientY) {
        this._isDragging = true;
        this._map.stopAnimations();
        this._map.isDragging = true;
        this._map.container.classList.add('dragging');
        this._dragStart = { x: clientX, y: clientY, center: { ...this._map.center } };
        this._moveSamples = [];
        this._pushVelocitySample(clientX, clientY);
      }
      _endDrag() {
        if (!this._isDragging) return;
        this._isDragging = false;
        this._map.isDragging = false;
        this._map.container.classList.remove('dragging');
        const { vx, vy } = this._computeVelocity();
        if (this._map._baseLayer && this._map._baseLayer instanceof TileLayer) {
          this._map._baseLayer.updatePanningVelocity(vx, vy);
        }
        this._startInertia(vx, vy);
        this._removeMoveEvents();
      }
      _pushVelocitySample(x, y) {
        const t = performance.now();
        this._moveSamples.push({ t, x, y });
        const cutoff = t - VELOCITY_WINDOW_MS;
        while (this._moveSamples.length && this._moveSamples[0].t < cutoff) this._moveSamples.shift();
      }
      _computeVelocity() {
        if (this._moveSamples.length < 2) return { vx: 0, vy: 0 };
        const last = this._moveSamples[this._moveSamples.length - 1];
        let i = this._moveSamples.length - 2;
        while (i > 0 && last.t - this._moveSamples[i].t < VELOCITY_WINDOW_MS * 0.5) i--;
        const ref = this._moveSamples[i];
        const dt = Math.max(1, last.t - ref.t);
        return { vx: (last.x - ref.x) / dt, vy: (last.y - ref.y) / dt };
      }
      _startInertia(vx, vy) {
        const speed = Math.hypot(vx, vy);
        if (speed < INERTIA_STOP_SPEED) return;
        let lastT = performance.now();
        const step = () => {
          const now = performance.now();
          const dt = now - lastT;
          lastT = now;
          const dx = vx * dt, dy = vy * dt;
          const w = this._map.canvas.width / this._map.dpr;
          const h = this._map.canvas.height / this._map.dpr;
          this._map.center = this._map.screenToLatLon(w / 2 - dx, h / 2 - dy);
          const vmag = Math.hypot(vx, vy);
          const newVmag = Math.max(0, vmag - INERTIA_DECEL * dt);
          if (newVmag <= INERTIA_STOP_SPEED) {
            this._map.render();
            this._map._inertiaRAF = null;
            this._map.fire('moveend');
            return;
          }
          const s = newVmag / (vmag || 1);
          vx *= s;
          vy *= s;
          this._map.render();
          this._map._inertiaRAF = requestAnimationFrame(step);
        };
        this._map._inertiaRAF = requestAnimationFrame(step);
      }
    }
    class ScrollZoomHandler extends Handler {
      constructor(map) { super(map); }
      _addEvents() { this._map.canvas.addEventListener('wheel', this._onWheel = this._onWheel.bind(this), { passive: false }); }
      _removeEvents() { this._map.canvas.removeEventListener('wheel', this._onWheel); }
      _onWheel(e) {
        e.preventDefault();
        const dz = (e.deltaY < 0 ? WHEEL_ZOOM_STEP : -WHEEL_ZOOM_STEP);
        this._map.smoothZoomAt(e.clientX, e.clientY, dz);
      }
    }
    class DoubleClickZoomHandler extends Handler {
      constructor(map) { super(map); this._lastClickTime = 0; this._lastClickPos = { x: 0, y: 0 }; }
      _addEvents() { this._map.canvas.addEventListener('dblclick', this._onDoubleClick = this._onDoubleClick.bind(this)); }
      _removeEvents() { this._map.canvas.removeEventListener('dblclick', this._onDoubleClick); }
      _onDoubleClick(e) {
        e.preventDefault();
        this._map.animateZoomRotateAbout(e.clientX, e.clientY, this._map.getZoom() + 1, this._map.getBearing(), TAP_ZOOM_DURATION);
      }
    }
    class TouchZoomRotateHandler extends Handler {
      constructor(map) {
        super(map);
        this._isPinching = false;
        this._pinchStartDist = 0;
        this._pinchStartAngle = 0;
        this._pinchStartZoom = map.getZoom();
        this._pinchStartBearing = map.getBearing();
        this._pinchStartTime = 0;
        this._pinchLastCenter = null;
        this._pinchMoved = false;
        this._pinchAnchorLL = null;
        this._lastTapTime = 0;
        this._lastTapPos = { x: 0, y: 0 };
        this._singleTapTimeout = null;
      }
      _addEvents() { this._map.canvas.addEventListener('touchstart', this._onTouchStart = this._onTouchStart.bind(this), { passive: false }); }
      _removeEvents() {
        this._map.canvas.removeEventListener('touchstart', this._onTouchStart);
        this._removeMoveEvents();
        if (this._singleTapTimeout) { clearTimeout(this._singleTapTimeout); this._singleTapTimeout = null; }
      }
      _removeMoveEvents() {
        document.removeEventListener('touchmove', this._onTouchMove, { passive: false });
        document.removeEventListener('touchend', this._onTouchEnd);
        document.removeEventListener('touchcancel', this._onTouchEnd);
      }
      _onTouchStart(e) {
        if (e.touches.length === 1) {
          const now = Date.now();
          const clientX = e.touches[0].clientX;
          const clientY = e.touches[0].clientY;
          if (this._singleTapTimeout) { clearTimeout(this._singleTapTimeout); this._singleTapTimeout = null; }
          if (now - this._lastTapTime < DOUBLE_TAP_MAX_DELAY && Math.hypot(clientX - this._lastTapPos.x, clientY - this._lastTapPos.y) < DOUBLE_TAP_MAX_MOVE) {
            e.preventDefault();
            this._map.animateZoomRotateAbout(clientX, clientY, this._map.getZoom() + 1, this._map.getBearing(), TAP_ZOOM_DURATION);
            this._lastTapTime = 0;
            this._lastTapPos = { x: 0, y: 0 };
            return;
          } else {
            this._lastTapTime = now;
            this._lastTapPos = { x: clientX, y: clientY };
            this._singleTapTimeout = setTimeout(() => { this._lastTapTime = 0; this._lastTapPos = { x: 0, y: 0 }; this._singleTapTimeout = null; }, DOUBLE_TAP_MAX_DELAY);
          }
        }
        if (e.touches.length < 2) return;
        e.preventDefault();
        this._startPinch(e);
        document.addEventListener('touchmove', this._onTouchMove = this._onTouchMove.bind(this), { passive: false });
        document.addEventListener('touchend', this._onTouchEnd = this._onTouchEnd.bind(this));
        document.addEventListener('touchcancel', this._onTouchEnd);
      }
      _onTouchMove(e) {
        if (!this._isPinching || e.touches.length < 2) return;
        e.preventDefault();
        this._updatePinch(e);
      }
      _onTouchEnd(e) {
        if (this._isPinching) this._endPinch(e);
      }
      _startPinch(e) {
        this._map.stopAnimations();
        this._isPinching = true;
        this._pinchStartTime = performance.now();
        this._pinchMoved = false;
        const t1 = e.touches[0], t2 = e.touches[1];
        this._pinchStartDist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
        this._pinchStartAngle = Math.atan2(t2.clientY - t1.clientY, t2.clientX - t1.clientX);
        this._pinchStartZoom = this._map.getZoom();
        this._pinchStartBearing = this._map.getBearing();
        const centerX = (t1.clientX + t2.clientX) / 2;
        const centerY = (t1.clientY + t2.clientY) / 2;
        this._pinchLastCenter = { x: centerX, y: centerY };
        this._pinchAnchorLL = this._map.screenToLatLon(centerX, centerY);
      }
      _updatePinch(e) {
        const t1 = e.touches[0], t2 = e.touches[1];
        const currentDist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
        const currentAngle = Math.atan2(t2.clientY - t1.clientY, t2.clientX - t1.clientX);
        const centerX = (t1.clientX + t2.clientX) / 2;
        const centerY = (t1.clientY + t2.clientY) / 2;
        const centerMove = Math.hypot(centerX - this._pinchLastCenter.x, centerY - this._pinchLastCenter.y);
        if (centerMove > TWO_FINGER_TAP_MOVE_THRESH) this._pinchMoved = true;
        const zoomDelta = Math.log2(currentDist / this._pinchStartDist);
        const newZoom = this._pinchStartZoom + zoomDelta;
        const angleDelta = currentAngle - this._pinchStartAngle;
        let newBearing = this._pinchStartBearing;
        if (Math.abs(angleDelta) > ROTATE_MOVE_THRESH_RAD) {
          newBearing = this._pinchStartBearing + angleDelta;
        }
        this._map.applyZoomRotateAbout(centerX, centerY, newZoom, newBearing, this._pinchAnchorLL);
        this._map.render();
      }
      _endPinch(e) {
        if (!this._isPinching) return;
        this._isPinching = false;
        const elapsed = performance.now() - this._pinchStartTime;
        if (elapsed < TWO_FINGER_TAP_MAX_DELAY && !this._pinchMoved && e.touches.length === 0) {
          const centerX = this._pinchLastCenter.x;
          const centerY = this._pinchLastCenter.y;
          this._map.animateZoomRotateAbout(centerX, centerY, this._map.getZoom() - 1, this._map.getBearing(), TAP_ZOOM_DURATION);
        }
        this._removeMoveEvents();
      }
    }
    class KeyboardPanHandler extends Handler {
      constructor(map) { super(map); this._panStep = 100; }
      _addEvents() { document.addEventListener('keydown', this._onKeyDown = this._onKeyDown.bind(this)); }
      _removeEvents() { document.removeEventListener('keydown', this._onKeyDown); }
      _onKeyDown(e) {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        const w = this._map.canvas.width / this._map.dpr;
        const h = this._map.canvas.height / this._map.dpr;
        let dx = 0, dy = 0;
        switch (e.key) {
          case 'ArrowLeft': dx = -this._panStep; break;
          case 'ArrowRight': dx = this._panStep; break;
          case 'ArrowUp': dy = -this._panStep; break;
          case 'ArrowDown': dy = this._panStep; break;
          default: return;
        }
        e.preventDefault();
        this._map.center = this._map.screenToLatLon(w / 2 + dx, h / 2 + dy);
        this._map.render();
      }
    }
    class AreaZoomHandler extends Handler {
      constructor(map) {
        super(map);
        this._isSelecting = false;
        this._startPoint = null;
        this._endPoint = null;
        this._selectionRect = null;
      }
      _addEvents() {
        this._map.canvas.addEventListener('mousedown', this._onMouseDown = this._onMouseDown.bind(this));
      }
      _removeEvents() {
        this._map.canvas.removeEventListener('mousedown', this._onMouseDown);
        this._removeMoveEvents();
      }
      _removeMoveEvents() {
        document.removeEventListener('mousemove', this._onMouseMove);
        document.removeEventListener('mouseup', this._onMouseUp);
      }
      _onMouseDown(e) {
        if (e.button !== 0 || !e.shiftKey) return;
        e.preventDefault();
        this._startSelection(e.clientX, e.clientY);
        document.addEventListener('mousemove', this._onMouseMove = this._onMouseMove.bind(this));
        document.addEventListener('mouseup', this._onMouseUp = this._onMouseUp.bind(this));
      }
      _onMouseMove(e) {
        if (!this._isSelecting) return;
        e.preventDefault();
        this._updateSelection(e.clientX, e.clientY);
      }
      _onMouseUp(e) {
        if (!this._isSelecting) return;
        this._endSelection(e.clientX, e.clientY);
        this._removeMoveEvents();
      }
      _startSelection(clientX, clientY) {
        this._isSelecting = true;
        this._map.container.classList.add('selecting');
        const rect = this._map.canvas.getBoundingClientRect();
        this._startPoint = { x: clientX - rect.left, y: clientY - rect.top };
        this._createSelectionRect();
      }
      _updateSelection(clientX, clientY) {
        const rect = this._map.canvas.getBoundingClientRect();
        this._endPoint = { x: clientX - rect.left, y: clientY - rect.top };
        this._updateSelectionRect();
      }
      _endSelection(clientX, clientY) {
        if (!this._isSelecting) return;
        this._isSelecting = false;
        this._map.container.classList.remove('selecting');
        const rect = this._map.canvas.getBoundingClientRect();
        this._endPoint = { x: clientX - rect.left, y: clientY - rect.top };
        const selectionRect = {
          x: Math.min(this._startPoint.x, this._endPoint.x),
          y: Math.min(this._startPoint.y, this._endPoint.y),
          width: Math.abs(this._endPoint.x - this._startPoint.x),
          height: Math.abs(this._endPoint.y - this._startPoint.y)
        };
        if (selectionRect.width > 10 && selectionRect.height > 10) {
          this._zoomToSelection(selectionRect);
        }
        this._removeSelectionRect();
      }
      _createSelectionRect() {
        this._selectionRect = document.createElement('div');
        this._selectionRect.style.position = 'absolute';
        this._selectionRect.style.border = '2px dashed #1a73e8';
        this._selectionRect.style.backgroundColor = 'rgba(26, 115, 232, 0.1)';
        this._selectionRect.style.pointerEvents = 'none';
        this._selectionRect.style.zIndex = '999';
        this._map.container.appendChild(this._selectionRect);
      }
      _updateSelectionRect() {
        if (!this._selectionRect || !this._startPoint || !this._endPoint) return;
        const x = Math.min(this._startPoint.x, this._endPoint.x);
        const y = Math.min(this._startPoint.y, this._endPoint.y);
        const width = Math.abs(this._endPoint.x - this._startPoint.x);
        const height = Math.abs(this._endPoint.y - this._startPoint.y);
        this._selectionRect.style.left = x + 'px';
        this._selectionRect.style.top = y + 'px';
        this._selectionRect.style.width = width + 'px';
        this._selectionRect.style.height = height + 'px';
      }
      _removeSelectionRect() {
        if (this._selectionRect && this._selectionRect.parentNode) this._selectionRect.parentNode.removeChild(this._selectionRect);
        this._selectionRect = null; this._startPoint = null; this._endPoint = null;
      }
      _zoomToSelection(rect) {
        const w = this._map.canvas.width / this._map.dpr;
        const h = this._map.canvas.height / this._map.dpr;
        const sw = this._map.screenToLatLon(rect.x, rect.y + rect.height);
        const ne = this._map.screenToLatLon(rect.x + rect.width, rect.y);
        const centerLon = (sw.lon + ne.lon) / 2;
        const centerLat = (sw.lat + ne.lat) / 2;
        const latSpanMeters = Math.abs(ne.lat - sw.lat) * 111000;
        const requiredResolution = latSpanMeters / rect.height;
        let targetZoom = this._map.zoom;
        let centerResolution = GISUtils.getResolution(centerLat, targetZoom);
        while (centerResolution > requiredResolution && targetZoom < (this._map._baseLayer?.getMaxZoom() || 18)) {
          targetZoom += 0.1;
          centerResolution = GISUtils.getResolution(centerLat, targetZoom);
        }
        const MIN_ZOOM_FOR_AREA_SELECT = 1;
        targetZoom = Math.max(MIN_ZOOM_FOR_AREA_SELECT, targetZoom - 0.5);
        this._map.flyTo({ center: { lat: centerLat, lon: centerLon }, zoom: targetZoom, duration: 800, easing: EASING.easeInOutQuint });
      }
    }
    class Overlay {
      constructor(options = {}) {
        this._map = null;
        this._el = null;
        this._events = {};
        this.options = options;
        this._pane = 'overlay';
      }
      on(type, fn) { if (!this._events[type]) this._events[type] = []; this._events[type].push(fn); return this; }
      off(type, fn) { if (!this._events[type]) return this; this._events[type] = this._events[type].filter(cb => cb !== fn); return this; }
      fire(type, data = {}) { if (!this._events[type]) return; data.type = type; data.target = this; this._events[type].forEach(fn => fn(data)); }
      addTo(map) {
        this.remove();
        this._map = map;
        if (!this._el) this._el = this.onAdd();
        const pane = this._pane === 'popup' ? this._map._popupPane : this._map._overlayPane;
        pane.appendChild(this._el);
        this._map._overlays.push(this);
        this._updatePosition(true);
        return this;
      }
      remove() {
        if (!this._map) return this;
        if (this._el && this._el.parentNode) this._el.parentNode.removeChild(this._el);
        const idx = this._map._overlays.indexOf(this);
        if (idx >= 0) this._map._overlays.splice(idx, 1);
        this.onRemove();
        this._map = null;
        return this;
      }
      onAdd() { const d = document.createElement('div'); return d; }
      onRemove() {}
      _updatePosition(force = false) {}
      getElement() { return this._el; }
    }
    
    // EXACT GOOGLE MAPS POPUP REPLICA
    class Popup extends Overlay {
      constructor(options = {}) {
        super(options);
        this._pane = 'popup';
        this._latlng = options.latlng || { lat: 0, lon: 0 };
        this._content = options.content || '';
        this.options = {
          offset: options.offset || { x: 0, y: 0 },
          className: options.className || '',
          closeButton: options.closeButton !== false,
          autoClose: options.autoClose !== false,
          maxWidth: options.maxWidth || 320,
          minWidth: options.minWidth || 200,
          maxHeight: options.maxHeight || 300,
          keepInView: options.keepInView !== false,
          closeOnClick: options.closeOnClick !== false,
          closeOnEscapeKey: options.closeOnEscapeKey !== false
        };
        this._onDocPointerDown = this._onDocPointerDown.bind(this);
        this._onKeyDown = this._onKeyDown.bind(this);
        this._orientation = 'top';
        this._isOpen = false;
      }
      setLatLng(latlng) { 
        this._latlng = { ...latlng }; 
        this._updatePosition(true); 
        return this; 
      }
      setContent(content) {
        this._content = content;
        if (this._contentNode) {
          if (typeof content === 'string') this._contentNode.innerHTML = content;
          else {
            this._contentNode.innerHTML = '';
            this._contentNode.appendChild(content);
          }
        }
        return this;
      }
      onAdd() {
        const el = document.createElement('div');
        el.className = `atlas-popup ${this._orientation} ${this.options.className || ''}`;
        el.style.maxWidth = `min(90vw, ${this.options.maxWidth}px)`;
        el.style.minWidth = `${this.options.minWidth}px`;
        const card = document.createElement('div');
        card.className = 'atlas-popup-card';
        const content = document.createElement('div');
        content.className = 'atlas-popup-content';
        content.style.maxHeight = `${this.options.maxHeight}px`;
        content.style.overflowY = 'auto';
        if (typeof this._content === 'string') content.innerHTML = this._content;
        else if (this._content instanceof Node) content.appendChild(this._content);
        const arrow = document.createElement('div');
        arrow.className = 'atlas-popup-arrow';
        if (this.options.closeButton) {
          const btn = document.createElement('button');
          btn.className = 'atlas-popup-close';
          btn.type = 'button';
          btn.setAttribute('aria-label', 'Close popup');
          btn.innerHTML = '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M19 6.41L17.59 5L12 10.59L6.41 5L5 6.41L10.59 12L5 17.59L6.41 19L12 13.41L17.59 19L19 17.59L13.41 12L19 6.41Z" fill="currentColor"/></svg>';
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            this.close();
          });
          card.appendChild(btn);
        }
        card.appendChild(content);
        el.appendChild(card);
        el.appendChild(arrow);
        this._contentNode = content;
        this._arrow = arrow;
        this._card = card;
        this._el = el;
        // Add event listeners after a brief delay to avoid immediate triggering
        setTimeout(() => {
          if (this.options.autoClose) {
            document.addEventListener('pointerdown', this._onDocPointerDown);
          }
          if (this.options.closeOnEscapeKey) {
            document.addEventListener('keydown', this._onKeyDown);
          }
        }, 0);
        this._isOpen = true;
        return el;
      }
      _onKeyDown(e) {
        if (e.key === 'Escape') {
          this.close();
        }
      }
      _onDocPointerDown(e) {
        if (!this._map || !this._el || !this._isOpen) return;
        if (this._el.contains(e.target)) return;
        if (this.options.closeOnClick && e.target === this._map.canvas) {
          this.close();
          return;
        }
        // Only close if clicking outside the popup
        this.close();
      }
      close() {
        if (!this._isOpen) return this;
        this._isOpen = false;
        if (this.options.autoClose) {
          document.removeEventListener('pointerdown', this._onDocPointerDown);
        }
        if (this.options.closeOnEscapeKey) {
          document.removeEventListener('keydown', this._onKeyDown);
        }
        this.remove();
        this.fire('close');
        return this;
      }
      openOn(map) { 
        return this.addTo(map); 
      }
      isOpen() {
        return this._isOpen;
      }
      _chooseOrientation(pt, cardRect, mapSize) {
        const margin = 16;
        // Calculate available space in each direction
        const spaceTop = pt.y - margin;
        const spaceBottom = mapSize.h - pt.y - margin;
        const spaceLeft = pt.x - margin;
        const spaceRight = mapSize.w - pt.x - margin;
        // Define marker's bounding box (exact Google Maps marker size: 27x43px)
        const markerRect = {
            x: pt.x - 13.5, // Half width
            y: pt.y - 43, // Full height (since it points down)
            width: 27,
            height: 43
        };
        // Check if 'top' position would cover the marker
        const proposedTopRect = {
            x: pt.x - cardRect.width / 2,
            y: pt.y - cardRect.height - 8, // 8px for arrow + margin
            width: cardRect.width,
            height: cardRect.height
        };
        const topWouldCoverMarker = !(
            proposedTopRect.x > markerRect.x + markerRect.width ||
            proposedTopRect.x + proposedTopRect.width < markerRect.x ||
            proposedTopRect.y > markerRect.y + markerRect.height ||
            proposedTopRect.y + proposedTopRect.height < markerRect.y
        );
        // Choose orientation based on available space and marker occlusion
        if (spaceTop > cardRect.height && !topWouldCoverMarker) {
          return 'top';
        } else if (spaceBottom > cardRect.height) {
          return 'bottom';
        } else if (spaceRight > cardRect.width / 2) {
          return 'right';
        } else if (spaceLeft > cardRect.width / 2) {
          return 'left';
        }
        // Fallback: if no ideal position, prefer top or bottom
        if (spaceTop > cardRect.height) return 'top';
        if (spaceBottom > cardRect.height) return 'bottom';
        return 'top'; // final fallback
      }
      _updatePosition(force = false) {
        if (!this._map || !this._el) return;
        const pt = this._map.latLngToContainerPoint(this._latlng);
        const w = this._map.canvas.width / this._map.dpr;
        const h = this._map.canvas.height / this._map.dpr;
        // Force reflow to get accurate dimensions
        this._el.style.display = 'block';
        const cardRect = this._card.getBoundingClientRect();
        const mapRect = this._map.container.getBoundingClientRect();
        const previousOrientation = this._orientation;
        const orientation = this._chooseOrientation(pt, cardRect, { w, h });
        if (orientation !== this._orientation) {
          this._el.classList.remove(this._orientation);
          this._el.classList.add(orientation);
          this._orientation = orientation;
          // Set the correct animation based on orientation
          this._card.style.animationName = `atlas-popup-in-${orientation}`;
        }
        // Apply offset
        let left = pt.x + (this.options.offset.x || 0);
        let top = pt.y + (this.options.offset.y || 0);
        // Keep popup in view if enabled
        if (this.options.keepInView) {
          const popupWidth = cardRect.width;
          const popupHeight = cardRect.height;
          const margin = 16; // Define the margin for keepInView
          // Adjust for orientation
          if (orientation === 'top') {
            top = top - popupHeight - 8; // 8px for the arrow + margin
            if (top < margin) {
              top = margin;
            }
          } else if (orientation === 'bottom') {
            top = top + 8; // 8px for the arrow + margin
            if (top + popupHeight > h - margin) {
              top = h - margin - popupHeight;
            }
          } else if (orientation === 'left') {
            left = left - popupWidth - 8; // 8px for the arrow + margin
            if (left < margin) {
              left = margin;
            }
          } else if (orientation === 'right') {
            left = left + 8; // 8px for the arrow + margin
            if (left + popupWidth > w - margin) {
              left = w - margin - popupWidth;
            }
          }
        }
        this._el.style.left = left + 'px';
        this._el.style.top = top + 'px';
      }
    }
    
    // EXACT GOOGLE MAPS MARKER REPLICA
    class Marker extends Overlay {
      constructor(options = {}) {
        super(options);
        this._pane = 'overlay';
        this._latlng = options.position || { lat: 0, lon: 0 };
        this.options = {
          color: options.color || 'red', // 'red', 'blue', 'green', 'yellow', 'purple'
          title: options.title || 'Marker',
          draggable: options.draggable || false,
          zIndex: options.zIndex || 1000,
          ripple: options.ripple !== false,
          size: options.size || 'normal', // 'small', 'normal', 'large'
          animation: options.animation || 'none', // 'none', 'bounce', 'pulse'
          opacity: options.opacity || 1
        };
        this._isDragging = false;
        this._boundMove = this._onPointerMove.bind(this);
        this._boundUp = this._onPointerUp.bind(this);
        this._popup = null;
        this._animationFrame = null;
        this._animationStartTime = 0;
      }
      setLatLng(latlng) { 
        this._latlng = { ...latlng };


        this._updatePosition(true); 
        if (this._popup && this._popup._map) this._popup.setLatLng(this._latlng); 
        return this; 
      }
      getLatLng() { 
        return { ...this._latlng }; 
      }
      bindPopup(content, options = {}) {
        if (!this._popup) {
          this._popup = new Popup({ 
            latlng: this._latlng, 
            content, 
            ...options 
          });
        } else {
          this._popup.setContent(content).setLatLng(this._latlng);
        }
        return this;
      }
      openPopup() {
        if (!this._popup) return this;
        this._popup.setLatLng(this._latlng).openOn(this._map);
        return this;
      }
      closePopup() { 
        if (this._popup) this._popup.close(); 
        return this; 
      }
      togglePopup() { 
        if (this._popup && this._popup.isOpen()) this._popup.close(); 
        else this.openPopup(); 
        return this; 
      }
      onAdd() {
        const el = document.createElement('div');
        el.className = 'atlas-marker';
        el.setAttribute('role', 'button');
        el.setAttribute('tabindex', '0');
        el.setAttribute('aria-label', this.options.title);
        el.style.zIndex = this.options.zIndex;
        el.style.opacity = this.options.opacity;
        // Create exact Google Maps marker
        const markerDiv = document.createElement('div');
        markerDiv.className = 'atlas-marker-google';
        // Apply color
        this._applyColor(markerDiv, this.options.color);
        // Apply size
        this._applySize(markerDiv, this.options.size);
        // Apply animation
        if (this.options.animation === 'bounce') {
          markerDiv.classList.add('atlas-marker-bounce');
        } else if (this.options.animation === 'pulse') {
          markerDiv.classList.add('atlas-marker-pulse');
        }
        el.appendChild(markerDiv);
        // Add click event with Material Design ripple
        el.addEventListener('click', (e) => { 
          e.stopPropagation(); 
          if (this._popup) this.togglePopup(); 
          this.fire('click', { latlng: this.getLatLng() }); 
          if (this.options.ripple) this._ripple(e); 
        });
        // Add keyboard support
        el.addEventListener('keydown', (e) => { 
          if (e.key === 'Enter' || e.key === ' ') { 
            e.preventDefault(); 
            el.click(); 
          } 
        });
        // Add drag support if enabled
        if (this.options.draggable) {
          el.style.touchAction = 'none';
          el.addEventListener('pointerdown', (e) => this._onPointerDown(e));
        }
        this._el = el;
        return el;
      }
      _applyColor(element, color) {
        // Remove all color classes first
        element.classList.remove('atlas-marker-red', 'atlas-marker-blue', 'atlas-marker-green', 'atlas-marker-yellow', 'atlas-marker-purple');
        
        switch(color) {
          case 'red':
            element.classList.add('atlas-marker-red');
            break;
          case 'blue':
            element.classList.add('atlas-marker-blue');
            break;
          case 'green':
            element.classList.add('atlas-marker-green');
            break;
          case 'yellow':
            element.classList.add('atlas-marker-yellow');
            break;
          case 'purple':
            element.classList.add('atlas-marker-purple');
            break;
          default:
            // Default is red
            element.classList.add('atlas-marker-red');
            break;
        }
      }
      _applySize(element, size) {
        switch(size) {
          case 'small':
            element.style.width = '20px';
            element.style.height = '32px';
            break;
          case 'large':
            element.style.width = '34px';
            element.style.height = '54px';
            break;
          case 'normal':
          default:
            // Default size (27x43px - exact Google Maps size)
            element.style.width = '27px';
            element.style.height = '43px';
            break;
        }
      }
      _ripple(e) {
        const rect = this._el.getBoundingClientRect();
        const size = Math.max(rect.width, rect.height);
        const ripple = document.createElement('div');
        ripple.className = 'atlas-ripple-google';
        ripple.style.width = size + 'px';
        ripple.style.height = size + 'px';
        ripple.style.left = (e.clientX - rect.left - size / 2) + 'px';
        ripple.style.top = (e.clientY - rect.top - size / 2) + 'px';
        this._el.appendChild(ripple);
        setTimeout(() => {
          if (ripple.parentNode) ripple.parentNode.removeChild(ripple);
        }, 600);
      }
      _onPointerDown(e) {
        if (!this.options.draggable) return;
        e.preventDefault();
        this._isDragging = true;
        this._el.style.cursor = 'grabbing';
        this._el.setPointerCapture(e.pointerId);
        document.addEventListener('pointermove', this._boundMove);
        document.addEventListener('pointerup', this._boundUp);
        this.fire('dragstart', { latlng: this.getLatLng() });
      }
      _onPointerMove(e) {
        if (!this._isDragging) return;
        e.preventDefault();
        const rect = this._map.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const newLatLng = this._map.screenToLatLon(x, y);
        this.setLatLng(newLatLng);
        this.fire('drag', { latlng: newLatLng });
      }
      _onPointerUp(e) {
        if (!this._isDragging) return;
        this._isDragging = false;
        this._el.style.cursor = 'pointer';
        this._el.releasePointerCapture(e.pointerId);
        document.removeEventListener('pointermove', this._boundMove);
        document.removeEventListener('pointerup', this._boundUp);
        this.fire('dragend', { latlng: this.getLatLng() });
      }
      _updatePosition(force = false) {
        if (!this._map || !this._el) return;
        const pt = this._map.latLngToContainerPoint(this._latlng);
        this._el.style.left = pt.x + 'px';
        this._el.style.top = pt.y + 'px';
      }
      setColor(color) {
        this.options.color = color;
        if (this._el) {
          const markerDiv = this._el.querySelector('.atlas-marker-google');
          if (markerDiv) {
            this._applyColor(markerDiv, color);
          }
        }
        return this;
      }
      setSize(size) {
        this.options.size = size;
        if (this._el) {
          const markerDiv = this._el.querySelector('.atlas-marker-google');
          if (markerDiv) {
            this._applySize(markerDiv, size);
          }
        }
        return this;
      }
      setAnimation(animation) {
        if (this._el) {
          const markerDiv = this._el.querySelector('.atlas-marker-google');
          if (markerDiv) {
            markerDiv.classList.remove('atlas-marker-bounce', 'atlas-marker-pulse');
            if (animation === 'bounce') {
              markerDiv.classList.add('atlas-marker-bounce');
            } else if (animation === 'pulse') {
              markerDiv.classList.add('atlas-marker-pulse');
            }
          }
        }
        this.options.animation = animation;
        return this;
      }
      setOpacity(opacity) {
        this.options.opacity = opacity;
        if (this._el) {
          this._el.style.opacity = opacity;
        }
        return this;
      }
    }
    class Atlas {
      constructor(id, options = {}) {
        Object.assign(CONFIG, options);
        this.canvas = document.getElementById(id);
        this.ctx = this.canvas.getContext("2d");
        this.container = document.getElementById("map-container");
        this.center = { lon: GISUtils.wrapLongitude(CONFIG.defaultCenter.lon), lat: GISUtils.clampLatitude(CONFIG.defaultCenter.lat) };
        this.zoom = CONFIG.defaultZoom;
        this.bearing = 0;
        this.renderScheduled = false;
        this.loadingEl = document.getElementById("loading");
        this.loadingCountEl = document.getElementById("loading-count");
        this._inertiaRAF = null;
        this._layers = [];
        this._baseLayer = null;
        this._events = {};
        this._controls = [];
        this._controlCorners = {};
        this._handlers = {};
        this._overlays = [];
        this.projection = DEFAULT_PROJECTION;
        this._lastImmediateRender = 0;
        this._overlayPane = document.createElement('div');
        this._overlayPane.className = 'atlas-overlay-pane';
        this._popupPane = document.createElement('div');
        this._popupPane.className = 'atlas-popup-pane';
        this.container.appendChild(this._overlayPane);
        this.container.appendChild(this._popupPane);
        this._resizeTimeout = null;
        this._onWindowResize = () => {
          if (this._resizeTimeout) clearTimeout(this._resizeTimeout);
          this._resizeTimeout = setTimeout(() => { this.resize(); this._resizeTimeout = null; }, 150);
        };
        window.addEventListener('resize', this._onWindowResize);
        this.addHandler('dragPan', DragPanHandler);
        this.addHandler('scrollZoom', ScrollZoomHandler);
        this.addHandler('doubleClickZoom', DoubleClickZoomHandler);
        this.addHandler('touchZoomRotate', TouchZoomRotateHandler);
        this.addHandler('keyboardPan', KeyboardPanHandler);
        this.addHandler('areaZoom', AreaZoomHandler);
        console.warn(
          `%c[Atlas] You are using map tiles.
%cPlease comply with the respective tile usage policies.
%c- OpenStreetMap: https://operations.osmfoundation.org/policies/tiles/
%c- Esri: https://www.esri.com/en-us/legal/terms/full-master-agreement`,
          "font-weight:bold;color:#e74c3c;", "color:#3498db;", "color:#2ecc71;", "color:#f39c12;"
        );
        this.resize();
        this.addControl(new ZoomControl({ position: 'top-right' }));
        this.addControl(new LayerControl({ position: 'top-right' }));
        this.addControl(new FullscreenControl({ position: 'top-right' }));
        this.addControl(new AttributionControl({ position: 'bottom-left' }));
        this.addControl(new CompassControl({ position: 'top-right' }));
        this.addControl(new SearchControl({ position: 'top-left' }));
        this.updateAttribution();
        this.render();
        this.fire('load');
      }
      debouncedRender(delay = 33) {
        if (this._debounceRenderTimeout) clearTimeout(this._debounceRenderTimeout);
        this._debounceRenderTimeout = setTimeout(() => { this._debounceRenderTimeout = null; this.render(); }, delay);
      }
      on(type, fn) { if (!this._events[type]) this._events[type] = []; this._events[type].push(fn); return this; }
      off(type, fn) { if (!this._events[type]) return this; this._events[type] = this._events[type].filter(cb => cb !== fn); return this; }
      fire(type, data = {}) { if (!this._events[type]) return; data.type = type; data.target = this; this._events[type].forEach(fn => fn(data)); }
      addLayer(layer) {
        if (!(layer instanceof Layer)) throw new Error('Argument must be an instance of Layer');
        if (!this._layers.includes(layer)) {
          this._layers.push(layer);
          layer._map = this;
          layer.onAdd();
          this.render();
          if (!this._baseLayer || (layer instanceof TileLayer && !this._baseLayer)) {
            this._baseLayer = layer;
            this.container.style.background = layer.getBackground();
          }
          this.updateAttribution();
        }
        return this;
      }
      removeLayer(layer) {
        const index = this._layers.indexOf(layer);
        if (index !== -1) {
          this._layers.splice(index, 1);
          layer.onRemove();
          layer._map = null;
          if (this._baseLayer === layer) {
            this._baseLayer = this._layers.find(l => l instanceof TileLayer) || null;
            if (this._baseLayer) this.container.style.background = this._baseLayer.getBackground();
          }
          this.render();
          this.updateAttribution();
        }
        return this;
      }
      setBaseLayer(newLayer) {
        if (!(newLayer instanceof TileLayer)) throw new Error('Argument must be an instance of TileLayer');
        if (this._baseLayer && this._baseLayer !== newLayer) this.removeLayer(this._baseLayer);
        if (!this._layers.includes(newLayer)) this.addLayer(newLayer);
        else {
          this._baseLayer = newLayer;
          this.container.style.background = newLayer.getBackground();
          this.zoom = Math.max(newLayer.getMinZoom(), Math.min(newLayer.getMaxZoom(), this.zoom));
          this.render();
          this.updateAttribution();
        }
        return this;
      }
      getBaseLayer() { return this._baseLayer; }
      addControl(control) { if (!(control instanceof Control)) throw new Error('Argument must be an instance of Control'); this._controls.push(control); control.addTo(this); return this; }
      removeControl(control) {
        const index = this._controls.indexOf(control);
        if (index !== -1) { this._controls.splice(index, 1); control.remove(); }
        return this;
      }
      addOverlay(overlay) { if (!(overlay instanceof Overlay)) throw new Error('Argument must be an instance of Overlay'); overlay.addTo(this); return overlay; }
      removeOverlay(overlay) { overlay.remove(); return this; }
      getControls() { return [...this._controls]; }
      addHandler(name, HandlerClass) { if (this._handlers[name]) { console.warn(`Handler '${name}' already exists.`); return this; } this._handlers[name] = new HandlerClass(this); this._handlers[name].enable(); return this; }
      removeHandler(name) { if (!this._handlers[name]) return this; this._handlers[name].destroy(); delete this._handlers[name]; return this; }
      getHandler(name) { return this._handlers[name] || null; }
      enableHandler(name) { const handler = this.getHandler(name); if (handler) handler.enable(); return this; }
      disableHandler(name) { const handler = this.getHandler(name); if (handler) handler.disable(); return this; }
      getHandlers() { return { ...this._handlers }; }
      setZoom(z) {
        const minZoom = this._baseLayer ? this._baseLayer.getMinZoom() : 0;
        const maxZoom = this._baseLayer ? this._baseLayer.getMaxZoom() : 18;
        const nz = Math.max(minZoom, Math.min(maxZoom, z));
        if (nz === this.zoom) return;
        this.zoom = nz;
        this.render();
        this.showZoomOverlay();
        this.updateControlsUI();
        this.fire('zoom');
      }
      setBearing(rad) {
        const nr = normalizeAngle(rad);
        if (Math.abs(nr - this.bearing) < 1e-6) return;
        this.bearing = nr;
        this.render();
        this.fire('rotate');
      }
      showZoomOverlay() {}
      stopInertia() { if (this._inertiaRAF) cancelAnimationFrame(this._inertiaRAF); this._inertiaRAF = null; }
      stopAnimations() {
        this.stopInertia();
        if (this._zoomAnim?.raf) cancelAnimationFrame(this._zoomAnim.raf);
        this._zoomAnim = null;
        if (this._flyAnim?.raf) cancelAnimationFrame(this._flyAnim.raf);
        this._flyAnim = null;
      }
      resize() {
        const w = this.container.offsetWidth, h = this.container.offsetHeight;
        this.dpr = window.devicePixelRatio || 1;
        this.canvas.width = w * this.dpr;
        this.canvas.height = h * this.dpr;
        this.canvas.style.width = w + "px";
        this.canvas.style.height = h + "px";
        this.ctx.setTransform(this.dpr, 0, 0, this.dpr, 0, 0);
        this.render();
        this.fire('resize');
      }
      scheduleRender() {
        if (this.renderScheduled) return;
        this.renderScheduled = true;
        requestAnimationFrame(() => { this.renderScheduled = false; this._draw(); });
      }
      render(immediate = false) {
        if (immediate) {
          const now = performance.now();
          if (!this._lastImmediateRender || (now - this._lastImmediateRender) > 8) {
            this._lastImmediateRender = now;
            this._draw();
          } else {
            requestAnimationFrame(() => this._draw());
          }
        } else {
          if (this.renderScheduled) return;
          this.renderScheduled = true;
          requestAnimationFrame(() => { this.renderScheduled = false; this._draw(); });
        }
      }
      _snapCanvasToPixelGrid() {
        const currentTransform = this.ctx.getTransform();
        const physicalTranslateX = currentTransform.e * this.dpr;
        const physicalTranslateY = currentTransform.f * this.dpr;
        const snapX = - (physicalTranslateX % 1) / this.dpr;
        const snapY = - (physicalTranslateY % 1) / this.dpr;
        this.ctx.translate(snapX, snapY);
      }
      _updateOverlays() {
        for (const ov of this._overlays) {
          try { ov._updatePosition(); } catch (e) { console.error('[Atlas] Overlay update error:', e); }
        }
      }
      _draw() {
        const backgroundColor = this._baseLayer ? this._baseLayer.getBackground() : '#000';
        const w = this.canvas.width / this.dpr, h = this.canvas.height / this.dpr;
        this.ctx.fillStyle = backgroundColor;
        this.ctx.fillRect(0, 0, w, h);
        for (const layer of this._layers) {
          try { layer.render(); } catch (error) { console.error(`[Atlas] Error rendering layer:`, error); }
        }
        this._snapCanvasToPixelGrid();
        this._updateOverlays();
        let loadingCount = 0;
        if (this._baseLayer && this._baseLayer instanceof TileLayer) loadingCount = this._baseLayer.loadingTiles.size;
        this.loadingEl.classList.toggle("visible", loadingCount > 0);
        this.loadingCountEl.textContent = loadingCount;
        this.updateControlsUI();
        this.fire('moveend');
      }
      updateAttribution() { for (const control of this._controls) { if (control instanceof AttributionControl && typeof control._update === 'function') control._update(); } }
      updateControlsUI() { for (const control of this._controls) { if (typeof control._update === 'function') control._update(); } }
      getCenter() { return { ...this.center }; }
      getZoom() { return this.zoom; }
      getBearing() { return this.bearing; }
      screenToLatLon(ax, ay, zoom = this.zoom, bearing = this.bearing, center = this.center) {
        const w = this.canvas.width / this.dpr;
        const h = this.canvas.height / this.dpr;
        const zInt = Math.floor(zoom);
        const ts = TILE_SIZE * Math.pow(2, zoom - zInt);
        const ct = this.projection.latLngToTile(center, zInt);
        const anchorVec = { x: ax - w / 2, y: ay - h / 2 };
        const v = rot(anchorVec.x / ts, anchorVec.y / ts, -bearing);
        const tpt = { x: ct.x + v.x, y: ct.y + v.y };
        const ll = this.projection.tileToLatLng(tpt.x, tpt.y, zInt);
        return { lon: GISUtils.wrapLongitude(ll.lon), lat: GISUtils.clampLatitude(ll.lat) };
      }
      lonLatToTile(lon, lat, z) { return this.projection.latLngToTile({ lat, lon }, z); }
      latLngToContainerPoint(latlng) {
        const w = this.canvas.width / this.dpr;
        const h = this.canvas.height / this.dpr;
        const zInt = Math.floor(this.zoom);
        const ts = TILE_SIZE * Math.pow(2, this.zoom - zInt);
        const ct = this.projection.latLngToTile(this.center, zInt);
        const pt = this.projection.latLngToTile(latlng, zInt);
        const trX = (pt.x - ct.x) * ts;
        const trY = (pt.y - ct.y) * ts;
        const anchorVec = rot(trX, trY, this.bearing);
        return { x: w / 2 + anchorVec.x, y: h / 2 + anchorVec.y };
      }
      applyZoomRotateAbout(ax, ay, newZoom, newBearing, anchorLL = null) {
        const minZoom = this._baseLayer ? this._baseLayer.getMinZoom() : 0;
        const maxZoom = this._baseLayer ? this._baseLayer.getMaxZoom() : 18;
        newZoom = Math.max(minZoom, Math.min(maxZoom, newZoom));
        const w = this.canvas.width / this.dpr;
        const h = this.canvas.height / this.dpr;
        const anchorVec = { x: ax - w / 2, y: ay - h / 2 };
        const currAnchorLL = anchorLL || this.screenToLatLon(ax, ay, this.zoom, this.bearing, this.center);
        const zInt = Math.floor(newZoom);
        const ts = TILE_SIZE * Math.pow(2, newZoom - zInt);
        const Ptile = this.projection.latLngToTile(currAnchorLL, zInt);
        const v = rot(anchorVec.x / ts, anchorVec.y / ts, -newBearing);
        const ctNew = { x: Ptile.x - v.x, y: Ptile.y - v.y };
        const newCenter = this.projection.tileToLatLng(ctNew.x, ctNew.y, zInt);
        this.center = { lon: GISUtils.wrapLongitude(newCenter.lon), lat: GISUtils.clampLatitude(newCenter.lat) };
        this.zoom = newZoom;
        this.bearing = normalizeAngle(newBearing);
      }
      showZoomIndicator(x, y) {
        if (this._zoomIndicator) this.container.removeChild(this._zoomIndicator);
        const indicator = document.createElement("div");
        indicator.style.position = "absolute";
        indicator.style.left = (x - 15) + "px";
        indicator.style.top = (y - 15) + "px";
        indicator.style.width = "30px";
        indicator.style.height = "30px";
        indicator.style.borderRadius = "50%";
        indicator.style.border = "2px solid #333";
        indicator.style.opacity = "0.8";
        indicator.style.pointerEvents = "none";
        indicator.style.zIndex = "100";
        indicator.style.animation = "zoom-indicator 0.6s ease-out forwards";
        this.container.appendChild(indicator);
        this._zoomIndicator = indicator;
        setTimeout(() => {
          if (this._zoomIndicator && this._zoomIndicator.parentNode) {
            this.container.removeChild(this._zoomIndicator);
            this._zoomIndicator = null;
          }
        }, 600);
      }
      showPulseAtLatLng(latlng) { const pt = this.latLngToContainerPoint(latlng); this.showZoomIndicator(pt.x, pt.y); }
      animateZoomRotateAbout(ax, ay, toZoom, toBearing = this.bearing, duration = WHEEL_ZOOM_DURATION, easing = EASING.easeInOutCubic) {
        this.showZoomIndicator(ax, ay);
        this.stopAnimations();
        const startT = performance.now();
        const sZoom = this.zoom;
        const sBear = this.bearing;
        const deltaBear = shortestAngleDiff(sBear, toBearing);
        const anchorLL = this.screenToLatLon(ax, ay, this.zoom, this.bearing, this.center);
        let isAnimating = true;
        const step = (timestamp) => {
          if (!isAnimating) { this._zoomAnim = null; return; }
          const elapsed = timestamp - startT;
          let t = elapsed / Math.max(1, duration);
          if (elapsed >= duration) t = 1;
          const p = t >= 1 ? 1 : easing(Math.max(0, Math.min(1, t)));
          const z = sZoom + (toZoom - sZoom) * p;
          const b = sBear + deltaBear * p;
          this.applyZoomRotateAbout(ax, ay, z, b, anchorLL);
          this.render();
          if (t >= 1) { isAnimating = false; this._zoomAnim = null; this.fire('zoomend'); return; }
          this._zoomAnim = { raf: requestAnimationFrame(step) };
        };
        this._zoomAnim = { raf: requestAnimationFrame(step) };
      }
      smoothZoomAt(ax, ay, deltaZoom, duration = WHEEL_ZOOM_DURATION) {
        const targetZoom = this.zoom + deltaZoom;
        this.animateZoomRotateAbout(ax, ay, targetZoom, this.bearing, duration);
      }
      flyTo(options = {}) {
        const { center = this.center, zoom = this.zoom, bearing = this.bearing, duration = FLYTO_DURATION, easing = EASING.easeInOutQuint } = options;
        this.stopAnimations();
        const startT = performance.now();
        const sCenter = { ...this.center };
        const sZoom = this.zoom;
        const sBearing = this.bearing;
        const deltaLat = center.lat - sCenter.lat;
        const deltaLon = wrapDeltaLon(center.lon - sCenter.lon);
        const deltaZoom = zoom - sZoom;
        const deltaBearing = shortestAngleDiff(sBearing, bearing);
        let isAnimating = true;
        const step = (timestamp) => {
          if (!isAnimating) { this._flyAnim = null; return; }
          const elapsed = timestamp - startT;
          let t = elapsed / Math.max(1, duration);
          if (elapsed >= duration) t = 1;
          const p = t >= 1 ? 1 : easing(Math.max(0, Math.min(1, t)));
          this.center = {
            lat: GISUtils.clampLatitude(sCenter.lat + deltaLat * p),
            lon: GISUtils.wrapLongitude(sCenter.lon + deltaLon * p)
          };
          this.zoom = sZoom + deltaZoom * p;
          this.bearing = normalizeAngle(sBearing + deltaBearing * p);
          this.render();
          if (t >= 1) { isAnimating = false; this._flyAnim = null; this.fire('moveend'); return; }
          this._flyAnim = { raf: requestAnimationFrame(step) };
        };
        this._flyAnim = { raf: requestAnimationFrame(step) };
      }
      flyToQuick(options = {}) {
        const { center = this.center, zoom = this.zoom, bearing = this.bearing, duration = 420, easing = EASING.easeInOutQuint } = options;
        this.flyTo({ center, zoom, bearing, duration, easing });
      }
      setView(center, zoom, options = {}) {
        if (options.animate !== false) {
          this.flyTo({ center, zoom, duration: options.duration || FLYTO_DURATION });
        } else {
          this.center = { lon: GISUtils.wrapLongitude(center.lon), lat: GISUtils.clampLatitude(center.lat) };
          this.zoom = zoom;
          this.render();
        }
        return this;
      }
      panTo(center, options = {}) {
        if (options.animate !== false) {
          this.flyTo({ center, zoom: this.zoom, duration: options.duration || FLYTO_DURATION });
        } else {
          this.center = { lon: GISUtils.wrapLongitude(center.lon), lat: GISUtils.clampLatitude(center.lat) };
          this.render();
        }
        return this;
      }
      zoomTo(zoom, options = {}) {
        if (options.animate !== false) {
          this.flyTo({ center: this.center, zoom, duration: options.duration || FLYTO_DURATION });
        } else {
          this.setZoom(zoom);
        }
        return this;
      }
      fitBounds(bounds, options = {}) {
        const { padding = 20 } = options;
        const sw = bounds[0];
        const ne = bounds[1];
        const centerLat = (sw.lat + ne.lat) / 2;
        const centerLon = (sw.lon + ne.lon) / 2;
        const latSpan = Math.abs(ne.lat - sw.lat);
        const lonSpan = Math.abs(ne.lon - sw.lon);
        const w = this.canvas.width / this.dpr - padding * 2;
        const h = this.canvas.height / this.dpr - padding * 2;
        const latZoom = Math.log2(h * 180 / (latSpan * TILE_SIZE));
        const lonZoom = Math.log2(w * 360 / (lonSpan * TILE_SIZE));
        const targetZoom = Math.min(latZoom, lonZoom);
        const minZoom = this._baseLayer ? this._baseLayer.getMinZoom() : 0;
        const maxZoom = this._baseLayer ? this._baseLayer.getMaxZoom() : 18;
        const clampedZoom = Math.max(minZoom, Math.min(maxZoom, targetZoom));
        this.setView({ lat: centerLat, lon: centerLon }, clampedZoom, options);
        return this;
      }
    }
    
    // Initialize the map when the page loads
    window.addEventListener('DOMContentLoaded', () => {
      // Create the map instance
      const map = new Atlas('map', {
        defaultCenter: { lat: 40.7128, lon: -74.0060 }, // New York City
        defaultZoom: 10
      });
      
      // Add the default OpenStreetMap layer
      const osmLayer = new TileLayer('https://a.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '© <a href="https://www.openstreetmap.org/copyright" target="_blank" rel="noopener noreferrer">OpenStreetMap contributors</a>',
        maxZoom: 19
      });
      map.addLayer(osmLayer);
      
      // Add some example markers with Google Maps styling
      const marker1 = new Marker({
        position: { lat: 40.7128, lon: -74.0060 },
        color: 'red',
        title: 'New York City',
        draggable: true
      }).addTo(map);
      
      marker1.bindPopup(`
        <div class="atlas-popup-header">New York City</div>
        <div class="atlas-popup-content">The most populous city in the United States, located in the state of New York.</div>
      `);
      
      const marker2 = new Marker({
        position: { lat: 40.7589, lon: -73.9851 },
        color: 'blue',
        title: 'Times Square',
        animation: 'pulse'
      }).addTo(map);
      
      marker2.bindPopup(`
        <div class="atlas-popup-header">Times Square</div>
        <div class="atlas-popup-content">A major commercial intersection, tourist destination, entertainment center, and neighborhood in Midtown Manhattan.</div>
      `);
      
      const marker3 = new Marker({
        position: { lat: 40.6892, lon: -74.0445 },
        color: 'green',
        title: 'Statue of Liberty',
        size: 'large'
      }).addTo(map);
      
      marker3.bindPopup(`
        <div class="atlas-popup-header">Statue of Liberty</div>
        <div class="atlas-popup-content">A neoclassical sculpture on Liberty Island in New York Harbor within New York City.</div>
      `);
      
      // Make the map globally accessible for debugging
      window.map = map;
      window.Marker = Marker;
      window.Popup = Popup;
      window.TileLayer = TileLayer;
      window.GeoJSONLayer = GeoJSONLayer;
    });
  </script>
</body>
</html>

