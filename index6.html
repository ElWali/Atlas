<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="referrer" content="origin">
  <title>Atlas.js - Lightweight JavaScript Mapping Library</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      font-family: sans-serif;
    }
    #map-container {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      touch-action: none;
      cursor: grab;
    }
    #map-container.dragging { cursor: grabbing; }
    #map {
      width: 100%;
      height: 100%;
      display: block;
    }
    .controls {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      flex-direction: column;
      gap: 5px;
      z-index: 10;
    }
    .control-btn {
      background: rgba(255,255,255,0.9);
      border: 1px solid #ccc;
      font-size: 16px;
      padding: 4px 8px;
      cursor: pointer;
      border-radius: 3px;
      user-select: none;
    }
    .control-btn:hover {
      background: rgba(240,240,240,0.9);
    }
    .control-btn:active {
      background: rgba(224,224,224,0.9);
      transform: scale(0.95);
      transition: transform 0.05s;
    }
    .control-btn:focus {
      outline: 2px solid #0078A8;
      outline-offset: 2px;
    }
    .control-btn:disabled {
      background: rgba(245,245,245,0.9);
      color: #aaa;
      cursor: not-allowed;
      transform: none;
      border-color: #ddd;
    }
    #loading {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255,255,255,0.9);
      padding: 4px 8px;
      border-radius: 3px;
      font-size: 12px;
      display: none;
    }
    #loading.visible { display: block; }
    #coords {
      position: absolute;
      bottom: 25px;
      left: 5px;
      background: rgba(255,255,255,0.7);
      font-size: 12px;
      padding: 2px 6px;
      border-radius: 2px;
    }
    #zoom-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%,-50%);
      background: rgba(255,255,255,0.8);
      font-size: 20px;
      padding: 6px 12px;
      border-radius: 4px;
      opacity: 0;
      transition: opacity 0.25s;
      pointer-events: none;
    }
    .scale-bar-container {
      position: absolute;
      bottom: 5px;
      right: 10px;
      text-align: center;
      font-size: 11px;
      color: #fff;
      cursor: pointer;
    }
    .scale-bar {
      height: 4px;
      background: #fff;
      margin-bottom: 2px;
    }
    #attribution {
      position: absolute;
      bottom: 5px;
      left: 10px;
      background: rgba(0,0,0,0.5);
      color: #fff;
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: sans-serif;
    }
    #attribution a {
      text-decoration: none;
      color: #4d90fe;
    }
    #fullscreen {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255,255,255,0.9);
      border: 1px solid #ccc;
      padding: 4px 8px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 16px;
      z-index: 10;
    }

    @keyframes zoom-indicator {
      0%   { transform: scale(0.2); opacity: 0.8; }
      100% { transform: scale(1.2); opacity: 0; }
    }

    /* --- Marker & Popup Styles (Leaflet-like) --- */
    .popup {
      position: absolute;
      text-align: center;
      font-family: Arial, Helvetica, sans-serif;
      font-size: 12px;
      line-height: 1.4;
      box-shadow: 0 3px 14px rgba(0,0,0,0.4);
      padding: 0;
      border-radius: 12px;
      border: 1px solid #cccccc;
      background: #fff;
      z-index: 11;
      display: none;
    }
    .popup-content-wrapper { padding: 1px; text-align: left; border-radius: 12px; }
    .popup-content { margin: 13px 19px; line-height: 1.3; font-size: 13px; }
    .popup-tip-container {
      margin: 0 auto;
      width: 40px;
      height: 20px;
      position: relative;
      overflow: hidden;
    }
    .popup-tip {
      width: 17px;
      height: 17px;
      padding: 1px;
      margin: -10px auto 0;
      transform: rotate(45deg);
      background: #fff;
      border: 1px solid #999;
      box-shadow: 0 3px 14px rgba(0,0,0,0.4);
      border-top: none;
      border-left: none;
    }
    .popup-close-button {
      position: absolute;
      top: 0;
      right: 0;
      padding: 4px 4px 0 0;
      border: none;
      text-align: center;
      width: 18px;
      height: 14px;
      font: 16px/14px Tahoma, Verdana, sans-serif;
      color: #c3c3c3;
      text-decoration: none;
      font-weight: bold;
      background: transparent;
      cursor: pointer;
    }
    .popup-close-button:hover { color: #999; }

    .marker-container {
      position: absolute;
      pointer-events: none;
      z-index: 10;
      user-drag: none;
    }
    .marker-icon {
      display: block;
      width: 25px;
      height: 41px;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 384 512'%3E%3Cpath fill='%23007acc' d='M215.7 499.2C267 435 384 279.4 384 192C384 86 298 0 192 0S0 86 0 192c0 87.4 117 243 168.3 307.2c12.3 15.3 35.1 15.3 47.4 0zM192 256c-35.3 0-64-28.7-64-64s28.7-64 64-64s64 28.7 64 64s-28.7 64-64 64z'/%3E%3C/svg%3E");
      background-size: cover;
      background-repeat: no-repeat;
    }
    .marker-shadow {
      position: absolute;
      width: 41px;
      height: 41px;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'%3E%3Cpath fill='%23000' fill-opacity='0.2' d='M256 80c0-16.57-13.43-32-32-32s-32 15.43-32 32c0 16.57 13.43 32 32 32S256 96.57 256 80zM416 32c0-16.57-13.43-32-32-32s-32 15.43-32 32c0 16.57 13.43 32 32 32S416 48.57 416 32zM96 32c0-16.57-13.43-32-32-32S32 15.43 32 32c0 16.57 13.43 32 32 32S96 48.57 96 32zM480 96c-16.57 0-32 13.43-32 32s15.43 32 32 32s32-13.43 32-32S496.6 96 480 96zM32 96c-16.57 0-32 13.43-32 32s15.43 32 32 32s32-13.43 32-32S48.57 96 32 96zM480 192c-16.57 0-32 13.43-32 32s15.43 32 32 32s32-13.43 32-32S496.6 192 480 192zM32 192c-16.57 0-32 13.43-32 32s15.43 32 32 32s32-13.43 32-32S48.57 192 32 192zM256 480c16.57 0 32-13.43 32-32s-13.43-32-32-32s-32 13.43-32 32S239.4 480 256 480zM416 352c16.57 0 32-13.43 32-32s-13.43-32-32-32s-32 13.43-32 32S399.4 352 416 352zM96 352c16.57 0 32-13.43 32-32s-13.43-32-32-32s-32 13.43-32 32S79.43 352 96 352z'/%3E%3C/svg%3E");
      background-size: cover;
      background-repeat: no-repeat;
      opacity: 0.8;
      left: -13px;
      top: 0px;
    }
    /* --- End Marker & Popup Styles --- */
  </style>
</head>
<body>
  <div id="map-container">
    <canvas id="map"></canvas>

    <div class="controls">
      <button id="zoom-in"  class="control-btn" aria-label="Zoom in">+</button>
      <button id="zoom-out" class="control-btn" aria-label="Zoom out">‚àí</button>
      <button id="layer-toggle" class="control-btn" aria-label="Toggle layer">üåê</button>
    </div>

    <button id="fullscreen" class="control-btn" aria-label="Toggle fullscreen">‚õ∂</button>
    <div id="loading">Loading: <span id="loading-count">0</span></div>
    <div id="zoom-overlay"></div>
    <div id="coords"></div>

    <div class="scale-bar-container">
      <div class="scale-bar"></div>
      <div id="scale-text"></div>
    </div>

    <div id="attribution"></div>

    <!-- Marker & Popup HTML -->
    <div id="popup" class="popup">
      <div class="popup-content-wrapper">
        <div id="popup-content" class="popup-content"></div>
        <div class="popup-tip-container">
          <div class="popup-tip"></div>
        </div>
        <a class="popup-close-button" id="popup-close" href="#close">&times;</a>
      </div>
    </div>
    <!-- End Marker & Popup HTML -->

  </div>

  <script>
    // --- Constants ---
    const EARTH_RADIUS              = 6378137;
    const EARTH_CIRCUMFERENCE       = 2 * Math.PI * EARTH_RADIUS;
    const MAX_LATITUDE              = 85.05112878;
    const MIN_LATITUDE              = -85.05112878;
    const TILE_SIZE                 = 256;
    const TILE_BUFFER               = 3;
    const TILE_TTL                  = 1000 * 60 * 60 * 24; // 24h
    const TILE_LOAD_TIMEOUT_MS      = 10000;              // 10s
    const SCALE_BAR_TARGET_PX       = 120;
    const INERTIA_DECEL             = 0.0025;
    const INERTIA_STOP_SPEED        = 0.02;
    const VELOCITY_WINDOW_MS        = 120;
    const DOUBLE_TAP_MAX_DELAY      = 300;
    const DOUBLE_TAP_MAX_MOVE       = 16;
    const TWO_FINGER_TAP_MAX_DELAY  = 250;
    const TWO_FINGER_TAP_MOVE_THRESH= 10;
    const ROTATE_MOVE_THRESH_RAD    = 0.08;
    const WHEEL_ZOOM_STEP           = 0.25;
    const WHEEL_ZOOM_DURATION       = 220;
    const TAP_ZOOM_DURATION         = 280;
    const SNAP_DURATION             = 300;
    const FLYTO_DURATION            = 800;

    // Popup auto-pan
    const POPUP_AUTO_PAN_PADDING    = { x:20, y:20 };
    const POPUP_AUTO_PAN_DURATION   = 300;

    // Layers
    const LAYERS = {
      OSM: {
        name: "OpenStreetMap",
        minZoom:0, maxZoom:19,
        tileServers:["https://tile.openstreetmap.org"],
        attribution: '¬© <a href="https://www.openstreetmap.org/copyright" target="_blank" rel="noopener noreferrer">OSM contributors</a>',
        background:"#e6e6e6",
        supportsRetina:true,
        maxCacheSize:500
      },
      ESRI: {
        name:"Esri Satellite",
        minZoom:0, maxZoom:19,
        tileServers:["https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile"],
        attribution: 'Tiles ¬© <a href="https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer" target="_blank" rel="noopener noreferrer">Esri</a>',
        background:"#000000",
        supportsRetina:false,
        maxCacheSize:400
      }
    };

    // Config
    const CONFIG = {
      defaultLayer:"OSM",
      defaultCenter:{ lon: 0, lat: 0 },
      defaultZoom:3,
      retina:"auto",
      retinaSuffix:"@2x"
    };

    // Easing
    const EASING = {
      easeInOutCubic: t => t<0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2,
      easeOutCubic:   t => 1 - Math.pow(1-t,3),
      linear:         t => t
    };

    const RAD2DEG = 180/Math.PI;
    const DEG2RAD = Math.PI/180;

    // Utility functions...
    function normalizeAngle(rad) {
      return Math.atan2(Math.sin(rad), Math.cos(rad));
    }
    function shortestAngleDiff(from, to) {
      return normalizeAngle(to - from);
    }
    function wrapDeltaLon(delta) {
      return ((delta+180)%360+360)%360 - 180;
    }
    function rot(x,y,ang) {
      const c=Math.cos(ang), s=Math.sin(ang);
      return { x: x*c - y*s, y: x*s + y*c };
    }

    class GISUtils {
      static toRadians(d) { return d * Math.PI / 180; }
      static toDegrees(r) { return r * 180 / Math.PI; }
      static wrapLongitude(l) {
        while(l>180) l-=360;
        while(l<-180)l+=360;
        return l;
      }
      static clampLatitude(lat) {
        return Math.max(MIN_LATITUDE, Math.min(MAX_LATITUDE, lat));
      }
      static getResolution(lat, z) {
        return (EARTH_CIRCUMFERENCE * Math.cos(this.toRadians(lat)))
             / (Math.pow(2,z) * TILE_SIZE);
      }
      static formatDistance(m) {
        return m<1000 ? Math.round(m)+" m" : (m/1000).toFixed(1)+" km";
      }
      static tileToLonLat(x,y,z) {
        const scale=Math.pow(2,z);
        const lon = x/scale*360 - 180;
        const n = Math.PI - 2*Math.PI*y/scale;
        const lat = this.toDegrees(Math.atan(Math.sinh(n)));
        return { lon, lat };
      }
    }

    class Atlas {
      constructor(id, options={}) {
        Object.assign(CONFIG, options);
        this.canvas = document.getElementById(id);
        this.ctx    = this.canvas.getContext("2d");
        this.container   = document.getElementById("map-container");
        this.tileCache   = new Map();
        this.loadingTiles= new Set();
        this.currentLayer= CONFIG.defaultLayer;
        this.layerConfig = LAYERS[this.currentLayer];
        this.center = {
          lon: GISUtils.wrapLongitude(CONFIG.defaultCenter.lon),
          lat: GISUtils.clampLatitude(CONFIG.defaultCenter.lat)
        };
        this.zoom    = CONFIG.defaultZoom;
        this.bearing = 0;
        this.isDragging = false;
        this.dragStart  = null;
        this.renderScheduled = false;
        this.zoomOverlay     = document.getElementById("zoom-overlay");
        this.loadingEl       = document.getElementById("loading");
        this.loadingCountEl  = document.getElementById("loading-count");
        this.coordsEl        = document.getElementById("coords");
        this.scaleBarEl      = document.querySelector(".scale-bar");
        this.scaleTextEl     = document.getElementById("scale-text");
        this.attributionEl   = document.getElementById("attribution");

        // Marker & popup props
        this.markers        = [];
        this.popupEl        = document.getElementById("popup");
        this.popupContentEl = document.getElementById("popup-content");
        this.popupCloseEl   = document.getElementById("popup-close");

        this._retinaAvailable = true;
        this._inertiaRAF      = null;
        this._moveSamples     = [];
        this.isPinching       = false;
        this._lastTapTime     = 0;
        this._lastTapPos      = { x:0, y:0 };
        this._zoomAnim        = null;
        this._flyAnim         = null;
        this._eventListeners  = {};

        console.warn(
          "%c[Atlas] You are using map tiles.\n" +
          "%cPlease comply with tile policies.",
          "font-weight:bold;color:#e74c3c;",
          "color:#3498db;"
        );

        this.resize();
        this.setupEvents();
        this.initControls();
        this.updateAttribution();
        this.render();
        this.updateControlsUI();
      }

      resize() {
        const w = this.container.offsetWidth,
              h = this.container.offsetHeight;
        this.dpr = window.devicePixelRatio || 1;
        this.canvas.width  = w * this.dpr;
        this.canvas.height = h * this.dpr;
        this.canvas.style.width  = w + "px";
        this.canvas.style.height = h + "px";
        this.ctx.setTransform(this.dpr,0,0,this.dpr,0,0);
        this.render();
      }

      getCurrentLayerConfig() { return this.layerConfig; }

      switchLayer(layerName) {
        if (!LAYERS[layerName] || layerName===this.currentLayer) return;
        this.currentLayer = layerName;
        this.layerConfig  = LAYERS[layerName];
        this.container.style.background = this.layerConfig.background;
        this.updateAttribution();
        this.tileCache.clear();
        this.loadingTiles.clear();
        this.zoom = Math.max(this.layerConfig.minZoom,
                     Math.min(this.layerConfig.maxZoom, this.zoom));
        this.render();
        this.updateControlsUI();
      }

      lonLatToTile(lon,lat,z) {
        lat = GISUtils.clampLatitude(lat);
        lon = GISUtils.wrapLongitude(lon);
        const scale = Math.pow(2,z);
        const x = (lon+180)/360*scale;
        const y = (1 - Math.log(Math.tan(GISUtils.toRadians(lat)) +
                 1/Math.cos(GISUtils.toRadians(lat))) / Math.PI)/2 * scale;
        return { x, y };
      }

      shouldRequestRetina() {
        const mode = CONFIG.retina;
        const want = (mode===true) ||
                     (mode==="auto" && (window.devicePixelRatio||1)>1.5);
        return want && this._retinaAvailable;
      }

      getTileUrl(x,y,z) {
        const layerConfig = this.getCurrentLayerConfig();
        const scale = Math.pow(2,z);
        const intX = (Math.floor(x)%scale + scale)%scale;
        const intY = Math.max(0,Math.min(scale-1,Math.floor(y)));
        let baseUrl = layerConfig.tileServers[0],
            url;

        if (this.currentLayer==="ESRI") {
          url = `${baseUrl}/${z}/${intY}/${intX}`;
        } else {
          url = `${baseUrl}/${z}/${intX}/${intY}.png`;
        }

        if (layerConfig.supportsRetina && this.shouldRequestRetina()) {
          url += CONFIG.retinaSuffix;
        }
        return url;
      }

      async loadTile(key,url) {
        if (this.tileCache.has(key)) return this.tileCache.get(key);
        const img = new Image();
        img.crossOrigin = "anonymous";
        const tile = { img, loaded:false, loadedAt:Date.now(), lastUsed:Date.now() };
        this.tileCache.set(key,tile);
        this.loadingTiles.add(key);

        const loadPromise = new Promise((resolve,reject)=>{
          img.onload = ()=>{
            tile.loaded = true;
            tile.loadedAt = Date.now();
            this.loadingTiles.delete(key);
            this.scheduleRender();
            resolve(tile);
          };
          img.onerror = e=>{
            console.warn(`Failed to load tile: ${url}`, e);
            if (this.getCurrentLayerConfig().supportsRetina &&
                url.includes(CONFIG.retinaSuffix)) {
              this._retinaAvailable = false;
              img.src = url.replace(CONFIG.retinaSuffix,"");
              return;
            }
            this.loadingTiles.delete(key);
            reject(e);
          };
        });

        const timeoutPromise = new Promise((_,reject)=>{
          setTimeout(()=>{
            if (this.loadingTiles.has(key)) {
              console.warn(`Tile load timeout for: ${url}`);
              this.loadingTiles.delete(key);
              this.tileCache.delete(key);
              reject(new Error(`Timeout loading tile: ${url}`));
            }
          }, TILE_LOAD_TIMEOUT_MS);
        });

        img.src = url;
        try {
          await Promise.race([loadPromise,timeoutPromise]);
        } catch(err) {
          console.error("Tile loading error:", err.message);
        }
        return tile;
      }

      reloadTile(key,url) {
        const existing = this.tileCache.get(key);
        if (!existing) return;
        const token = key+"#r";
        if (this.loadingTiles.has(token)) return;

        const doReload = ()=>{
          const img = new Image();
          img.crossOrigin = "anonymous";
          this.loadingTiles.add(token);
          img.onload  = ()=>{
            existing.img      = img;
            existing.loaded   = true;
            existing.loadedAt = Date.now();
            this.loadingTiles.delete(token);
            this.scheduleRender();
          };
          img.onerror = ()=> this.loadingTiles.delete(token);
          img.src = url + (url.includes("?")?"&":"?")+"v="+Date.now();
        };

        if ('requestIdleCallback' in window) {
          requestIdleCallback(doReload);
        } else {
          setTimeout(doReload,100);
        }
      }

      evict() {
        const maxSize = this.getCurrentLayerConfig().maxCacheSize || 0;
        if (this.tileCache.size <= maxSize) return;
        if ('requestIdleCallback' in window) {
          requestIdleCallback(()=>this._performEviction());
        } else {
          setTimeout(()=>this._performEviction(),100);
        }
      }
      _performEviction() {
        const maxSize = this.getCurrentLayerConfig().maxCacheSize || 800;
        if (this.tileCache.size <= maxSize) return;
        const entries = Array.from(this.tileCache.entries());
        entries.sort((a,b)=>a[1].lastUsed - b[1].lastUsed);
        const removeCount = this.tileCache.size - maxSize;
        for (let i=0; i<removeCount; i++) {
          this.tileCache.delete(entries[i][0]);
        }
      }

      scheduleRender() {
        if (this.renderScheduled) return;
        this.renderScheduled = true;
        requestAnimationFrame(()=>{
          this.renderScheduled = false;
          this._draw();
        });
      }

      render() { this.scheduleRender(); }

      preloadAdjacentZoomTiles() {
        const cfg = this.getCurrentLayerConfig();
        const zInt = Math.floor(this.zoom);
        const nextZ= Math.min(cfg.maxZoom, zInt+1);
        const prevZ= Math.max(cfg.minZoom, zInt-1);
        if (Math.abs(this.zoom - zInt) > 0.3) return;

        const ct = this.lonLatToTile(this.center.lon,this.center.lat,zInt);
        const ts = TILE_SIZE;
        const w  = this.canvas.width/this.dpr;
        const h  = this.canvas.height/this.dpr;
        const vp = Math.ceil(Math.max(w,h)/ts) + TILE_BUFFER;

        for (let dz of [prevZ,nextZ]) {
          if (dz===zInt) continue;
          const scaleDiff = Math.pow(2, Math.abs(dz-zInt));
          const startX = Math.floor(ct.x * (dz>zInt?scaleDiff:1/scaleDiff) - vp/2);
          const startY = Math.floor(ct.y * (dz>zInt?scaleDiff:1/scaleDiff) - vp/2);

          for (let dx=0; dx<vp; dx++){
            for (let dy=0; dy<vp; dy++){
              const X = startX+dx, Y = startY+dy;
              const key = `${this.currentLayer}_${dz}/${X}/${Y}`;
              if (!this.tileCache.has(key) && !this.loadingTiles.has(key)) {
                const url = this.getTileUrl(X,Y,dz);
                this.loadTile(key,url);
              }
            }
          }
        }
      }

      _snapCanvasToPixelGrid() {
        const t = this.ctx.getTransform();
        const tx = t.e * this.dpr;
        const ty = t.f * this.dpr;
        const sx = -(tx % 1)/this.dpr;
        const sy = -(ty % 1)/this.dpr;
        this.ctx.translate(sx, sy);
      }

      _draw() {
        const cfg = this.getCurrentLayerConfig();
        const w = this.canvas.width/this.dpr,
              h = this.canvas.height/this.dpr;
        this.ctx.fillStyle = cfg.background;
        this.ctx.fillRect(0,0,w,h);

        const zInt = Math.floor(this.zoom),
              scaleFactor = Math.pow(2,this.zoom-zInt),
              ts = TILE_SIZE,
              ct = this.lonLatToTile(this.center.lon,this.center.lat,zInt);

        const absCos = Math.abs(Math.cos(this.bearing)),
              absSin = Math.abs(Math.sin(this.bearing));

        const needW = w*absCos + h*absSin,
              needH = w*absSin + h*absCos;

        const cols = Math.ceil(needW/(ts*scaleFactor)) + TILE_BUFFER,
              rows = Math.ceil(needH/(ts*scaleFactor)) + TILE_BUFFER;

        const startX = Math.floor(ct.x - cols/2),
              startY = Math.floor(ct.y - rows/2);

        this.ctx.save();
        this.ctx.translate(w/2,h/2);
        this.ctx.rotate(this.bearing);
        this.ctx.scale(scaleFactor,scaleFactor);
        this.ctx.imageSmoothingEnabled = false;

        for (let dx=0; dx<cols; dx++){
          for (let dy=0; dy<rows; dy++){
            const X= startX+dx,
                  Y= startY+dy,
                  key= `${this.currentLayer}_${zInt}/${X}/${Y}`,
                  url= this.getTileUrl(X,Y,zInt),
                  trX= (X - ct.x)*ts,
                  trY= (Y - ct.y)*ts;

            let tile = this.tileCache.get(key);
            if (!tile) {
              this.loadTile(key,url);
            }
            else if (tile.loaded) {
              this.ctx.drawImage(tile.img, trX, trY, ts, ts);
              tile.lastUsed = Date.now();

              if (Date.now() - tile.loadedAt > TILE_TTL) {
                this.reloadTile(key,url);
              }
            }
          }
        }

        this.ctx.restore();

        // --- Draw markers ---
        this.container.querySelectorAll('.marker-container').forEach(c=>c.remove());
        for (let marker of this.markers) {
          const scr = this.latLonToScreen(marker.lon, marker.lat);
          if (!scr) continue;

          const mc = document.createElement('div');
          mc.className = 'marker-container';
          const mi = document.createElement('div');
          mi.className = 'marker-icon';
          const ms = document.createElement('div');
          ms.className = 'marker-shadow';
          mc.append(mi, ms);

          mc.style.left = (scr.x - 12)+'px';
          mc.style.top  = (scr.y - 41)+'px';
          mc.dataset.markerId = marker.id;
          marker._container    = mc;
          this.container.append(mc);
        }

        this._snapCanvasToPixelGrid();
        this.evict();
        this.preloadAdjacentZoomTiles();

        this.loadingEl.classList.toggle('visible', this.loadingTiles.size > 0);
        this.loadingCountEl.textContent = this.loadingTiles.size;

        this.coordsEl.textContent =
          `${this.center.lat.toFixed(6)}¬∞, ${this.center.lon.toFixed(6)}¬∞ | ` +
          `Z: ${this.zoom.toFixed(2)} | Bearing: ${(this.bearing*RAD2DEG).toFixed(1)}¬∞ | ` +
          `Layer: ${this.currentLayer}`;

        this.updateScaleBar();
        this.updateControlsUI();
      }

      updateScaleBar() {
        if (!this.scaleBarEl || !this.scaleTextEl) return;
        const mPerPx = GISUtils.getResolution(this.center.lat,this.zoom);
        const targetMeters = mPerPx * SCALE_BAR_TARGET_PX;
        const pow = Math.pow(10, Math.floor(Math.log10(targetMeters)));
        const base = targetMeters / pow;
        const niceBase = base>=5 ? 5 : base>=2 ? 2 : 1;
        const niceMeters = niceBase*pow;
        const widthPx = Math.max(20, Math.min(300, niceMeters/mPerPx));

        this.scaleBarEl.style.width = widthPx + 'px';

        if (!this.scaleTextEl.dataset.unit) {
          this.scaleTextEl.dataset.unit = 'metric';
        }

        let displayText;
        if (this.scaleTextEl.dataset.unit==='metric') {
          displayText = GISUtils.formatDistance(niceMeters);
        } else {
          const feet = niceMeters*3.28084;
          displayText = feet<5280 ? Math.round(feet)+' ft' : (feet/5280).toFixed(1)+' mi';
        }
        this.scaleTextEl.textContent = displayText;

        if (!this.scaleTextEl._hasClickListener) {
          this.scaleTextEl.addEventListener('click', ()=>{
            this.scaleTextEl.dataset.unit =
              this.scaleTextEl.dataset.unit==='metric' ? 'imperial' : 'metric';
            this.updateScaleBar();
          });
          this.scaleTextEl._hasClickListener = true;
        }
      }

      setZoom(z) {
        const cfg = this.getCurrentLayerConfig();
        const nz = Math.max(cfg.minZoom, Math.min(cfg.maxZoom, z));
        if (nz===this.zoom) return;
        this.zoom = nz;
        this.render();
        this.showZoomOverlay();
        this.updateControlsUI();
      }

      showZoomOverlay() {
        const ov = this.zoomOverlay;
        ov.textContent = `Zoom: ${this.zoom.toFixed(2)}`;
        ov.style.opacity = 1;
        clearTimeout(this._zTimer);
        this._zTimer = setTimeout(()=> ov.style.opacity = 0, 500);
      }

      stopInertia() {
        if (this._inertiaRAF) cancelAnimationFrame(this._inertiaRAF);
        this._inertiaRAF = null;
      }

      stopAnimations() {
        this.stopInertia();
        if (this._zoomAnim?.raf) cancelAnimationFrame(this._zoomAnim.raf);
        if (this._flyAnim?.raf) cancelAnimationFrame(this._flyAnim.raf);
        this._zoomAnim = this._flyAnim = null;
      }

      resetVelocitySamples() { this._moveSamples = []; }
      pushVelocitySample(x,y) {
        const t = performance.now();
        this._moveSamples.push({t,x,y});
        const cutoff = t - VELOCITY_WINDOW_MS;
        while (this._moveSamples.length && this._moveSamples[0].t < cutoff) {
          this._moveSamples.shift();
        }
      }
      computeVelocity() {
        if (this._moveSamples.length<2) return {vx:0,vy:0};
        const last = this._moveSamples[this._moveSamples.length-1];
        let i = this._moveSamples.length-2;
        while (i>0 && last.t - this._moveSamples[i].t < VELOCITY_WINDOW_MS*0.5) {
          i--;
        }
        const ref = this._moveSamples[i];
        const dt  = Math.max(1, last.t - ref.t);
        return { vx:(last.x-ref.x)/dt, vy:(last.y-ref.y)/dt };
      }

      startInertia(vx,vy) {
        const speed = Math.hypot(vx,vy);
        if (speed < INERTIA_STOP_SPEED) return;
        this.stopInertia();
        let lastT = performance.now();

        const step = ()=>{
          const now = performance.now();
          const dt  = now - lastT;
          lastT    = now;
          const dx = vx*dt, dy = vy*dt;
          const w = this.canvas.width/this.dpr,
                h = this.canvas.height/this.dpr;
          this.center = this.screenToLatLon(w/2 - dx, h/2 - dy);

          const vmag = Math.hypot(vx,vy),
                newV = Math.max(0, vmag - INERTIA_DECEL*dt);

          if (newV <= INERTIA_STOP_SPEED) {
            this.render();
            this._inertiaRAF = null;
            return;
          }

          const s = newV / (vmag||1);
          vx *= s; vy *= s;
          this.render();
          this._inertiaRAF = requestAnimationFrame(step);
        };

        this._inertiaRAF = requestAnimationFrame(step);
      }

      screenToLatLon(ax,ay, zoom=this.zoom, bearing=this.bearing, center=this.center) {
        const w = this.canvas.width/this.dpr,
              h = this.canvas.height/this.dpr;
        const zInt = Math.floor(zoom),
              ts   = TILE_SIZE * Math.pow(2,zoom - zInt),
              ct   = this.lonLatToTile(center.lon, center.lat, zInt);
        const anchorVec = { x: ax - w/2, y: ay - h/2 };
        const v = rot(anchorVec.x/ts, anchorVec.y/ts, -bearing);
        const tpt = { x: ct.x + v.x, y: ct.y + v.y };
        const ll  = GISUtils.tileToLonLat(tpt.x, tpt.y, zInt);
        return {
          lon: GISUtils.wrapLongitude(ll.lon),
          lat: GISUtils.clampLatitude(ll.lat)
        };
      }

      latLonToScreen(lon,lat) {
        const w = this.canvas.width/this.dpr,
              h = this.canvas.height/this.dpr,
              zInt = Math.floor(this.zoom);
        const tileCoords   = this.lonLatToTile(lon, lat, zInt),
              centerCoords = this.lonLatToTile(this.center.lon, this.center.lat, zInt);
        const dTileX = tileCoords.x - centerCoords.x,
              dTileY = tileCoords.y - centerCoords.y;
        const scaleFactor = Math.pow(2,this.zoom - zInt),
              ts = TILE_SIZE;
        const scaledDx = dTileX * ts * scaleFactor,
              scaledDy = dTileY * ts * scaleFactor;
        const rotPt = rot(scaledDx, scaledDy, this.bearing);
        return {
          x: w/2 + rotPt.x,
          y: h/2 + rotPt.y
        };
      }

      applyZoomRotateAbout(ax,ay,newZoom,newBearing, anchorLL=null) {
        const cfg = this.getCurrentLayerConfig();
        newZoom = Math.max(cfg.minZoom, Math.min(cfg.maxZoom, newZoom));
        const w = this.canvas.width/this.dpr,
              h = this.canvas.height/this.dpr;
        const anchorVec = { x: ax - w/2, y: ay - h/2 };
        const currAnchorLL = anchorLL ||
               this.screenToLatLon(ax,ay,this.zoom,this.bearing,this.center);
        const zInt = Math.floor(newZoom),
              ts   = TILE_SIZE * Math.pow(2,newZoom - zInt);
        const Ptile = this.lonLatToTile(currAnchorLL.lon, currAnchorLL.lat, zInt);
        const v = rot(anchorVec.x/ts, anchorVec.y/ts, -newBearing);
        const ctNew = { x: Ptile.x - v.x, y: Ptile.y - v.y };
        const newC  = GISUtils.tileToLonLat(ctNew.x, ctNew.y, zInt);
        this.center  = {
          lon: GISUtils.wrapLongitude(newC.lon),
          lat: GISUtils.clampLatitude(newC.lat)
        };
        this.zoom    = newZoom;
        this.bearing = normalizeAngle(newBearing);
      }

      showZoomIndicator(x,y) {
        if (this._zoomIndicator) {
          this.container.removeChild(this._zoomIndicator);
        }
        const indicator = document.createElement("div");
        indicator.style.cssText = `
          position: absolute;
          left: ${x-15}px;
          top:  ${y-15}px;
          width: 30px; height: 30px;
          border-radius: 50%;
          border: 2px solid #333;
          opacity: 0.8;
          pointer-events: none;
          z-index: 100;
          animation: zoom-indicator 0.6s ease-out forwards;
        `;
        this.container.append(indicator);
        this._zoomIndicator = indicator;
        setTimeout(()=>{
          if (this._zoomIndicator && this._zoomIndicator.parentNode) {
            this.container.removeChild(this._zoomIndicator);
            this._zoomIndicator = null;
          }
        },600);
      }

      animateZoomRotateAbout(ax,ay,toZoom,toBearing=this.bearing,
                           duration=WHEEL_ZOOM_DURATION,
                           easing=EASING.easeInOutCubic) {
        this.showZoomIndicator(ax,ay);
        this.stopAnimations();
        const startT = performance.now(),
              sZoom  = this.zoom,
              sBear  = this.bearing,
              deltaBear = shortestAngleDiff(sBear,toBearing),
              anchorLL = this.screenToLatLon(ax,ay,this.zoom,this.bearing,this.center);

        const step = ()=>{
          const t = (performance.now() - startT)/Math.max(1,duration),
                p = t>=1 ? 1 : easing(Math.max(0,Math.min(1,t)));
          const z = sZoom + (toZoom - sZoom)*p,
                b = sBear + deltaBear*p;
          this.applyZoomRotateAbout(ax,ay,z,b,anchorLL);
          this.render();
          if (t<1) {
            this._zoomAnim = { raf: requestAnimationFrame(step) };
          } else {
            this._zoomAnim = null;
            this.updateControlsUI();
          }
        };

        this._zoomAnim = { raf: requestAnimationFrame(step) };
      }

      smoothZoomAt(ax,ay,deltaZ) {
        const cfg = this.getCurrentLayerConfig();
        const target = Math.max(cfg.minZoom, Math.min(cfg.maxZoom, this.zoom+deltaZ));
        this.animateZoomRotateAbout(ax,ay,target,this.bearing, WHEEL_ZOOM_DURATION, EASING.easeInOutCubic);
      }

      flyTo({ center=this.center, zoom=this.zoom, bearing=this.bearing,
              duration=FLYTO_DURATION, easing=EASING.easeInOutCubic }={}) {
        const cfg = this.getCurrentLayerConfig();
        this.stopAnimations();

        const startT = performance.now(),
              sC = { ...this.center },
              eC = { ...center },
              dLon = wrapDeltaLon(eC.lon - sC.lon),
              dLat = eC.lat - sC.lat,
              sZ   = this.zoom,
              eZ   = Math.max(cfg.minZoom, Math.min(cfg.maxZoom, zoom)),
              sB   = this.bearing,
              dB   = shortestAngleDiff(sB,bearing);

        const step = ()=>{
          const t = (performance.now() - startT)/Math.max(1,duration),
                p = t>=1?1:easing(Math.max(0,Math.min(1,t)));
          this.center = {
            lon: GISUtils.wrapLongitude(sC.lon + dLon*p),
            lat: GISUtils.clampLatitude(sC.lat + dLat*p)
          };
          this.zoom    = sZ + (eZ - sZ)*p;
          this.bearing = normalizeAngle(sB + dB*p);
          this.render();
          if (t<1) {
            this._flyAnim = { raf: requestAnimationFrame(step) };
          } else {
            this._flyAnim = null;
            this.updateControlsUI();
          }
        };

        this._flyAnim = { raf: requestAnimationFrame(step) };
      }

      // --- Touch helpers ---
      _handleSingleTouchStart(e) {
        const t = e.touches[0];
        this.isDragging = true;
        this.container.classList.add('dragging');
        this.dragStart = { x:t.clientX, y:t.clientY, center:{ ...this.center }};
        this.resetVelocitySamples();
        this.pushVelocitySample(t.clientX, t.clientY);
        this._singleTouchStart = { x:t.clientX, y:t.clientY, t:performance.now() };
        this._singleTouchMoved = false;
      }
      _handlePinchStart(e) {
        const t1 = e.touches[0], t2 = e.touches[1];
        this.isDragging = false;
        this.isPinching = true;
        this.pinchStartDist   = Math.hypot(t2.clientX-t1.clientX, t2.clientY-t1.clientY);
        this.pinchStartAngle  = Math.atan2(t2.clientY-t1.clientY, t2.clientX-t1.clientX);
        this.pinchStartZoom   = this.zoom;
        this.pinchStartBearing= this.bearing;
        this.pinchStartTime   = performance.now();
        this.pinchLastCenter  = { x:(t1.clientX+t2.clientX)/2, y:(t1.clientY+t2.clientY)/2 };
        this._pinchAnchorLL   = this.screenToLatLon(this.pinchLastCenter.x,this.pinchLastCenter.y);
        this.resetVelocitySamples();
        this.pushVelocitySample(this.pinchLastCenter.x,this.pinchLastCenter.y);
        this._pinchMoved = false;
      }
      _handleSingleTouchMove(e) {
        const t = e.touches[0];
        if (this._singleTouchStart) {
          const md = Math.hypot(t.clientX - this._singleTouchStart.x,
                                 t.clientY - this._singleTouchStart.y);
          if (md > DOUBLE_TAP_MAX_MOVE) this._singleTouchMoved = true;
        }
        const dx = t.clientX - this.dragStart.x,
              dy = t.clientY - this.dragStart.y;
        const w = this.canvas.width/this.dpr,
              h = this.canvas.height/this.dpr;
        this.center = this.screenToLatLon(w/2 - dx, h/2 - dy,
                                          this.zoom, this.bearing, this.dragStart.center);
        this.pushVelocitySample(t.clientX,t.clientY);
        this.render();
      }
      _handlePinchMove(e) {
        const t1 = e.touches[0], t2 = e.touches[1];
        const dist  = Math.hypot(t2.clientX-t1.clientX, t2.clientY-t1.clientY);
        const angle = Math.atan2(t2.clientY-t1.clientY, t2.clientX-t1.clientX);
        const center= { x:(t1.clientX+t2.clientX)/2, y:(t1.clientY+t2.clientY)/2 };
        const targetZoom    = this.pinchStartZoom + Math.log2(dist/Math.max(1,this.pinchStartDist));
        const deltaAngle    = normalizeAngle(angle - this.pinchStartAngle);
        const targetBearing = normalizeAngle(this.pinchStartBearing + deltaAngle);

        if (Math.abs(Math.log(dist/Math.max(1,this.pinchStartDist))) >
            Math.log(1 + TWO_FINGER_TAP_MOVE_THRESH/Math.max(1,this.pinchStartDist)) ||
            Math.abs(deltaAngle) > ROTATE_MOVE_THRESH_RAD) {
          this._pinchMoved = true;
        }

        this.applyZoomRotateAbout(center.x,center.y,targetZoom,targetBearing,this._pinchAnchorLL);
        this.pinchLastCenter = center;
        this.pushVelocitySample(center.x,center.y);
        this.render();
      }
      _handleTouchEndSingle(e) {
        const now = performance.now();
        const s   = this._singleTouchStart;
        if (s && !this._singleTouchMoved) {
          const dt   = now - s.t;
          const distFromLast = Math.hypot(s.x - this._lastTapPos.x, s.y - this._lastTapPos.y);
          if (now - this._lastTapTime <= DOUBLE_TAP_MAX_DELAY && distFromLast <= DOUBLE_TAP_MAX_MOVE) {
            this.animateZoomRotateAbout(s.x,s.y,this.zoom+1,this.bearing,TAP_ZOOM_DURATION);
            this._lastTapTime = 0;
          } else {
            this._lastTapTime = now;
            this._lastTapPos  = { x:s.x, y:s.y };
          }
        }
        this.isDragging = false;
        this.container.classList.remove('dragging');
        const {vx,vy} = this.computeVelocity();
        this.startInertia(vx,vy);
      }
      _handleTouchEndPinch(e) {
        const dt = performance.now() - this.pinchStartTime;
        if (dt <= TWO_FINGER_TAP_MAX_DELAY && !this._pinchMoved) {
          const ax = this.pinchLastCenter?.x ?? (this.canvas.width/this.dpr)/2;
          const ay = this.pinchLastCenter?.y ?? (this.canvas.height/this.dpr)/2;
          this.animateZoomRotateAbout(ax,ay,this.zoom-1,this.bearing,TAP_ZOOM_DURATION);
        }
        this.isPinching = false;
      }
      // --- End Touch helpers ---

      // --- Marker & Popup Methods ---
      /**
       * Adds a marker to the map.
       */
      addMarker(markerData) {
        if (typeof markerData.lon!=='number' || typeof markerData.lat!=='number') {
          console.error("Invalid marker coords:", markerData);
          return;
        }
        if (!markerData.id) {
          markerData.id = 'marker_' + Date.now() + '_' + Math.random().toString(36).substr(2,5);
        }
        this.markers.push(markerData);
        this.render();
      }

      /**
       * Checks if a marker was clicked, shows popup if so.
       */
      handleMarkerClick(clickX, clickY) {
        for (let i=this.markers.length-1; i>=0; i--) {
          const m = this.markers[i];
          const ctr = m._container;
          if (!ctr) continue;
          const rect = ctr.getBoundingClientRect();
          const cRect= this.container.getBoundingClientRect();
          const left = rect.left - cRect.left;
          const top  = rect.top  - cRect.top;
          const right  = left + rect.width;
          const bottom = top  + rect.height;

          const iconEl = ctr.querySelector('.marker-icon');
          if (!iconEl) continue;
          const iRect = iconEl.getBoundingClientRect();
          const iLeft = iRect.left - cRect.left;
          const iTop  = iRect.top  - cRect.top;
          const iRight= iLeft + iRect.width;
          const iBottom= iTop + iRect.height;

          if (clickX>=iLeft && clickX<=iRight &&
              clickY>=iTop && clickY<=iBottom) {
            this.showPopup(m, clickX, clickY);
            return;
          }
        }
        this.closePopup();
      }

      /**
       * Shows a popup for the given marker.
       */
      showPopup(marker, x, y) {
        if (!this.popupEl||!this.popupContentEl) return;
        this.closePopup();

        let content = marker.description||marker.title||'Marker';
        if (typeof content==='string') {
          content = content.replace(/\n/g,'<br>');
        }
        this.popupContentEl.innerHTML = content;

        this.popupEl.style.display = 'block';
        this.popupEl.style.left    = '-9999px';
        this.popupEl.style.top     = '-9999px';
        this.popupEl.offsetHeight; // reflow

        const pw = this.popupEl.offsetWidth  ||300;
        const ph = this.popupEl.offsetHeight ||150;
        let left = x - pw/2;
        let top  = y - ph;

        const cw = this.container.offsetWidth,
              ch = this.container.offsetHeight;

        if (left < 0) left = 10;
        else if (left + pw > cw) left = cw - pw - 10;

        if (top < 0) {
          top = y + 20;
        }

        // auto-pan
        let panX=0, panY=0;
        if (left < POPUP_AUTO_PAN_PADDING.x) {
          panX = POPUP_AUTO_PAN_PADDING.x - left;
        } else if (left+pw > cw - POPUP_AUTO_PAN_PADDING.x) {
          panX = (cw - POPUP_AUTO_PAN_PADDING.x) - (left+pw);
        }
        if (top < POPUP_AUTO_PAN_PADDING.y) {
          panY = POPUP_AUTO_PAN_PADDING.y - top;
        } else if (top+ph > ch - POPUP_AUTO_PAN_PADDING.y) {
          panY = (ch - POPUP_AUTO_PAN_PADDING.y) - (top+ph);
        }

        this.popupEl.style.left = left + 'px';
        this.popupEl.style.top  = top  + 'px';
        this._currentPopupMarker = marker;

        if (panX!==0||panY!==0) {
          const newCenter = this.screenToLatLon(
            this.container.offsetWidth/2 - panX,
            this.container.offsetHeight/2 - panY
          );
          this.flyTo({ center:newCenter, duration:POPUP_AUTO_PAN_DURATION });
        }
      }

      closePopup() {
        if (this.popupEl) this.popupEl.style.display = 'none';
        this._currentPopupMarker = null;
      }
      // --- End Marker & Popup Methods ---

      setupEvents() {
        this._eventListeners.resize = ()=>this.resize();
        window.addEventListener("resize", this._eventListeners.resize);

        // Mouse down = start drag
        this._eventListeners.mousedown = (e)=>{
          this.stopAnimations();
          this.isDragging = true;
          this.container.classList.add("dragging");
          this.dragStart = { x:e.clientX, y:e.clientY, center:{ ...this.center }};
          this.resetVelocitySamples();
          this.pushVelocitySample(e.clientX,e.clientY);
        };
        this.canvas.addEventListener("mousedown", this._eventListeners.mousedown);

        // Mouse move
        this._eventListeners.mousemove = (e)=>{
          if (!this.isDragging) return;
          const dx = e.clientX - this.dragStart.x;
          const dy = e.clientY - this.dragStart.y;
          const w = this.canvas.width/this.dpr;
          const h = this.canvas.height/this.dpr;
          this.center = this.screenToLatLon(w/2 - dx, h/2 - dy, this.zoom, this.bearing, this.dragStart.center);
          this.pushVelocitySample(e.clientX,e.clientY);
          this.render();
        };
        window.addEventListener("mousemove", this._eventListeners.mousemove);

        // Mouse up = end drag
        this._eventListeners.mouseup = ()=>{
          if (!this.isDragging) return;
          this.isDragging = false;
          this.container.classList.remove("dragging");
          const {vx,vy} = this.computeVelocity();
          this.startInertia(vx,vy);
        };
        window.addEventListener("mouseup", this._eventListeners.mouseup);

        // Wheel zoom
        this._eventListeners.wheel = (e)=>{
          e.preventDefault();
          const dz = e.deltaY < 0 ? WHEEL_ZOOM_STEP : -WHEEL_ZOOM_STEP;
          this.smoothZoomAt(e.clientX,e.clientY,dz);
        };
        this.canvas.addEventListener("wheel", this._eventListeners.wheel, { passive:false });

        // Double-click
        this._eventListeners.dblclick = (e)=>{
          e.preventDefault();
          this.animateZoomRotateAbout(e.clientX, e.clientY, this.zoom+1, this.bearing, TAP_ZOOM_DURATION);
        };
        this.canvas.addEventListener("dblclick", this._eventListeners.dblclick);

        // Zoom buttons
        document.getElementById("zoom-in").addEventListener("click", ()=>{
          this.stopAnimations();
          this.setZoom(this.zoom+1);
        });
        document.getElementById("zoom-out").addEventListener("click", ()=>{
          this.stopAnimations();
          this.setZoom(this.zoom-1);
        });

        // Layer toggle
        this._eventListeners.layerToggleClick = ()=>{
          this.switchLayer(this.currentLayer==="OSM"?"ESRI":"OSM");
        };
        document.getElementById("layer-toggle")
                .addEventListener("click", this._eventListeners.layerToggleClick);

        // Keyboard
        this._eventListeners.keydown = (e)=>{
          switch(e.key) {
            case "+": case "=":
              this.stopAnimations();
              this.setZoom(this.zoom+1);
              break;
            case "-":
              this.stopAnimations();
              this.setZoom(this.zoom-1);
              break;
            case "ArrowUp":
              this.stopAnimations();
              this.center.lat = GISUtils.clampLatitude(this.center.lat+1);
              this.render();
              break;
            case "ArrowDown":
              this.stopAnimations();
              this.center.lat = GISUtils.clampLatitude(this.center.lat-1);
              this.render();
              break;
            case "ArrowLeft":
              this.stopAnimations();
              this.center.lon = GISUtils.wrapLongitude(this.center.lon-1);
              this.render();
              break;
            case "ArrowRight":
              this.stopAnimations();
              this.center.lon = GISUtils.wrapLongitude(this.center.lon+1);
              this.render();
              break;
            case "n":
            case "N": {
              const w = this.canvas.width/this.dpr,
                    h = this.canvas.height/this.dpr;
              this.animateZoomRotateAbout(w/2,h/2,this.zoom,0,SNAP_DURATION);
              break;
            }
            case "r":
              this.setBear‚Ä¶
            default: break;
          }
        };
        window.addEventListener("keydown", this._eventListeners.keydown);

        // Touch
        const onTouchStart = e=>{
          if (!e.touches.length) return;
          e.preventDefault();
          this.stopAnimations();
          if (e.touches.length===1) this._handleSingleTouchStart(e);
          else if (e.touches.length===2) this._handlePinchStart(e);
        };
        const onTouchMove = e=>{
          if (!e.touches.length) return;
          e.preventDefault();
          if (this.isPinching && e.touches.length>=2) this._handlePinchMove(e);
          else if (this.isDragging && e.touches.length===1) this._handleSingleTouchMove(e);
        };
        const onTouchEnd = e=>{
          if (this.isPinching) this._handleTouchEndPinch(e);
          if (this.isDragging) this._handleTouchEndSingle(e);
        };
        this.canvas.addEventListener("touchstart", onTouchStart, {passive:false});
        this.canvas.addEventListener("touchmove",  onTouchMove,  {passive:false});
        this.canvas.addEventListener("touchend",   onTouchEnd,   {passive:false});
        this.canvas.addEventListener("touchcancel",onTouchEnd,   {passive:false});

        // Fullscreen
        this._eventListeners.fullscreenClick = ()=>{
          if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch(err=>{
              console.warn(`Error enabling fullscreen: ${err.message}`);
            });
          } else {
            document.exitFullscreen().catch(err=>{
              console.warn(`Error exiting fullscreen: ${err.message}`);
            });
          }
        };
        document.getElementById("fullscreen")
                .addEventListener("click", this._eventListeners.fullscreenClick);

        // Marker click
        this._eventListeners.canvasClick = e=>{
          const rect = this.container.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          this.handleMarkerClick(x,y);
        };
        this.canvas.addEventListener("click", this._eventListeners.canvasClick);

        // Popup close
        this._eventListeners.popupCloseClick = e=>{
          e.preventDefault();
          this.closePopup();
        };
        if (this.popupCloseEl) {
          this.popupCloseEl.addEventListener("click", this._eventListeners.popupCloseClick);
        }
      }

      initControls() {
        const stack = this.container.querySelector(".controls");
        if (!stack) return;

        // Compass
        const compass = document.createElement("button");
        compass.id    = "compass";
        compass.className= "control-btn";
        compass.title     = "Reset North";
        compass.setAttribute("aria-label","Reset North");
        compass.textContent="N";
        compass.style.display = "none";
        compass.onclick = ()=>{
          const w = this.canvas.width/this.dpr,
                h = this.canvas.height/this.dpr;
          this.animateZoomRotateAbout(w/2,h/2,this.zoom,0,SNAP_DURATION);
        };
        stack.append(compass);
        this._compassBtn = compass;

        // Reset zoom
        const rz = document.createElement("button");
        rz.id    = "reset-zoom";
        rz.className= "control-btn";
        rz.title     = "Reset Zoom";
        rz.setAttribute("aria-label","Reset Zoom");
        rz.textContent="‚§¢";
        rz.onclick = ()=>{
          const w = this.canvas.width/this.dpr,
                h = this.canvas.height/this.dpr;
          this.animateZoomRotateAbout(w/2,h/2,CONFIG.defaultZoom,this.bearing,SNAP_DURATION);
        };
        stack.append(rz);
        this._resetZoomBtn = rz;
      }

      updateControlsUI() {
        const zi = document.getElementById("zoom-in"),
              zo = document.getElementById("zoom-out"),
              cfg= this.getCurrentLayerConfig();

        if (zi) zi.disabled = this.zoom >= cfg.maxZoom;
        if (zo) zo.disabled = this.zoom <= cfg.minZoom;

        if (this._compassBtn) {
          const visible = Math.abs(this.bearing) > 0.001;
          this._compassBtn.style.display = visible ? "block" : "none";
          this._compassBtn.style.transform = `rotate(${-this.bearing*RAD2DEG}deg)`;
        }
      }

      updateAttribution() {
        if (this.attributionEl) {
          this.attributionEl.innerHTML = this.layerConfig.attribution;
        }
      }

      destroy() {
        this.stopAnimations();
        this.stopInertia();
        window.removeEventListener("resize", this._eventListeners.resize);
        this.canvas.removeEventListener("mousedown", this._eventListeners.mousedown);
        window.removeEventListener("mousemove", this._eventListeners.mousemove);
        window.removeEventListener("mouseup",   this._eventListeners.mouseup);
        this.canvas.removeEventListener("wheel", this._eventListeners.wheel);
        this.canvas.removeEventListener("dblclick", this._eventListeners.dblclick);
        window.removeEventListener("keydown",    this._eventListeners.keydown);
        this.canvas.removeEventListener("touchstart", this._eventListeners.touchstart);
        this.canvas.removeEventListener("touchmove",  this._eventListeners.touchmove);
        this.canvas.removeEventListener("touchend",   this._eventListeners.touchend);
        this.canvas.removeEventListener("touchcancel",this._eventListeners.touchcancel);
        document.getElementById("fullscreen")
                .removeEventListener("click", this._eventListeners.fullscreenClick);
        document.getElementById("layer-toggle")
                .removeEventListener("click", this._eventListeners.layerToggleClick);
        this.canvas.removeEventListener("click", this._eventListeners.canvasClick);
        if (this.popupCloseEl) {
          this.popupCloseEl.removeEventListener("click", this._eventListeners.popupCloseClick);
        }
        this.tileCache.clear();
        this.loadingTiles.clear();
        this.container.querySelectorAll('.marker-container').forEach(c=>c.remove());
        console.log("Atlas destroyed");
      }
    }

    // Initialize
    let atlasInstance = null;
    function initializeAtlas() {
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(pos=>{
          atlasInstance = new Atlas("map");
          atlasInstance.flyTo({ center:{ lat:pos.coords.latitude, lon:pos.coords.longitude }, zoom:10 });
        }, err=>{
          alert("Could not determine your location. Loading default view.");
          atlasInstance = new Atlas("map");
        });
      } else {
        alert("Geolocation not supported. Loading default view.");
        atlasInstance = new Atlas("map");
      }

      // Add sample markers after 2s
      setTimeout(()=>{
        if (!atlasInstance) return;
        atlasInstance.addMarker({
          lon:2.2945, lat:48.8584,
          title:"Eiffel Tower",
          description:"A wrought-iron lattice tower on the Champ de Mars in Paris."
        });
        atlasInstance.addMarker({
          lon:-74.0060, lat:40.7128,
          title:"New York City",
          description:"The most populous city in the United States.\nA major cultural & financial center."
        });
        atlasInstance.addMarker({
          lon:139.6917, lat:35.6895,
          title:"Tokyo",
          description:"The capital and most populous city of Japan."
        });
      },2000);
    }

    if (document.readyState==="loading") {
      document.addEventListener("DOMContentLoaded", initializeAtlas);
    } else {
      initializeAtlas();
    }

  </script>
</body>
</html>
