<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Atlasâ€‘Lite v1.0 Fixed</title>
  <style>
    html, body {
      margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden;
    }
    #map-container {
      position: relative;
      width: 100%; height: 100%;
    }
    canvas { width:100%; height:100%; display:block; }
    .atlas-control button { cursor:pointer; }
    .atlas-attribution { font-size:11px; }
    .atlas-attribution a { color:#4da3ff; text-decoration:none; }
    .atlas-attribution a:hover { text-decoration:underline; }
  </style>
</head>
<body>
<div id="map-container">
  <canvas id="map"></canvas>
</div>

<script>
(function (global,factory){
  global.Atlas = factory();
})(this,function(){
"use strict";

const TILE_SIZE=256, EARTH_RADIUS=6378137, DEG2RAD=Math.PI/180, MAX_LAT=85.0511;

class Projection {
  project({lat,lon}){
    const clampedLat=Math.max(Math.min(lat,MAX_LAT),-MAX_LAT);
    const sin=Math.sin(clampedLat*DEG2RAD);
    return {
      x: EARTH_RADIUS*lon*DEG2RAD,
      y: EARTH_RADIUS * Math.log((1+sin)/(1-sin))/2
    };
  }
  unproject({x,y}){
    return {
      lon:(x/EARTH_RADIUS)*180/Math.PI,
      lat:(2*Math.atan(Math.exp(y/EARTH_RADIUS))-Math.PI/2)*180/Math.PI
    };
  }
  latLngToTile({lat,lon},z){
    const scale=1<<z;
    const {x,y}=this.project({lat,lon});
    return {
      x:(x+Math.PI*EARTH_RADIUS)/(2*Math.PI*EARTH_RADIUS)*scale,
      y:(Math.PI*EARTH_RADIUS-y)/(2*Math.PI*EARTH_RADIUS)*scale
    };
  }
}

class TileLayer {
  constructor(urlTemplate, attribution="Â© Atlas-Lite", opts={}){
    this.urlTemplate=urlTemplate;
    this.attribution=attribution;
    this.cache=new Map();
    this.maxCacheSize=opts.maxCacheSize||300;
    this.minZoom=opts.minZoom??0;
    this.maxZoom=opts.maxZoom??19;
  }
  _makePlaceholder(){
    const c=document.createElement("canvas"); c.width=TILE_SIZE; c.height=TILE_SIZE;
    const ctx=c.getContext("2d");
    ctx.fillStyle="#ddd"; ctx.fillRect(0,0,TILE_SIZE,TILE_SIZE);
    ctx.strokeStyle="#999"; ctx.strokeRect(0,0,TILE_SIZE,TILE_SIZE);
    ctx.fillStyle="#555"; ctx.font="20px sans-serif"; ctx.fillText("âš ",TILE_SIZE/2-8,TILE_SIZE/2+8);
    return c;
  }
  _getTileUrl(x,y,z){
    return this.urlTemplate.replace("{z}",z).replace("{x}",x).replace("{y}",y);
  }
  render(map){
    const {ctx,canvas,zoom,center,projection}=map;
    const zInt=Math.floor(zoom);
    const {x:cx,y:cy}=projection.latLngToTile(center,zInt);
    const w=canvas.width,h=canvas.height;
    const cols=Math.ceil(w/TILE_SIZE)+2, rows=Math.ceil(h/TILE_SIZE)+2;
    const startX=Math.floor(cx-cols/2), startY=Math.floor(cy-rows/2);

    for (let dx=0;dx<cols;dx++){
      for(let dy=0;dy<rows;dy++){
        const x=startX+dx, y=startY+dy, key=`${zInt}/${x}/${y}`;
        if(!this.cache.has(key)){
          const url=this._getTileUrl(x,y,zInt);
          const img=new Image();
          img.crossOrigin="anonymous";
          img.onload=()=>{ this.cache.set(key,{drawable:img,lastUsed:Date.now()}); };
          img.onerror=()=>{ this.cache.set(key,{drawable:this._makePlaceholder(),lastUsed:Date.now()}); };
          img.src=url;
          this.cache.set(key,{drawable:this._makePlaceholder(),lastUsed:Date.now()}); // temporary
          // eviction simple FIFO
          if(this.cache.size>this.maxCacheSize){
            const firstKey=this.cache.keys().next().value;
            this.cache.delete(firstKey);
          }
        }
        const entry=this.cache.get(key);
        if(entry){
          entry.lastUsed=Date.now();
          const px=(x-cx)*TILE_SIZE+w/2, py=(y-cy)*TILE_SIZE+h/2;
          ctx.drawImage(entry.drawable,px,py,TILE_SIZE,TILE_SIZE);
        }
      }
    }
  }
}

function place(el,pos="top-left"){
  el.style.position="absolute";
  if(pos.includes("top")) el.style.top="10px";
  if(pos.includes("bottom")) el.style.bottom="10px";
  if(pos.includes("left")) el.style.left="10px";
  if(pos.includes("right")) el.style.right="10px";
}

class ZoomControl {
  constructor(opts={}){ this.pos=opts.position||"top-left"; }
  addTo(map){
    this.container=document.createElement("div"); place(this.container,this.pos);
    const mk=(label,title,fn)=>{
      const b=document.createElement("button");
      b.textContent=label; b.title=title;
      b.onclick=fn; b.style.cssText="width:30px;height:30px;margin:2px;";
      this.container.appendChild(b);
    };
    mk("+","Zoom in",()=>map.setZoom(map.getZoom()+1));
    mk("âˆ’","Zoom out",()=>map.setZoom(map.getZoom()-1));
    map.container.appendChild(this.container);
  }
}
class FullscreenControl {
  constructor(opts={}){ this.pos=opts.position||"top-right"; }
  addTo(map){
    this.container=document.createElement("div"); place(this.container,this.pos);
    const b=document.createElement("button"); b.textContent="â›¶"; b.title="Fullscreen";
    b.style.cssText="width:34px;height:34px;margin:2px;";
    b.onclick=()=>{!document.fullscreenElement?map.container.requestFullscreen():document.exitFullscreen();};
    this.container.appendChild(b); map.container.appendChild(this.container);
  }
}
class LayerControl {
  constructor(layers,opts={}){ this.layers=layers; this.idx=0; this.pos=opts.position||"top-left"; }
  addTo(map){
    this.container=document.createElement("div"); place(this.container,this.pos);
    const b=document.createElement("button"); b.textContent="ðŸŒ"; b.title="Switch layer";
    b.style.cssText="width:34px;height:34px;margin:2px;";
    b.onclick=()=>{ this.idx=(this.idx+1)%this.layers.length; map.layers=[]; map.addLayer(this.layers[this.idx]); };
    this.container.appendChild(b); map.container.appendChild(this.container);
  }
}

class AtlasMap {
  constructor(id,options={}){
    this.canvas=document.getElementById(id);
    this.ctx=this.canvas.getContext("2d");
    this.dpr=window.devicePixelRatio||1;
    this.center=options.center||{lat:0,lon:0};
    this.zoom=options.zoom||2;
    this.projection=new Projection();
    this.layers=[];
    this.container=this.canvas.parentElement||document.body;
    this.container.style.position="relative";
    window.addEventListener("resize",()=>this.resize());
    this._bind();
    this.resize();
  }
  addLayer(l){ this.layers.push(l); this.render(); return this; }
  addControl(c){ c.addTo(this); return this; }
  setCenter(c){ this.center=c; this.render(); return this; }
  getCenter(){ return {...this.center}; }
  setZoom(z){
    const layer=this.layers[0];
    const min=layer?.minZoom??0, max=layer?.maxZoom??20;
    this.zoom=Math.max(min,Math.min(max,z));
    this.render(); return this;
  }
  getZoom(){ return this.zoom; }
  resize(){
    const w=this.canvas.clientWidth,h=this.canvas.clientHeight;
    this.canvas.width=w*this.dpr; this.canvas.height=h*this.dpr;
    this.ctx.setTransform(this.dpr,0,0,this.dpr,0,0);
    this.render();
  }
  render(){
    this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
    for(const l of this.layers) l.render(this);
  }
  _bind(){
    let dragging=false,last=null;
    this.canvas.style.cursor="grab";
    this.canvas.addEventListener("mousedown",(e)=>{dragging=true;last={x:e.clientX,y:e.clientY};this.canvas.style.cursor="grabbing";});
    window.addEventListener("mousemove",(e)=>{if(!dragging)return;this._panBy(e.clientX-last.x,e.clientY-last.y);last={x:e.clientX,y:e.clientY};});
    window.addEventListener("mouseup",()=>{dragging=false;this.canvas.style.cursor="grab";});
    this.canvas.addEventListener("wheel",(e)=>{e.preventDefault();this.setZoom(this.zoom+(e.deltaY<0?1:-1));},{passive:false});
    // touch
    let pinchStart=null,startZoom=this.zoom,lastTouch=null;
    this.canvas.addEventListener("touchstart",(e)=>{
      if(e.touches.length===1) lastTouch={x:e.touches[0].clientX,y:e.touches[0].clientY};
      if(e.touches.length===2){
        const dx=e.touches[0].clientX-e.touches[1].clientX,dy=e.touches[0].clientY-e.touches[1].clientY;
        pinchStart=Math.hypot(dx,dy); startZoom=this.zoom;
      }
    },{passive:false});
    this.canvas.addEventListener("touchmove",(e)=>{
      e.preventDefault();
      if(e.touches.length===1&&lastTouch){
        this._panBy(e.touches[0].clientX-lastTouch.x,e.touches[0].clientY-lastTouch.y);
        lastTouch={x:e.touches[0].clientX,y:e.touches[0].clientY};
      } else if(e.touches.length===2){
        const dx=e.touches[0].clientX-e.touches[1].clientX,dy=e.touches[0].clientY-e.touches[1].clientY;
        const dist=Math.hypot(dx,dy); if(pinchStart) this.setZoom(startZoom+Math.log2(dist/pinchStart));
      }
    },{passive:false});
    this.canvas.addEventListener("touchend",()=>{pinchStart=null;lastTouch=null;});
  }
}

const Atlas={Map:AtlasMap,TileLayer,ZoomControl,FullscreenControl,LayerControl,version:"1.0.0"};
return Atlas;
});
</script>

<script>
const map=new Atlas.Map("map",{zoom:2,center:{lat:20,lon:0}});
const osm=new Atlas.TileLayer("https://a.tile.openstreetmap.org/{z}/{x}/{y}.png","Â© OSM");
const esri=new Atlas.TileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}","Â© Esri");
map.addLayer(osm);
map.addControl(new Atlas.ZoomControl());
map.addControl(new Atlas.FullscreenControl({position:"top-right"}));
map.addControl(new Atlas.LayerControl([osm,esri]));
</script>
</body>
</html>
