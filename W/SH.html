<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Atlas.js v2 â€” Tarfaya Map</title>
<style>
  html, body { margin: 0; height: 100%; overflow: hidden; }
  #map { width: 100%; height: 100%; position: relative; background: #f0f4f8; cursor: grab; touch-action: none; outline: none; }
  #map.grabbing { cursor: grabbing; }

  .pane { position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; }
  .tilePane { z-index: 100; }
  .overlayPane { z-index: 200; pointer-events: none; }
  .popupPane { z-index: 300; pointer-events: none; }

  .tileLayer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; will-change: transform, opacity; transform-origin: 50% 50%; }
  .tile { position: absolute; width: 256px; height: 256px; image-rendering: pixelated; opacity: 0; transition: opacity 0.2s ease; }
  .tile.loaded { opacity: 1; }

  .markerPane { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
  .marker {
    position: absolute;
    transform: translate(-50%, -100%);
    cursor: pointer;
    font-size: 24px;
    pointer-events: auto;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
    transition: transform 0.2s ease;
  }
  .marker:hover { transform: translate(-50%, -105%) scale(1.1); }

  .popup {
    position: absolute;
    background: white;
    padding: 12px 16px;
    border: 1px solid #ccc;
    border-radius: 8px;
    font-size: 14px;
    transform: translate(-50%, -100%);
    pointer-events: auto;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    max-width: 280px;
  }
  .popup::after {
    content: "";
    position: absolute;
    left: 50%;
    bottom: -8px;
    transform: translateX(-50%);
    border: 8px solid transparent;
    border-top-color: #ccc;
    z-index: -1;
  }
  .popup .close {
    position: absolute;
    top: -10px;
    right: -10px;
    width: 22px;
    height: 22px;
    border-radius: 50%;
    background: white;
    border: 2px solid #999;
    line-height: 18px;
    text-align: center;
    font-weight: bold;
    cursor: pointer;
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
  }

  .control {
    position: absolute;
    z-index: 1100;
    background: white;
    border: 1px solid #ddd;
    border-radius: 6px;
    margin: 10px;
    cursor: pointer;
    user-select: none;
    box-shadow: 0 2px 6px rgba(0,0,0,0.1);
  }
  .zoom-btn {
    display: block;
    width: 36px;
    height: 36px;
    text-align: center;
    line-height: 36px;
    font-weight: bold;
    font-size: 20px;
    border: 0;
    background: none;
  }
  .zoom-btn:not(:last-child) { border-bottom: 1px solid #eee; }
  .zoom-btn:hover { background: #f8f9fa; }

  .attrib {
    position: absolute;
    bottom: 10px;
    right: 10px;
    z-index: 1100;
    font-size: 11px;
    padding: 4px 8px;
    background: rgba(255,255,255,0.9);
    border-radius: 4px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  }

  /* Placement for controls */
  .control-top-left { top: 0; left: 0; }
  .control-top-right { top: 0; right: 0; }
  .control-bottom-left { bottom: 0; left: 0; }
  .control-bottom-right { bottom: 0; right: 0; }
</style>
</head>
<body>
<div id="map" tabindex="0" aria-label="Interactive map"></div>

<script>
/* =============================
   FIXED CRS (web mercator math)
   ============================= */
const CRS = {
  EPSG3857: {
    R: 6378137,
    MAX: 20037508.34,
    project: (lat, lon) => {
      const x = lon * (CRS.EPSG3857.MAX / 180);
      let y = Math.log(Math.tan((90 + lat) * Math.PI / 360)) * (CRS.EPSG3857.MAX / Math.PI);
      return { x, y };
    },
    unproject: (x, y) => {
      const lon = x * 180 / CRS.EPSG3857.MAX;
      let lat = (y / CRS.EPSG3857.MAX) * Math.PI;
      lat = 180 / Math.PI * (2 * Math.atan(Math.exp(lat)) - Math.PI / 2);
      return { lat, lon };
    },
    scale: (zoom) => 256 * Math.pow(2, zoom),
    tileSize: 256
  }
};

/* ==== Base Classes ==== */
class Layer { onAdd(){} onRemove(){} render(){} }
class Control { onAdd(){} onRemove(){} }

/* ===================
   CORE MAP OBJECT
   =================== */
class AtlasMap {
  constructor(el, opts={}) {
    const { lat=0, lon=0, zoom=2, minZoom=1, maxZoom=19 } = opts;
    this.container = el;
    this.lat = lat; this.lon = lon; this.zoom = zoom;
    this.minZoom=minZoom; this.maxZoom=maxZoom;
    this.crs = CRS.EPSG3857;
    this.layers = [];
    this.controls = [];
    this._needRender = false;
    this._isZooming = false;

    this._initPanes();
    this._bindHandlers();
    this._setupResize();
    this.invalidate();
    this.loop();
  }

  _initPanes() {
    ["tilePane","overlayPane","popupPane"].forEach(cls=>{
      const d = document.createElement("div"); d.className="pane "+cls;
      this.container.append(d); this[cls]=d;
    });
    this.markerPane=document.createElement("div");
    this.markerPane.className="markerPane"; this.overlayPane.append(this.markerPane);
  }

  size(){ return {width:this.container.clientWidth,height:this.container.clientHeight}; }

  setView(lat,lon,z=this.zoom){ 
    const maxLat=85.0511; lat=Math.max(Math.min(lat,maxLat),-maxLat);
    lon=((lon+180)%360+360)%360-180;
    z=Math.max(this.minZoom,Math.min(z,this.maxZoom));
    this.lat=lat; this.lon=lon; this.zoom=z; this.invalidate();
  }

  panBy(dx,dy){ /* unchanged */ 
    const z=this.zoom, scale=this.crs.scale(z);
    const center=this.crs.project(this.lat,this.lon);
    let x=center.x+dx/scale, y=center.y+dy/scale;
    const ww=40075016.686; x=((x%ww)+ww)%ww;
    const nc=this.crs.unproject(x,y); this.setView(nc.lat,nc.lon,z);
  }

  pointToLatLng(px,py,z=this.zoom){ /* unchanged */ 
    const {width,height}=this.size(), scale=this.crs.scale(z);
    const center=this.crs.project(this.lat,this.lon);
    const wx=center.x+(px-width/2)/scale, wy=center.y+(py-height/2)/scale;
    return this.crs.unproject(wx,wy);
  }
  latLngToPoint(lat,lon,z=this.zoom){ 
    const {width,height}=this.size(), scale=this.crs.scale(z);
    const center=this.crs.project(this.lat,this.lon);
    const p=this.crs.project(lat,lon);
    return {x:width/2+(p.x-center.x)*scale, y:height/2+(p.y-center.y)*scale};
  }

  /* Smooth zoom interpolation ðŸ§ˆ */
  zoomAt(px,py,newZ){ 
    newZ=Math.max(this.minZoom,Math.min(newZ,this.maxZoom));
    if(this._isZooming){ return; }
    this._isZooming=true;
    const startZoom=this.zoom; const diff=newZ-startZoom;
    const duration=200; const start=performance.now();
    const step=(t)=>{
      const p=Math.min(1,(t-start)/duration);
      const z=startZoom+diff*p;
      const anchor=this.pointToLatLng(px,py,startZoom);
      const {width,height}=this.size(); const scale=this.crs.scale(z);
      const proj=this.crs.project(anchor.lat,anchor.lon);
      let cx=proj.x-(px-width/2)/scale, cy=proj.y-(py-height/2)/scale;
      const ww=40075016.686; cx=((cx%ww)+ww)%ww;
      const nc=this.crs.unproject(cx,cy);
      this.lat=nc.lat; this.lon=nc.lon; this.zoom=z; this.invalidate();
      if(p<1) requestAnimationFrame(step); else this._isZooming=false;
    };
    requestAnimationFrame(step);
  }

  addLayer(layer){ layer.onAdd(this); this.layers.push(layer); this.invalidate(); return this; }
  removeLayer(layer){ layer.onRemove(); this.layers=this.layers.filter(l=>l!==layer); this.invalidate(); return this; }

  addControl(control,position="top-left"){ 
    const el=control.onAdd(this); el.classList.add("control",`control-${position}`);
    this.container.appendChild(el); this.controls.push({control,el}); return this;
  }

  invalidate(){ this._needRender=true; }
  loop(){ if(this._needRender){ this.layers.forEach(l=>l.render?.()); this._needRender=false; } requestAnimationFrame(()=>this.loop()); }
  _setupResize(){ new ResizeObserver(()=>this.invalidate()).observe(this.container); }

  _bindHandlers(){
    let dragging=false,lastX=0,lastY=0,pinching=false,pinchStartDist=0,pinchStartZoom=0,pinchAnchorLL=null;
    this.container.addEventListener("mousedown",e=>{dragging=true;lastX=e.clientX;lastY=e.clientY;this.container.classList.add("grabbing");});
    this.container.addEventListener("mousemove",e=>{if(!dragging)return;this.panBy(lastX-e.clientX,lastY-e.clientY);lastX=e.clientX;lastY=e.clientY;});
    window.addEventListener("mouseup",()=>{dragging=false;this.container.classList.remove("grabbing");});
    // Touch
    this.container.addEventListener("touchstart",e=>{
      if(e.touches.length===1){dragging=true;lastX=e.touches[0].clientX;lastY=e.touches[0].clientY;}
      else if(e.touches.length===2){pinching=true;dragging=false;const dx=e.touches[0].clientX-e.touches[1].clientX,dy=e.touches[0].clientY-e.touches[1].clientY;
        pinchStartDist=Math.hypot(dx,dy);pinchStartZoom=this.zoom;const rect=this.container.getBoundingClientRect();const midX=(e.touches[0].clientX+e.touches[1].clientX)/2,midY=(e.touches[0].clientY+e.touches[1].clientY)/2;pinchAnchorLL=this.pointToLatLng(midX-rect.left,midY-rect.top,this.zoom);}
    });
    this.container.addEventListener("touchmove",e=>{
      if(pinching&&e.touches.length>=2){const dx=e.touches[0].clientX-e.touches[1].clientX,dy=e.touches[0].clientY-e.touches[1].clientY;const dist=Math.hypot(dx,dy);const scale=dist/pinchStartDist||1;const newZ=pinchStartZoom+Math.log2(scale);const rect=this.container.getBoundingClientRect();const midX=(e.touches[0].clientX+e.touches[1].clientX)/2,midY=(e.touches[0].clientY+e.touches[1].clientY)/2;this.zoomAt(midX-rect.left,midY-rect.top,newZ);}
      else if(dragging&&e.touches.length===1){this.panBy(lastX-e.touches[0].clientX,lastY-e.touches[0].clientY);lastX=e.touches[0].clientX;lastY=e.touches[0].clientY;}
    });
    this.container.addEventListener("touchend",e=>{if(e.touches.length<2)pinching=false;if(e.touches.length===0)dragging=false;});
    // Wheel zoom
    this.container.addEventListener("wheel",e=>{e.preventDefault();const rect=this.container.getBoundingClientRect();const px=e.clientX-rect.left,py=e.clientY-rect.top;const delta=-Math.sign(e.deltaY)*0.5;this.zoomAt(px,py,this.zoom+delta);},{passive:false});
    // Double click zoom
    this.container.addEventListener("dblclick",e=>{const rect=this.container.getBoundingClientRect();this.zoomAt(e.clientX-rect.left,e.clientY-rect.top,this.zoom+1);});
  }
}

/* ====================
   Tile Layer with LRU cache & Retina tiles
   ==================== */
class TileLayer extends Layer {
  constructor(url="https://tile.openstreetmap.org/{z}/{x}/{y}.png",maxCache=300){super();this.urlTpl=url;this.cache=new Map();this.maxCache=maxCache;}
  onAdd(map){this.map=map;this.container=document.createElement("div");this.container.className="tileLayer";map.tilePane.appendChild(this.container);}
  url(z,x,y){const dpr=window.devicePixelRatio>1?2:"";return this.urlTpl.replace("{z}",z).replace("{x}",x).replace("{y}",y)+(dpr?"?scale=2":"");}
  _getTile(key,url){let t=this.cache.get(key);if(!t){const img=new Image();img.className="tile";t={key,url,img};this.cache.set(key,t);if(this.cache.size>this.maxCache){const oldest=this.cache.keys().next().value;const old=this.cache.get(oldest);old.img.remove();this.cache.delete(oldest);}img.onload=()=>img.classList.add("loaded");img.src=url;}return t;}
  render(){const {width,height}=this.map.size();const {lat,lon,zoom}=this.map;const z=Math.floor(zoom),f=zoom-z;this.container.style.transform=`scale(${Math.pow(2,f)})`;const center=this.map.crs.project(lat,lon),scale=this.map.crs.scale(z);const tilesX=Math.ceil(width/256)+2,tilesY=Math.ceil(height/256)+2;const startX=Math.floor(center.x/scale-tilesX/2),startY=Math.floor(center.y/scale-tilesY/2);const offX=width/2-(center.x/scale-startX)*256,offY=height/2-(center.y/scale-startY)*256;const max=Math.pow(2,z);for(let x=startX;x<startX+tilesX;x++){for(let y=startY;y<startY+tilesY;y++){if(y<0||y>=max)continue;const wx=((x%max)+max)%max;const key=`${z}/${wx}/${y}`;const url=this.url(z,wx,y);const t=this._getTile(key,url);if(t.img.parentNode!==this.container)this.container.appendChild(t.img);t.img.style.transform=`translate(${offX+(x-startX)*256}px,${offY+(y-startY)*256}px)`;}}}
}

/* ====================
   Marker Layer â€” persistent DOM
   ==================== */
class MarkerLayer extends Layer {
  constructor(){super();this.markers=[];}
  onAdd(map){this.map=map;this.container=map.markerPane;this.markers.forEach(m=>this._createNode(m));}
  addMarker(lat,lon,text,emoji="ðŸ“"){const m={lat,lon,text,emoji};this.markers.push(m);if(this.container)this._createNode(m);return m;}
  _createNode(m){const node=document.createElement("div");node.className="marker";node.textContent=m.emoji;node.setAttribute("aria-label",m.text||"Marker");node.addEventListener("click",e=>{e.stopPropagation();this.map.openPopup(`<b>${m.text}</b>`,m.lat,m.lon);});m.node=node;this.container.appendChild(node);this.renderOne(m);}
  render(){this.markers.forEach(m=>this.renderOne(m));}
  renderOne(m){if(!m.node)return;const pt=this.map.latLngToPoint(m.lat,m.lon);m.node.style.left=pt.x+"px";m.node.style.top=pt.y+"px";}
}

/* PopupLayer unchanged */
class PopupLayer extends Layer{/* same as before for brevity */}

/* ZoomControl unchanged */
class ZoomControl extends Control{/* same as before */}

/* ====================
   INIT
   ==================== */
document.addEventListener("DOMContentLoaded",()=>{
  const map=new AtlasMap(document.getElementById("map"),{lat:27.9384,lon:-12.9167,zoom:12,minZoom:3,maxZoom:18});
  map.addLayer(new TileLayer());
  const markers=new MarkerLayer();map.addLayer(markers);markers.addMarker(27.9384,-12.9167,"Tarfaya, Morocco ðŸ‡²ðŸ‡¦");
  map.addControl(new ZoomControl(),"top-left");
  const attrib=document.createElement("div");attrib.className="attrib";attrib.innerHTML='Â© <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a>';map.container.appendChild(attrib);
});
</script>
</body>
</html>
