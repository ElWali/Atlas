<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="referrer" content="origin">
  <title>Atlas - Custom OSM Viewer</title>
  <style>
    html, body {
      margin: 0; padding: 0; height: 100%; width: 100%; overflow: hidden; font-family: sans-serif;
    }
    #map-container {
      position: relative; width: 100vw; height: 100vh; overflow: hidden; background: #e6e6e6;
      touch-action: none;
    }
    #map {
      width: 100%; height: 100%; display: block;
    }
    .zoom-controls {
      position: absolute; top: 10px; left: 10px; display: flex; flex-direction: column; gap: 5px; z-index: 12;
    }
    .zoom-btn {
      background: white; border: 1px solid #ccc; font-size: 16px; padding: 4px 8px; cursor: pointer;
      border-radius: 3px; user-select: none;
    }
    .zoom-btn:hover, .zoom-btn:focus {
      background: #f0f0f0;
      outline: 2px solid #0078A8;
      outline-offset: 2px;
    }
    .zoom-btn:active {
      background: #e0e0e0;
      transform: scale(0.95);
      transition: transform 0.05s;
    }
    .zoom-btn[disabled] {
      background: #f5f5f5;
      color: #aaa;
      cursor: not-allowed;
      transform: none;
      border-color: #ddd;
    }
    #loading {
      position: absolute; top: 10px; right: 10px; background: rgba(255,255,255,0.9); padding: 4px 8px;
      border-radius: 3px; font-size: 12px; display: none; z-index: 20;
    }
    #loading.visible { display: block; }
    #coords {
      position: absolute; bottom: 25px; left: 5px; background: rgba(255,255,255,0.7); font-size: 12px;
      padding: 2px 6px; border-radius: 2px; z-index: 10;
    }
    #zoom-overlay {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: rgba(255,255,255,0.8); font-size: 20px; padding: 6px 12px; border-radius: 4px;
      opacity: 0; transition: opacity 0.25s; pointer-events: none; z-index: 100;
    }
    .scale-bar-container {
      position: absolute; bottom: 5px; right: 10px; text-align: center; font-size: 11px; color: #333; z-index: 10;
    }
    .scale-bar {
      height: 4px; background: black; margin-bottom: 2px;
    }
    #attribution {
      position: absolute; bottom: 5px; left: 10px; background: rgba(255,255,255,0.8); font-size: 11px;
      padding: 2px 6px; border-radius: 3px; font-family: sans-serif; z-index: 10;
    }
    #attribution a {
      text-decoration: none; color: #0078A8;
    }
    #fullscreen {
      position: absolute; top: 10px; right: 10px; background: white; border: 1px solid #ccc; padding: 4px 8px;
      border-radius: 3px; cursor: pointer; font-size: 16px; z-index: 13;
    }
    @keyframes zoom-indicator {
      0% { transform: scale(0.2); opacity: 0.8; }
      100% { transform: scale(1.2); opacity: 0; }
    }
    #retina-toggle-bar {
      position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
      background: rgba(255,255,255,0.9); padding: 2px 8px; border-radius: 3px;
      font-size: 12px; z-index: 15; cursor: pointer;
    }
    #retina-toggle-bar:focus {
      outline: 2px solid #0078A8;
      outline-offset: 2px;
    }
  </style>
</head>
<body>
  <div id="map-container">
    <canvas id="map" aria-label="Interactive Map" role="img"></canvas>
    <div class="zoom-controls">
      <button id="zoom-in" class="zoom-btn" aria-label="Zoom In" title="Zoom In">+</button>
      <button id="zoom-out" class="zoom-btn" aria-label="Zoom Out" title="Zoom Out">−</button>
    </div>
    <button id="fullscreen" aria-label="Fullscreen" title="Fullscreen">⛶</button>
    <div id="loading">Loading: <span id="loading-count">0</span></div>
    <div id="zoom-overlay"></div>
    <div id="coords"></div>
    <div class="scale-bar-container">
      <div class="scale-bar"></div>
      <div id="scale-text" aria-label="Scale Bar" title="Click to toggle units"></div>
    </div>
    <div id="attribution">
      © <a href="https://www.openstreetmap.org/copyright" target="_blank" rel="noopener">OpenStreetMap contributors</a>
    </div>
  </div>
<script>
/* --- Atlas.js: Performance-Optimized Version --- */
class AtlasConfig {
  static EARTH_RADIUS = 6378137;
  static EARTH_CIRCUMFERENCE = 2 * Math.PI * AtlasConfig.EARTH_RADIUS;
  static MAX_LATITUDE = 85.05112878;
  static MIN_LATITUDE = -85.05112878;
  static TILE_SIZE = 256;
  static TILE_BUFFER = 3;
  static TILE_TTL = 1000 * 60 * 60 * 24;
  static SCALE_BAR_TARGET_PX = 120;
  static INERTIA_DECEL = 0.0025;
  static INERTIA_STOP_SPEED = 0.02;
  static VELOCITY_WINDOW_MS = 120;
  static DOUBLE_TAP_MAX_DELAY = 300;
  static DOUBLE_TAP_MAX_MOVE = 16;
  static TWO_FINGER_TAP_MAX_DELAY = 250;
  static TWO_FINGER_TAP_MOVE_THRESH = 10;
  static ROTATE_MOVE_THRESH_RAD = 0.08;
  static WHEEL_ZOOM_STEP = 0.25;
  static WHEEL_ZOOM_DURATION = 220;
  static TAP_ZOOM_DURATION = 280;
  static SNAP_DURATION = 300;
  static FLYTO_DURATION = 800;
  static MAX_CONCURRENT_TILE_LOADS = 12;
  static CONFIG = {
    minZoom: 2,
    maxZoom: 19,
    defaultZoom: 3,
    defaultCenter: { lon: 0, lat: 0 },
    tileServers: [
      "https://a.tile.openstreetmap.org",
      "https://b.tile.openstreetmap.org",
      "https://c.tile.openstreetmap.org"
    ],
    maxCacheSize: 600,
    retina: "auto",
    retinaSuffix: "@2x"
  };
}
const RAD2DEG = 180 / Math.PI;
const DEG2RAD = Math.PI / 180;
const EASING = {
  easeInOutCubic: t => t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3)/2,
  easeOutCubic: t => 1 - Math.pow(1 - t, 3),
  linear: t => t
};
function normalizeAngle(rad) { return Math.atan2(Math.sin(rad), Math.cos(rad)); }
function shortestAngleDiff(from, to) { return normalizeAngle(to - from); }
function wrapDeltaLon(delta) { return ((delta + 180) % 360 + 360) % 360 - 180; }
function rot(x, y, ang) {
  const c = Math.cos(ang), s = Math.sin(ang);
  return { x: x*c - y*s, y: x*s + y*c };
}
class GISUtils {
  static toRadians(d) { return d * Math.PI/180; }
  static toDegrees(r) { return r * 180/Math.PI; }
  static wrapLongitude(l) {
    while (l > 180) l -= 360;
    while (l < -180) l += 360;
    return l;
  }
  static clampLatitude(lat) {
    return Math.max(AtlasConfig.MIN_LATITUDE, Math.min(AtlasConfig.MAX_LATITUDE, lat));
  }
  static getResolution(lat, z) {
    return (AtlasConfig.EARTH_CIRCUMFERENCE * Math.cos(this.toRadians(lat))) / (Math.pow(2, z) * AtlasConfig.TILE_SIZE);
  }
  static formatDistance(m) {
    return m < 1000 ? Math.round(m) + " m" : (m/1000).toFixed(1) + " km";
  }
  static tileToLonLat(x, y, z) {
    const scale = Math.pow(2, z);
    const lon = x / scale * 360 - 180;
    const n = Math.PI - 2 * Math.PI * y / scale;
    const lat = this.toDegrees(Math.atan(Math.sinh(n)));
    return { lon, lat };
  }
}
class Atlas {
  constructor(id, options = {}) {
    this.options = Object.assign({}, AtlasConfig.CONFIG, options);
    this.canvas = document.getElementById(id);
    this.ctx = this.canvas.getContext("2d");
    this.container = document.getElementById("map-container");
    this.tileCache = new Map();
    this.loadingTiles = new Set();
    this.tileLoadQueue = [];
    this.activeTileLoads = 0;
    this.center = {
      lon: GISUtils.wrapLongitude(this.options.defaultCenter.lon),
      lat: GISUtils.clampLatitude(this.options.defaultCenter.lat)
    };
    this.zoom = this.options.defaultZoom;
    this.bearing = 0;
    this.isDragging = false; this.dragStart = null;
    this.renderScheduled = false;
    this.lastRenderTime = 0;
    this.zoomOverlay = document.getElementById("zoom-overlay");
    this.loadingEl = document.getElementById("loading");
    this.loadingCountEl = document.getElementById("loading-count");
    this.coordsEl = document.getElementById("coords");
    this.scaleBarEl = document.querySelector(".scale-bar");
    this.scaleTextEl = document.getElementById("scale-text");
    this.attributionEl = document.getElementById("attribution");
    this._retinaAvailable = true;
    this._inertiaRAF = null;
    this._moveSamples = [];
    this.isPinching = false;
    this.pinchStartDist = 0;
    this.pinchStartAngle = 0;
    this.pinchStartZoom = this.zoom;
    this.pinchStartBearing = this.bearing;
    this.pinchStartTime = 0;
    this.pinchLastCenter = null;
    this._pinchMoved = false;
    this._pinchAnchorLL = null;
    this._lastTapTime = 0;
    this._lastTapPos = {x:0, y:0};
    this._singleTouchStart = null;
    this._singleTouchMoved = false;
    this._zoomAnim = null;
    this._flyAnim = null;
    this._zTimer = null;
    this._zoomIndicator = null;
    this._fullscreenActive = false;
    this._retinaMode = this.options.retina;
    this.initRetinaToggle();
    this.initAccessibility();
    this.resize();
    this.setupEvents();
    this.initControls();
    this.scheduleRender();
    if (window.location.hostname !== "localhost") {
      console.warn(
        `[Atlas] You are using OpenStreetMap's tile servers.\n` +
        `Please comply with Tile Usage Policy: https://operations.osmfoundation.org/policies/tiles/\n` +
        `- No heavy automated usage\n- Consider your own tile server for production apps`
      );
    }
  }
  scheduleRender() {
    if (this.renderScheduled) return;
    this.renderScheduled = true;
    window.requestAnimationFrame(() => {
      const now = performance.now();
      if (now - this.lastRenderTime >= 20) {
        this._draw();
        this.lastRenderTime = now;
      }
      this.renderScheduled = false;
    });
  }
  render() { this.scheduleRender(); }
  resize() {
    clearTimeout(this._resizeTimer);
    this._resizeTimer = setTimeout(() => {
      const w = this.container.offsetWidth, h = this.container.offsetHeight;
      this.dpr = window.devicePixelRatio || 1;
      this.canvas.width = w * this.dpr; this.canvas.height = h * this.dpr;
      this.canvas.style.width = w + "px"; this.canvas.style.height = h + "px";
      this.ctx.setTransform(this.dpr, 0, 0, this.dpr, 0, 0);
      this.scheduleRender();
    }, 60);
  }
  processTileQueue() {
    while (this.tileLoadQueue.length > 0 && this.activeTileLoads < AtlasConfig.MAX_CONCURRENT_TILE_LOADS) {
      const {key, url, resolve} = this.tileLoadQueue.shift();
      this._actuallyLoadTile(key, url, resolve);
    }
  }
  loadTile(key, url) {
    return new Promise(resolve => {
      if (this.tileCache.has(key)) return resolve(this.tileCache.get(key));
      if (this.loadingTiles.has(key)) return resolve(null);
      this.tileLoadQueue.push({key, url, resolve});
      this.processTileQueue();
    });
  }
  _actuallyLoadTile(key, url, resolve) {
    this.activeTileLoads++;
    this.loadingTiles.add(key);
    const img = new window.Image();
    img.crossOrigin = "anonymous";
    const tile = { img, loaded: false, loadedAt: Date.now(), lastUsed: Date.now() };
    this.tileCache.set(key, tile);
    img.onload = () => {
      tile.loaded = true; tile.loadedAt = Date.now();
      this.loadingTiles.delete(key);
      this.activeTileLoads--;
      resolve(tile);
      this.scheduleRender();
      this.processTileQueue();
    };
    img.onerror = () => {
      if (url.includes(this.options.retinaSuffix)) {
        this._retinaAvailable = false;
        img.src = url.replace(this.options.retinaSuffix, "");
        return;
      }
      this.loadingTiles.delete(key);
      this.activeTileLoads--;
      resolve(null);
      this.processTileQueue();
    };
    img.src = url;
  }
  evict() {
    if (this.tileCache.size <= this.options.maxCacheSize) return;
    const keepKeys = new Set();
    const centerTile = this.lonLatToTile(this.center.lon, this.center.lat, Math.floor(this.zoom));
    for (const dz of [
      Math.floor(this.zoom)-1,
      Math.floor(this.zoom),
      Math.floor(this.zoom)+1
    ]) {
      for (let dx = -AtlasConfig.TILE_BUFFER; dx <= AtlasConfig.TILE_BUFFER; dx++) {
        for (let dy = -AtlasConfig.TILE_BUFFER; dy <= AtlasConfig.TILE_BUFFER; dy++) {
          const key = `${dz}/${Math.floor(centerTile.x)+dx}/${Math.floor(centerTile.y)+dy}`;
          keepKeys.add(key);
        }
      }
    }
    const entries = Array.from(this.tileCache.entries()).filter(([k]) => !keepKeys.has(k));
    entries.sort((a, b) => a[1].lastUsed - b[1].lastUsed);
    const removeCount = this.tileCache.size - this.options.maxCacheSize;
    for (let i = 0; i < removeCount; i++) {
      this.tileCache.delete(entries[i][0]);
    }
  }
  initRetinaToggle() {
    const bar = document.createElement("div");
    bar.id = "retina-toggle-bar";
    bar.innerText = "Retina: " + (this._retinaMode === true ? "On" : this._retinaMode === false ? "Off" : "Auto");
    bar.title = "Click to toggle retina mode";
    bar.setAttribute("tabindex", "0");
    bar.setAttribute("aria-label", "Toggle retina mode");
    bar.onclick = () => {
      if (this._retinaMode === "auto") this._retinaMode = true;
      else if (this._retinaMode === true) this._retinaMode = false;
      else this._retinaMode = "auto";
      bar.innerText = "Retina: " + (this._retinaMode === true ? "On" : this._retinaMode === false ? "Off" : "Auto");
      this.scheduleRender();
    };
    bar.onkeydown = (e) => {
      if (e.key === "Enter" || e.key === " ") { bar.onclick(); }
    };
    this.container.appendChild(bar);
    this._retinaToggleBar = bar;
  }
  initAccessibility() {
    for (const btn of this.container.querySelectorAll('.zoom-btn, #fullscreen')) {
      if (!btn.title) btn.title = btn.getAttribute('aria-label') || btn.innerText;
      btn.setAttribute('tabindex', "0");
    }
    this.canvas.setAttribute('role', 'img');
    this.canvas.setAttribute('aria-label', 'Interactive Map');
  }
  toggleFullscreen() {
    if (!this._fullscreenActive) {
      if (this.container.requestFullscreen) {
        this.container.requestFullscreen();
      } else if (this.container.webkitRequestFullscreen) {
        this.container.webkitRequestFullscreen();
      }
      this._fullscreenActive = true;
    } else {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
      }
      this._fullscreenActive = false;
    }
  }
  getTileUrl(x, y, z) {
    const scale = Math.pow(2, z);
    const intX = Math.floor((x % scale) + scale) % scale;
    const intY = Math.max(0, Math.min(scale - 1, Math.floor(y)));
    const idx = (intX + intY) % this.options.tileServers.length;
    let url = `${this.options.tileServers[idx]}/${z}/${intX}/${intY}.png`;
    if (this.shouldRequestRetina()) url += this.options.retinaSuffix;
    return url;
  }
  shouldRequestRetina() {
    const mode = this._retinaMode;
    const want = (mode === true) || (mode === "auto" && (window.devicePixelRatio || 1) > 1.5);
    return want && this._retinaAvailable;
  }
  lonLatToTile(lon, lat, z) {
    lat = GISUtils.clampLatitude(lat); lon = GISUtils.wrapLongitude(lon);
    const scale = Math.pow(2, z);
    const x = (lon + 180) / 360 * scale;
    const y = (1 - Math.log(Math.tan(GISUtils.toRadians(lat)) + 1 / Math.cos(GISUtils.toRadians(lat))) / Math.PI) / 2 * scale;
    return { x, y };
  }
  preloadAdjacentZoomTiles() {
    const zInt = Math.floor(this.zoom);
    const nextZoom = Math.min(this.options.maxZoom, zInt + 1);
    const prevZoom = Math.max(this.options.minZoom, zInt - 1);
    if (Math.abs(this.zoom - zInt) > 0.3) return;
    const ct = this.lonLatToTile(this.center.lon, this.center.lat, zInt);
    const ts = AtlasConfig.TILE_SIZE;
    const w = this.canvas.width / this.dpr;
    const h = this.canvas.height / this.dpr;
    const viewportTiles = Math.ceil(Math.max(w, h) / ts) + AtlasConfig.TILE_BUFFER;
    for (let dz of [prevZoom, nextZoom]) {
      if (dz === zInt) continue;
      const scaleDiff = Math.pow(2, Math.abs(dz - zInt));
      const startX = Math.floor(ct.x * (dz > zInt ? scaleDiff : 1/scaleDiff) - viewportTiles/2);
      const startY = Math.floor(ct.y * (dz > zInt ? scaleDiff : 1/scaleDiff) - viewportTiles/2);
      for (let dx = 0; dx < viewportTiles; dx++) {
        for (let dy = 0; dy < viewportTiles; dy++) {
          const X = startX + dx, Y = startY + dy;
          const key = `${dz}/${X}/${Y}`;
          if (!this.tileCache.has(key) && !this.loadingTiles.has(key)) {
            const url = this.getTileUrl(X, Y, dz);
            this.loadTile(key, url);
          }
        }
      }
    }
  }
  _draw() {
    const w = this.canvas.width / this.dpr, h = this.canvas.height / this.dpr;
    this.ctx.fillStyle = "#e6e6e6"; this.ctx.fillRect(0, 0, w, h);
    const zInt = Math.floor(this.zoom);
    const scaleFactor = Math.pow(2, this.zoom - zInt);
    const ts = AtlasConfig.TILE_SIZE;
    const ct = this.lonLatToTile(this.center.lon, this.center.lat, zInt);
    const absCos = Math.abs(Math.cos(this.bearing)), absSin = Math.abs(Math.sin(this.bearing));
    const needW = w * absCos + h * absSin;
    const needH = w * absSin + h * absCos;
    const cols = Math.ceil(needW / (ts * scaleFactor)) + AtlasConfig.TILE_BUFFER;
    const rows = Math.ceil(needH / (ts * scaleFactor)) + AtlasConfig.TILE_BUFFER;
    const startX = Math.floor(ct.x - cols/2);
    const startY = Math.floor(ct.y - rows/2);
    this.ctx.save();
    this.ctx.translate(w/2, h/2);
    this.ctx.rotate(this.bearing);
    this.ctx.scale(scaleFactor, scaleFactor);
    for (let dx = 0; dx < cols; dx++) {
      for (let dy = 0; dy < rows; dy++) {
        const X = startX + dx, Y = startY + dy;
        const key = `${zInt}/${X}/${Y}`;
        const url = this.getTileUrl(X, Y, zInt);
        const trX = (X - ct.x) * ts;
        const trY = (Y - ct.y) * ts;
        let tile = this.tileCache.get(key);
        if (!tile) {
          this.loadTile(key, url);
        } else if (tile.loaded) {
          this.ctx.drawImage(tile.img, trX, trY, ts, ts);
          tile.lastUsed = Date.now();
          if (tile.loadedAt && (Date.now() - tile.loadedAt > AtlasConfig.TILE_TTL)) {
            // Reload old tile
            this.loadTile(key, url + "?v=" + Date.now());
          }
        }
      }
    }
    this.ctx.restore();
    this.evict();
    this.preloadAdjacentZoomTiles();
    this.loadingEl.classList.toggle("visible", this.loadingTiles.size > 0);
    this.loadingCountEl.textContent = this.loadingTiles.size;
    this.coordsEl.textContent =
      `${this.center.lat.toFixed(6)}°, ${this.center.lon.toFixed(6)}° | Z: ${this.zoom.toFixed(2)} | Bearing: ${(this.bearing*RAD2DEG).toFixed(1)}°`;
    this.updateScaleBar();
    this.updateControlsUI();
  }
  updateScaleBar() {
    if (!this.scaleBarEl || !this.scaleTextEl) return;
    const mPerPx = GISUtils.getResolution(this.center.lat, this.zoom);
    const targetMeters = mPerPx * AtlasConfig.SCALE_BAR_TARGET_PX;
    const pow = Math.pow(10, Math.floor(Math.log10(targetMeters)));
    const base = targetMeters / pow;
    const niceBase = base >= 5 ? 5 : base >= 2 ? 2 : 1;
    const niceMeters = niceBase * pow;
    const widthPx = Math.max(20, Math.min(300, niceMeters / mPerPx));
    this.scaleBarEl.style.width = `${widthPx}px`;
    if (!this.scaleTextEl.dataset.unit) this.scaleTextEl.dataset.unit = "metric";
    let displayText;
    if (this.scaleTextEl.dataset.unit === "metric") {
      displayText = GISUtils.formatDistance(niceMeters);
    } else {
      const feet = niceMeters * 3.28084;
      displayText = feet < 5280 ? Math.round(feet) + " ft" : (feet/5280).toFixed(1) + " mi";
    }
    this.scaleTextEl.textContent = displayText;
    if (!this.scaleTextEl._hasClickListener) {
      this.scaleTextEl.addEventListener("click", () => {
        this.scaleTextEl.dataset.unit = this.scaleTextEl.dataset.unit === "metric" ? "imperial" : "metric";
        this.updateScaleBar();
      });
      this.scaleTextEl._hasClickListener = true;
    }
  }
  setZoom(z) {
    const nz = Math.max(this.options.minZoom, Math.min(this.options.maxZoom, z));
    if (nz === this.zoom) return;
    this.zoom = nz;
    this.scheduleRender();
    this.showZoomOverlay();
    this.updateControlsUI();
  }
  setBearing(rad) {
    const nr = normalizeAngle(rad);
    if (Math.abs(nr - this.bearing) < 1e-6) return;
    this.bearing = nr;
    this.scheduleRender();
  }
  showZoomOverlay() {
    const overlay = this.zoomOverlay;
    overlay.textContent = `Zoom: ${this.zoom.toFixed(2)}`;
    overlay.style.opacity = 1;
    clearTimeout(this._zTimer);
    this._zTimer = setTimeout(() => overlay.style.opacity = 0, 500);
  }
  stopInertia() {
    if (this._inertiaRAF) cancelAnimationFrame(this._inertiaRAF);
    this._inertiaRAF = null;
  }
  stopAnimations() {
    this.stopInertia();
    if (this._zoomAnim?.raf) cancelAnimationFrame(this._zoomAnim.raf);
    this._zoomAnim = null;
    if (this._flyAnim?.raf) cancelAnimationFrame(this._flyAnim.raf);
    this._flyAnim = null;
  }
  resetVelocitySamples() { this._moveSamples = []; }
  pushVelocitySample(x, y) {
    const t = performance.now();
    this._moveSamples.push({ t, x, y });
    const cutoff = t - AtlasConfig.VELOCITY_WINDOW_MS;
    while (this._moveSamples.length && this._moveSamples[0].t < cutoff) {
      this._moveSamples.shift();
    }
  }
  computeVelocity() {
    if (this._moveSamples.length < 2) return { vx: 0, vy: 0 };
    const last = this._moveSamples[this._moveSamples.length - 1];
    let i = this._moveSamples.length - 2;
    while (i > 0 && last.t - this._moveSamples[i].t < AtlasConfig.VELOCITY_WINDOW_MS * 0.5) i--;
    const ref = this._moveSamples[i];
    const dt = Math.max(1, last.t - ref.t);
    return { vx: (last.x - ref.x) / dt, vy: (last.y - ref.y) / dt };
  }
  startInertia(vx, vy) {
    const speed = Math.hypot(vx, vy);
    if (speed < AtlasConfig.INERTIA_STOP_SPEED) return;
    this.stopInertia();
    let lastT = performance.now();
    const step = () => {
      const now = performance.now();
      const dt = now - lastT; lastT = now;
      const dx = vx * dt, dy = vy * dt;
      const w = this.canvas.width / this.dpr;
      const h = this.canvas.height / this.dpr;
      this.center = this.screenToLatLon(w/2 - dx, h/2 - dy);
      const vmag = Math.hypot(vx, vy);
      const newVmag = Math.max(0, vmag - AtlasConfig.INERTIA_DECEL * dt);
      if (newVmag <= AtlasConfig.INERTIA_STOP_SPEED) {
        this.scheduleRender();
        this._inertiaRAF = null;
        return;
      }
      const s = newVmag / (vmag || 1);
      vx *= s; vy *= s;
      this.scheduleRender();
      this._inertiaRAF = requestAnimationFrame(step);
    };
    this._inertiaRAF = requestAnimationFrame(step);
  }
  screenToLatLon(ax, ay, zoom = this.zoom, bearing = this.bearing, center = this.center) {
    const w = this.canvas.width / this.dpr;
    const h = this.canvas.height / this.dpr;
    const zInt = Math.floor(zoom);
    const ts = AtlasConfig.TILE_SIZE * Math.pow(2, zoom - zInt);
    const ct = this.lonLatToTile(center.lon, center.lat, zInt);
    const anchorVec = { x: ax - w/2, y: ay - h/2 };
    const v = rot(anchorVec.x/ts, anchorVec.y/ts, -bearing);
    const tpt = { x: ct.x + v.x, y: ct.y + v.y };
    const ll = GISUtils.tileToLonLat(tpt.x, tpt.y, zInt);
    return {
      lon: GISUtils.wrapLongitude(ll.lon),
      lat: GISUtils.clampLatitude(ll.lat)
    };
  }
  applyZoomRotateAbout(ax, ay, newZoom, newBearing, anchorLL = null) {
    newZoom = Math.max(this.options.minZoom, Math.min(this.options.maxZoom, newZoom));
    const w = this.canvas.width / this.dpr;
    const h = this.canvas.height / this.dpr;
    const anchorVec = { x: ax - w/2, y: ay - h/2 };
    const currAnchorLL = anchorLL || this.screenToLatLon(ax, ay, this.zoom, this.bearing, this.center);
    const zInt = Math.floor(newZoom);
    const ts = AtlasConfig.TILE_SIZE * Math.pow(2, newZoom - zInt);
    const Ptile = this.lonLatToTile(currAnchorLL.lon, currAnchorLL.lat, zInt);
    const v = rot(anchorVec.x/ts, anchorVec.y/ts, -newBearing);
    const ctNew = { x: Ptile.x - v.x, y: Ptile.y - v.y };
    const newCenter = GISUtils.tileToLonLat(ctNew.x, ctNew.y, zInt);
    this.center = {
      lon: GISUtils.wrapLongitude(newCenter.lon),
      lat: GISUtils.clampLatitude(newCenter.lat)
    };
    this.zoom = newZoom;
    this.bearing = normalizeAngle(newBearing);
  }
  showZoomIndicator(x, y) {
    if (this._zoomIndicator) {
      this.container.removeChild(this._zoomIndicator);
    }
    const indicator = document.createElement("div");
    indicator.style.position = "absolute";
    indicator.style.left = (x - 15) + "px";
    indicator.style.top = (y - 15) + "px";
    indicator.style.width = "30px";
    indicator.style.height = "30px";
    indicator.style.borderRadius = "50%";
    indicator.style.border = "2px solid #333";
    indicator.style.opacity = "0.8";
    indicator.style.pointerEvents = "none";
    indicator.style.zIndex = "100";
    indicator.style.animation = "zoom-indicator 0.6s ease-out forwards";
    this.container.appendChild(indicator);
    this._zoomIndicator = indicator;
    setTimeout(() => {
      if (this._zoomIndicator && this._zoomIndicator.parentNode) {
        this.container.removeChild(this._zoomIndicator);
        this._zoomIndicator = null;
      }
    }, 600);
  }
  animateZoomRotateAbout(ax, ay, toZoom, toBearing = this.bearing, duration = AtlasConfig.WHEEL_ZOOM_DURATION, easing = EASING.easeInOutCubic) {
    this.showZoomIndicator(ax, ay);
    this.stopAnimations();
    const startT = performance.now();
    const sZoom = this.zoom;
    const sBear = this.bearing;
    const deltaBear = shortestAngleDiff(sBear, toBearing);
    const anchorLL = this.screenToLatLon(ax, ay, this.zoom, this.bearing, this.center);
    const step = () => {
      const t = (performance.now() - startT) / Math.max(1, duration);
      const p = t >= 1 ? 1 : easing(Math.max(0, Math.min(1, t)));
      const z = sZoom + (toZoom - sZoom) * p;
      const b = sBear + deltaBear * p;
      this.applyZoomRotateAbout(ax, ay, z, b, anchorLL);
      this.scheduleRender();
      if (t < 1) {
        this._zoomAnim = { raf: requestAnimationFrame(step) };
      } else {
        this._zoomAnim = null;
        this.updateControlsUI();
      }
    };
    this._zoomAnim = { raf: requestAnimationFrame(step) };
  }
  smoothZoomAt(ax, ay, deltaZ) {
    const target = Math.max(this.options.minZoom, Math.min(this.options.maxZoom, this.zoom + deltaZ));
    this.animateZoomRotateAbout(ax, ay, target, this.bearing, AtlasConfig.WHEEL_ZOOM_DURATION, EASING.easeInOutCubic);
  }
  flyTo({ center = this.center, zoom = this.zoom, bearing = this.bearing, duration = AtlasConfig.FLYTO_DURATION, easing = EASING.easeInOutCubic } = {}) {
    this.stopAnimations();
    const startT = performance.now();
    const sC = {...this.center}; const eC = {...center};
    const dLon = wrapDeltaLon(eC.lon - sC.lon);
    const dLat = eC.lat - sC.lat;
    const sZ = this.zoom, eZ = Math.max(this.options.minZoom, Math.min(this.options.maxZoom, zoom));
    const sB = this.bearing, dB = shortestAngleDiff(sB, bearing);
    const step = () => {
      const t = (performance.now() - startT) / Math.max(1, duration);
      const p = t >= 1 ? 1 : easing(Math.max(0, Math.min(1, t)));
      this.center = {
        lon: GISUtils.wrapLongitude(sC.lon + dLon * p),
        lat: GISUtils.clampLatitude(sC.lat + dLat * p)
      };
      this.zoom = sZ + (eZ - sZ) * p;
      this.bearing = normalizeAngle(sB + dB * p);
      this.scheduleRender();
      if (t < 1) {
        this._flyAnim = { raf: requestAnimationFrame(step) };
      } else {
        this._flyAnim = null;
        this.updateControlsUI();
      }
    };
    this._flyAnim = { raf: requestAnimationFrame(step) };
  }
  setupEvents() {
    window.addEventListener("resize", () => this.resize());
    this.canvas.addEventListener("mousedown", (e) => {
      this.stopAnimations();
      this.isDragging = true;
      this.dragStart = { x: e.clientX, y: e.clientY, center: {...this.center} };
      this.resetVelocitySamples();
      this.pushVelocitySample(e.clientX, e.clientY);
    });
    window.addEventListener("mousemove", (e) => {
      if (!this.isDragging) return;
      const dx = e.clientX - this.dragStart.x;
      const dy = e.clientY - this.dragStart.y;
      const w = this.canvas.width / this.dpr;
      const h = this.canvas.height / this.dpr;
      this.center = this.screenToLatLon(w/2 - dx, h/2 - dy, this.zoom, this.bearing, this.dragStart.center);
      this.pushVelocitySample(e.clientX, e.clientY);
      this.scheduleRender();
    });
    window.addEventListener("mouseup", () => {
      if (!this.isDragging) return;
      this.isDragging = false;
      const {vx, vy} = this.computeVelocity();
      this.startInertia(vx, vy);
    });
    this.canvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      const dz = (e.deltaY < 0 ? AtlasConfig.WHEEL_ZOOM_STEP : -AtlasConfig.WHEEL_ZOOM_STEP);
      this.smoothZoomAt(e.clientX, e.clientY, dz);
    }, { passive: false });
    this.canvas.addEventListener("dblclick", (e) => {
      e.preventDefault();
      this.animateZoomRotateAbout(e.clientX, e.clientY, this.zoom + 1, this.bearing, AtlasConfig.TAP_ZOOM_DURATION);
    });
    document.getElementById("zoom-in").onclick = () => {
      this.stopAnimations();
      this.setZoom(this.zoom + 1);
    };
    document.getElementById("zoom-out").onclick = () => {
      this.stopAnimations();
      this.setZoom(this.zoom - 1);
    };
    document.getElementById("fullscreen").onclick = () => this.toggleFullscreen();
    window.addEventListener("keydown", (e) => {
      if (e.key === "+" || e.key === "=") { this.stopAnimations(); this.setZoom(this.zoom + 1); }
      else if (e.key === "-") { this.stopAnimations(); this.setZoom(this.zoom - 1); }
      else if (e.key === "ArrowUp") { this.stopAnimations(); this.center.lat = GISUtils.clampLatitude(this.center.lat + 1); this.scheduleRender(); }
      else if (e.key === "ArrowDown") { this.stopAnimations(); this.center.lat = GISUtils.clampLatitude(this.center.lat - 1); this.scheduleRender(); }
      else if (e.key === "ArrowLeft") { this.stopAnimations(); this.center.lon = GISUtils.wrapLongitude(this.center.lon - 1); this.scheduleRender(); }
      else if (e.key === "ArrowRight") { this.stopAnimations(); this.center.lon = GISUtils.wrapLongitude(this.center.lon + 1); this.scheduleRender(); }
      else if (e.key.toLowerCase() === "n") {
        const w = this.canvas.width/this.dpr, h = this.canvas.height/this.dpr;
        this.animateZoomRotateAbout(w/2, h/2, this.zoom, 0, AtlasConfig.SNAP_DURATION);
      }
      else if (e.key === "r") {
        this.setBearing(this.bearing + DEG2RAD * 15);
      }
      else if (e.key === "l") {
        this.setBearing(this.bearing - DEG2RAD * 15);
      }
    });
    // Touch events (same as MVP, use scheduleRender)
    const onTouchStart = (e) => {
      if (!e.touches.length) return;
      e.preventDefault();
      this.stopAnimations();
      if (e.touches.length === 1) {
        this.isPinching = false;
        const t = e.touches[0];
        this.isDragging = true;
        this.dragStart = { x: t.clientX, y: t.clientY, center: {...this.center} };
        this.resetVelocitySamples();
        this.pushVelocitySample(t.clientX, t.clientY);
        this._singleTouchStart = { x: t.clientX, y: t.clientY, t: performance.now() };
        this._singleTouchMoved = false;
      } else if (e.touches.length === 2) {
        this.isDragging = false;
        this.isPinching = true;
        const t1 = e.touches[0], t2 = e.touches[1];
        this.pinchStartDist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
        this.pinchStartAngle = Math.atan2(t2.clientY - t1.clientY, t2.clientX - t1.clientX);
        this.pinchStartZoom = this.zoom;
        this.pinchStartBearing = this.bearing;
        this.pinchStartTime = performance.now();
        this.pinchLastCenter = { x: (t1.clientX + t2.clientX) / 2, y: (t1.clientY + t2.clientY) / 2 };
        this._pinchAnchorLL = this.screenToLatLon(this.pinchLastCenter.x, this.pinchLastCenter.y, this.zoom, this.bearing, this.center);
        this._pinchMoved = false;
      }
    };
    const onTouchMove = (e) => {
      if (!e.touches.length) return;
      e.preventDefault();
      if (this.isPinching && e.touches.length >= 2) {
        const t1 = e.touches[0], t2 = e.touches[1];
        const dist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
        const angle = Math.atan2(t2.clientY - t1.clientY, t2.clientX - t1.clientX);
        const center = { x: (t1.clientX + t2.clientX) / 2, y: (t1.clientY + t2.clientY) / 2 };
        const targetZoom = this.pinchStartZoom + Math.log2(dist / Math.max(1, this.pinchStartDist));
        const deltaAngle = normalizeAngle(angle - this.pinchStartAngle);
        const targetBearing = normalizeAngle(this.pinchStartBearing + deltaAngle);
        if (Math.abs(Math.log(dist / Math.max(1, this.pinchStartDist))) > Math.log(1 + AtlasConfig.TWO_FINGER_TAP_MOVE_THRESH/Math.max(1, this.pinchStartDist)) ||
            Math.abs(deltaAngle) > AtlasConfig.ROTATE_MOVE_THRESH_RAD) {
          this._pinchMoved = true;
        }
        this.applyZoomRotateAbout(center.x, center.y, targetZoom, targetBearing, this._pinchAnchorLL);
        this.pinchLastCenter = center;
        this.pushVelocitySample(center.x, center.y);
        this.scheduleRender();
      } else if (this.isDragging && e.touches.length === 1) {
        const t = e.touches[0];
        if (this._singleTouchStart) {
          const md = Math.hypot(t.clientX - this._singleTouchStart.x, t.clientY - this._singleTouchStart.y);
          if (md > AtlasConfig.DOUBLE_TAP_MAX_MOVE) this._singleTouchMoved = true;
        }
        const dx = t.clientX - this.dragStart.x;
        const dy = t.clientY - this.dragStart.y;
        const w = this.canvas.width / this.dpr;
        const h = this.canvas.height / this.dpr;
        this.center = this.screenToLatLon(w/2 - dx, h/2 - dy, this.zoom, this.bearing, this.dragStart.center);
        this.pushVelocitySample(t.clientX, t.clientY);
        this.scheduleRender();
      }
    };
    const onTouchEnd = (e) => {
      if (this.isPinching && e.touches.length === 0) {
        const dt = performance.now() - this.pinchStartTime;
        if (dt <= AtlasConfig.TWO_FINGER_TAP_MAX_DELAY && !this._pinchMoved) {
          const ax = this.pinchLastCenter ? this.pinchLastCenter.x : (this.canvas.width/this.dpr)/2;
          const ay = this.pinchLastCenter ? this.pinchLastCenter.y : (this.canvas.height/this.dpr)/2;
          this.animateZoomRotateAbout(ax, ay, this.zoom - 1, this.bearing, AtlasConfig.TAP_ZOOM_DURATION);
        }
        this.isPinching = false;
      }
      if (this.isDragging && e.touches.length === 0) {
        const now = performance.now();
        const s = this._singleTouchStart;
        if (s && !this._singleTouchMoved) {
          const dt = now - s.t;
          const distFromLast = Math.hypot(s.x - this._lastTapPos.x, s.y - this._lastTapPos.y);
          if (now - this._lastTapTime <= AtlasConfig.DOUBLE_TAP_MAX_DELAY && distFromLast <= AtlasConfig.DOUBLE_TAP_MAX_MOVE) {
            this.animateZoomRotateAbout(s.x, s.y, this.zoom + 1, this.bearing, AtlasConfig.TAP_ZOOM_DURATION);
            this._lastTapTime = 0;
          } else {
            this._lastTapTime = now;
            this._lastTapPos = { x: s.x, y: s.y };
          }
        }
        this.isDragging = false;
        const {vx, vy} = this.computeVelocity();
        this.startInertia(vx, vy);
      }
    };
    this.canvas.addEventListener("touchstart", onTouchStart, { passive: false });
    this.canvas.addEventListener("touchmove", onTouchMove, { passive: false });
    this.canvas.addEventListener("touchend", onTouchEnd, { passive: false });
    this.canvas.addEventListener("touchcancel", onTouchEnd, { passive: false });
  }
  initControls() {
    const stack = this.container.querySelector(".zoom-controls");
    if (!stack) return;
    const existingCompass = stack.querySelector("#compass");
    const existingResetZoom = stack.querySelector("#reset-zoom");
    if (existingCompass) { stack.removeChild(existingCompass); }
    if (existingResetZoom) { stack.removeChild(existingResetZoom); }
    const compass = document.createElement("button");
    compass.id = "compass";
    compass.className = "zoom-btn";
    compass.title = "Reset North";
    compass.setAttribute("aria-label", "Reset North");
    compass.textContent = "N";
    compass.style.display = "none";
    compass.onclick = () => {
      const w = this.canvas.width/this.dpr, h = this.canvas.height/this.dpr;
      this.animateZoomRotateAbout(w/2, h/2, this.zoom, 0, AtlasConfig.SNAP_DURATION);
    };
    compass.onmouseenter = () => { compass.style.background = "#f0f0f0"; };
    compass.onmouseleave = () => { compass.style.background = "white"; };
    compass.onmousedown = () => { compass.style.transform = "scale(0.95) rotate(" + (-this.bearing*RAD2DEG) + "deg)"; };
    compass.onmouseup = () => { compass.style.transform = "rotate(" + (-this.bearing*RAD2DEG) + "deg)"; };
    stack.appendChild(compass);
    this._compassBtn = compass;
    const resetZoom = document.createElement("button");
    resetZoom.id = "reset-zoom";
    resetZoom.className = "zoom-btn";
    resetZoom.title = "Reset Zoom";
    resetZoom.setAttribute("aria-label", "Reset Zoom");
    resetZoom.textContent = "⤢";
    resetZoom.onclick = () => {
      const w = this.canvas.width/this.dpr, h = this.canvas.height/this.dpr;
      this.animateZoomRotateAbout(w/2, h/2, this.options.defaultZoom, this.bearing, AtlasConfig.SNAP_DURATION);
    };
    resetZoom.onmouseenter = () => { resetZoom.style.background = "#f0f0f0"; };
    resetZoom.onmouseleave = () => { resetZoom.style.background = "white"; };
    resetZoom.onmousedown = () => { resetZoom.style.transform = "scale(0.95)"; };
    resetZoom.onmouseup = () => { resetZoom.style.transform = "scale(1)"; };
    stack.appendChild(resetZoom);
    this._resetZoomBtn = resetZoom;
  }
  updateControlsUI() {
    const zoomInBtn = document.getElementById("zoom-in");
    const zoomOutBtn = document.getElementById("zoom-out");
    if (zoomInBtn) { zoomInBtn.disabled = this.zoom >= this.options.maxZoom; }
    if (zoomOutBtn) { zoomOutBtn.disabled = this.zoom <= this.options.minZoom; }
    if (this._compassBtn) {
      const visible = Math.abs(this.bearing) > 0.001;
      this._compassBtn.style.display = visible ? "block" : "none";
      this._compassBtn.style.transition = "transform 0.3s ease-out";
      this._compassBtn.style.transform = `rotate(${-this.bearing*RAD2DEG}deg)`;
    }
  }
}
// Initialize Atlas only once
if (navigator.geolocation) {
  navigator.geolocation.getCurrentPosition(pos => {
    const atlas = new Atlas("map");
    const lat = pos.coords.latitude;
    const lon = pos.coords.longitude;
    atlas.flyTo({ center: { lat, lon }, zoom: 10 });
  }, () => {
    const atlas = new Atlas("map");
  });
} else {
  const atlas = new Atlas("map");
}
</script>
</body>
</html>
