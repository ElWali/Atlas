<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!-- Added for OSM Tile Usage Policy compliance -->
<meta name="referrer" content="origin">
<title>Atlas - Custom OSM Viewer</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    width: 100%;
    overflow: hidden;
    font-family: sans-serif;
  }
  #map-container {
    position: relative;
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: #e6e6e6;
  }
  #map {
    width: 100%;
    height: 100%;
    display: block;
  }
  .zoom-controls {
    position: absolute;
    top: 10px;
    left: 10px;
    display: flex;
    flex-direction: column;
    gap: 5px;
    z-index: 10;
  }
  .zoom-btn {
    background: white;
    border: 1px solid #ccc;
    font-size: 16px;
    padding: 4px 8px;
    cursor: pointer;
    border-radius: 3px;
    user-select: none;
  }
  #loading {
    position: absolute;
    top: 10px;
    right: 10px;
    background: rgba(255,255,255,0.9);
    padding: 4px 8px;
    border-radius: 3px;
    font-size: 12px;
    display: none;
  }
  #loading.visible {
    display: block;
  }
  #coords {
    position: absolute;
    bottom: 25px;
    left: 5px;
    background: rgba(255,255,255,0.7);
    font-size: 12px;
    padding: 2px 6px;
    border-radius: 2px;
  }
  #zoom-overlay {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(255,255,255,0.8);
    font-size: 20px;
    padding: 6px 12px;
    border-radius: 4px;
    opacity: 0;
    transition: opacity 0.25s;
    pointer-events: none;
  }
  .scale-bar-container {
    position: absolute;
    bottom: 5px;
    right: 10px;
    text-align: center;
    font-size: 11px;
    color: #333;
  }
  .scale-bar {
    height: 4px;
    background: black;
    margin-bottom: 2px;
  }
  #attribution {
    position: absolute;
    bottom: 5px;
    left: 10px;
    background: rgba(255,255,255,0.8);
    font-size: 11px;
    padding: 2px 6px;
    border-radius: 3px;
    font-family: sans-serif;
  }
  #attribution a {
    text-decoration: none;
    color: #0078A8;
  }
</style>
</head>
<body>
  <div id="map-container">
    <canvas id="map"></canvas>
    <div class="zoom-controls">
      <button id="zoom-in" class="zoom-btn">+</button>
      <button id="zoom-out" class="zoom-btn">−</button>
    </div>
    <div id="loading">Loading: <span id="loading-count">0</span></div>
    <div id="zoom-overlay"></div>
    <div id="coords"></div>
    <div class="scale-bar-container">
      <div class="scale-bar"></div>
      <div id="scale-text"></div>
    </div>
    <div id="attribution">
      © <a href="https://www.openstreetmap.org/copyright" target="_blank" rel="noopener">OpenStreetMap contributors</a>
    </div>
  </div>

<script>
// ---------------- Constants ----------------
const EARTH_RADIUS = 6378137;
const EARTH_CIRCUMFERENCE = 2 * Math.PI * EARTH_RADIUS;
const MAX_LATITUDE = 85.05112878;
const MIN_LATITUDE = -85.05112878;
const TILE_SIZE = 256;
const TILE_BUFFER = 2;        // extra tiles beyond view boundary
const FADE_DURATION = 300;    // ms
const TILE_TTL = 1000 * 60 * 60 * 24; // 24h cache freshness
const SCALE_BAR_TARGET_PX = 120; // desired scale bar width in px

// Inertia tuning
const INERTIA_DECEL = 0.0025;     // px/ms^2
const INERTIA_STOP_SPEED = 0.02;  // px/ms
const VELOCITY_WINDOW_MS = 120;   // ms

// Gestures and animation tuning
const DOUBLE_TAP_MAX_DELAY = 300; // ms
const DOUBLE_TAP_MAX_MOVE = 16;   // px
const TWO_FINGER_TAP_MAX_DELAY = 250; // ms
const TWO_FINGER_TAP_MOVE_THRESH = 10; // px
const ROTATE_MOVE_THRESH_RAD = 0.08;   // ~4.5°
const WHEEL_ZOOM_STEP = 0.25;      // per wheel tick
const WHEEL_ZOOM_DURATION = 220;   // ms
const TAP_ZOOM_DURATION = 280;     // ms
const SNAP_DURATION = 300;         // ms
const FLYTO_DURATION = 800;        // ms

const CONFIG = {
  minZoom: 0,
  maxZoom: 19,
  defaultZoom: 2,
  defaultCenter: { lon: 0, lat: 0 },
  // FIXED: Removed trailing spaces from URLs
  tileServers: [
    "https://a.tile.openstreetmap.org",
    "https://b.tile.openstreetmap.org",
    "https://c.tile.openstreetmap.org"
  ],
  maxCacheSize: 500,
  // Retina tiles:
  // - "off" (default for OSM), "auto" (use when DPR>1.5 and provider supports @2x), or true (force).
  retina: "off",
  retinaSuffix: "@2x" // change for providers with other schemes (e.g., ?scale=2)
};

// ---------------- Utilities ----------------
const EASING = {
  easeInOutCubic: (t)=> t<0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3)/2,
  easeOutCubic:  (t)=> 1 - Math.pow(1 - t, 3),
  linear:        (t)=> t
};
const RAD2DEG = 180/Math.PI;
const DEG2RAD = Math.PI/180;

function normalizeAngle(rad){
  // [-PI, PI]
  return Math.atan2(Math.sin(rad), Math.cos(rad));
}
function shortestAngleDiff(from, to){
  return normalizeAngle(to - from);
}
function wrapDeltaLon(delta){
  // shortest delta in [-180, 180)
  delta = ((delta + 180) % 360 + 360) % 360 - 180;
  return delta;
}
function rot(x, y, ang){
  const c = Math.cos(ang), s = Math.sin(ang);
  return { x: x*c - y*s, y: x*s + y*c };
}

// ---------------- GIS Utilities ----------------
class GISUtils {
  static toRadians(d) { return d * Math.PI/180; }
  static toDegrees(r) { return r * 180/Math.PI; }
  static wrapLongitude(l) {
    while (l > 180) l -= 360;
    while (l < -180) l += 360;
    return l;
  }
  static clampLatitude(lat) {
    return Math.max(MIN_LATITUDE, Math.min(MAX_LATITUDE, lat));
  }
  static getResolution(lat,z) {
    // meters per pixel at latitude for zoom z
    return (EARTH_CIRCUMFERENCE * Math.cos(this.toRadians(lat))) / (Math.pow(2,z)*TILE_SIZE);
  }
  static formatDistance(m) {
    return m < 1000 ? Math.round(m) + " m" : (m/1000).toFixed(1) + " km";
  }
  static tileToLonLat(x, y, z) {
    const scale = Math.pow(2, z);
    const lon = x / scale * 360 - 180;
    const n = Math.PI - 2 * Math.PI * y / scale;
    const lat = this.toDegrees(Math.atan(Math.sinh(n)));
    return { lon, lat };
  }
}

// ---------------- Core Viewer ----------------
class Atlas { // <-- CHANGED: Class name from AtlasMap to Atlas
  constructor(id) {
    this.canvas = document.getElementById(id);
    this.ctx = this.canvas.getContext("2d");
    this.container = document.getElementById("map-container");

    this.tileCache = new Map(); // key -> {img, loaded, loadedAt, lastUsed}
    this.loadingTiles = new Set();

    this.center = {...CONFIG.defaultCenter};
    this.zoom = CONFIG.defaultZoom;
    this.bearing = 0; // radians, 0 = north-up

    this.isDragging = false; this.dragStart = null;
    this.renderScheduled = false;
    this.zoomOverlay = document.getElementById("zoom-overlay");
    this.loadingEl = document.getElementById("loading");
    this.loadingCountEl = document.getElementById("loading-count");
    this.coordsEl = document.getElementById("coords");
    this.scaleBarEl = document.querySelector(".scale-bar");
    this.scaleTextEl = document.getElementById("scale-text");

    // Retina availability (auto-disables if first @2x request fails)
    this._retinaAvailable = true;

    // Inertia state
    this._inertiaRAF = null;
    this._moveSamples = []; // recent {t, x, y}

    // Pinch/rotate state
    this.isPinching = false;
    this.pinchStartDist = 0;
    this.pinchStartAngle = 0;
    this.pinchStartZoom = this.zoom;
    this.pinchStartBearing = this.bearing;
    this.pinchStartTime = 0;
    this.pinchLastCenter = null;
    this._pinchMoved = false;
    this._pinchAnchorLL = null;
    this._pinchAnchorVec = null; // screen vec from center (px)

    // Tap state
    this._lastTapTime = 0;
    this._lastTapPos = {x:0, y:0};
    this._singleTouchStart = null; // {x,y,t}
    this._singleTouchMoved = false;

    // Animations
    this._zoomAnim = null; // {raf, startT, dur, sZoom, eZoom, sBear, eBear, anchor, anchorVec}
    this._flyAnim = null;  // {raf, startT, dur, sCenter, eCenter, sZoom, eZoom, sBear, eBear}

    this.resize();
    this.setupEvents();
    this.initControls();
    this.render();
  }

  resize() {
    const w = this.container.offsetWidth, h = this.container.offsetHeight;
    this.dpr = window.devicePixelRatio || 1;
    this.canvas.width = w * this.dpr; this.canvas.height = h * this.dpr;
    this.canvas.style.width = w + "px"; this.canvas.style.height = h + "px";
    this.ctx.setTransform(this.dpr,0,0,this.dpr,0,0);
    this.render();
  }

  lonLatToTile(lon,lat,z){
    lat = GISUtils.clampLatitude(lat); lon = GISUtils.wrapLongitude(lon);
    const scale = Math.pow(2,z);
    const x = (lon + 180)/360 * scale;
    const y = (1 - Math.log(Math.tan(GISUtils.toRadians(lat)) + 1/Math.cos(GISUtils.toRadians(lat))) / Math.PI) / 2 * scale;
    return {x,y};
  }

  shouldRequestRetina() {
    const mode = CONFIG.retina;
    const want = (mode === true) || (mode === "auto" && (window.devicePixelRatio || 1) > 1.5);
    return want && this._retinaAvailable;
  }

  getTileUrl(x,y,z){
    const scale = Math.pow(2,z);
    x = ((x % scale) + scale) % scale; // wrap X
    y = Math.max(0, Math.min(scale-1, y)); // clamp Y
    const idx = (x + y) % CONFIG.tileServers.length;
    let url = `${CONFIG.tileServers[idx]}/${z}/${x}/${y}.png`;
    if (this.shouldRequestRetina()) url += CONFIG.retinaSuffix;
    return url;
  }

  async loadTile(key,url){
    if (this.tileCache.has(key)) return this.tileCache.get(key);
    const img = new Image(); img.crossOrigin = "anonymous";
    const tile = { img, loaded:false, loadedAt:Date.now(), lastUsed:Date.now() };
    this.tileCache.set(key, tile);
    this.loadingTiles.add(key);

    img.onload = () => {
      tile.loaded = true; tile.loadedAt = Date.now();
      this.loadingTiles.delete(key); this.scheduleRender();
    };
    img.onerror = () => {
      console.error("Tile load failed:", url); // ADDED for debugging
      // If @2x failed once, disable provider retina globally and retry 1x
      if (url.includes(CONFIG.retinaSuffix)) {
        this._retinaAvailable = false;
        img.src = url.replace(CONFIG.retinaSuffix, "");
        return;
      }
      this.loadingTiles.delete(key);
    };
    img.src = url;
    return tile;
  }

  reloadTile(key, url) {
    const existing = this.tileCache.get(key);
    if (!existing) return;
    const token = key + "#r";
    if (this.loadingTiles.has(token)) return;

    const img = new Image(); img.crossOrigin = "anonymous";
    this.loadingTiles.add(token);
    img.onload = () => {
      existing.img = img;
      existing.loaded = true;
      existing.loadedAt = Date.now();
      this.loadingTiles.delete(token);
      this.scheduleRender();
    };
    img.onerror = () => {
      this.loadingTiles.delete(token);
    };
    img.src = url + (url.includes("?") ? "&" : "?") + "v=" + Date.now();
  }

  evict(){
    if (this.tileCache.size <= CONFIG.maxCacheSize) return;
    const entries = Array.from(this.tileCache.entries());
    entries.sort((a,b)=> a[1].lastUsed - b[1].lastUsed); // least recently used first
    const removeCount = this.tileCache.size - CONFIG.maxCacheSize;
    for (let i=0; i<removeCount; i++) this.tileCache.delete(entries[i][0]);
  }

  scheduleRender(){
    if(this.renderScheduled) return;
    this.renderScheduled = true;
    requestAnimationFrame(()=>{ this.renderScheduled=false; this._draw(); });
  }

  render(){ this.scheduleRender(); }

  _draw(){
    const w = this.canvas.width/this.dpr, h = this.canvas.height/this.dpr;
    this.ctx.fillStyle = "#e6e6e6"; this.ctx.fillRect(0,0,w,h);

    // Fractional zoom handling
    const zInt = Math.floor(this.zoom);
    const scaleFactor = Math.pow(2, this.zoom - zInt);      // tile scale relative to integer zoom
    const ts = TILE_SIZE * scaleFactor;                      // tile size on screen in px
    const ct = this.lonLatToTile(this.center.lon, this.center.lat, zInt);

    // Overscan for rotation: draw enough tiles to cover rotated viewport
    const absCos = Math.abs(Math.cos(this.bearing)), absSin = Math.abs(Math.sin(this.bearing));
    const needW = w * absCos + h * absSin;
    const needH = w * absSin + h * absCos;

    const cols = Math.ceil(needW / ts) + TILE_BUFFER;
    const rows = Math.ceil(needH / ts) + TILE_BUFFER;
    const startX = Math.floor(ct.x - cols/2);
    const startY = Math.floor(ct.y - rows/2);

    // Rotate canvas about center
    this.ctx.save();
    this.ctx.translate(w/2, h/2);
    this.ctx.rotate(this.bearing);
    this.ctx.translate(-w/2, -h/2);

    for (let dx=0; dx<cols; dx++){
      for (let dy=0; dy<rows; dy++){
        const X = startX + dx, Y = startY + dy;
        const key = `${zInt}/${X}/${Y}`;
        const url = this.getTileUrl(X, Y, zInt);
        const trX = (X - ct.x) * ts + w/2;
        const trY = (Y - ct.y) * ts + h/2;

        let tile = this.tileCache.get(key);
        if (!tile) {
          this.loadTile(key,url);
        } else if (tile.loaded) {
          const age = Date.now() - tile.loadedAt;
          const alpha = age < FADE_DURATION ? Math.pow(age/FADE_DURATION, 0.5) : 1;
          this.ctx.globalAlpha = alpha;
          this.ctx.drawImage(tile.img, trX, trY, ts, ts);
          this.ctx.globalAlpha = 1;
          tile.lastUsed = Date.now();

          // Optional: refresh stale tiles in the background
          if (Date.now() - tile.loadedAt > TILE_TTL) this.reloadTile(key, url);
        }
      }
    }

    this.ctx.restore();
    this.evict();

    // UI updates
    this.loadingEl.classList.toggle("visible", this.loadingTiles.size > 0);
    this.loadingCountEl.textContent = this.loadingTiles.size;
    this.coordsEl.textContent =
      `${this.center.lat.toFixed(6)}°, ${this.center.lon.toFixed(6)}° | Z: ${this.zoom.toFixed(2)} | Bearing: ${(this.bearing*RAD2DEG).toFixed(1)}°`;
    this.updateScaleBar();
    this.updateControlsUI();
  }

  updateScaleBar() {
    if (!this.scaleBarEl || !this.scaleTextEl) return;
    const mPerPx = GISUtils.getResolution(this.center.lat, this.zoom);
    const targetMeters = mPerPx * SCALE_BAR_TARGET_PX;
    // Nice rounding: 1, 2, 5 * 10^k
    const pow = Math.pow(10, Math.floor(Math.log10(targetMeters)));
    const base = targetMeters / pow;
    const niceBase = base >= 5 ? 5 : base >= 2 ? 2 : 1;
    const niceMeters = niceBase * pow;
    const widthPx = Math.max(20, Math.min(300, niceMeters / mPerPx));

    this.scaleBarEl.style.width = `${widthPx}px`;
    this.scaleTextEl.textContent = GISUtils.formatDistance(niceMeters);
  }

  setZoom(z){
    const nz = Math.max(CONFIG.minZoom, Math.min(CONFIG.maxZoom, z));
    if(nz === this.zoom) return;
    this.zoom = nz;
    this.render(); this.showZoomOverlay();
  }

  setBearing(rad){
    const nr = normalizeAngle(rad);
    if (Math.abs(nr - this.bearing) < 1e-6) return;
    this.bearing = nr;
    this.render();
  }

  showZoomOverlay(){
    const overlay = this.zoomOverlay;
    overlay.textContent = `Zoom: ${this.zoom.toFixed(2)}`; overlay.style.opacity = 1;
    clearTimeout(this._zTimer); this._zTimer = setTimeout(()=>overlay.style.opacity=0, 500);
  }

  // ------------- Inertia helpers -------------
  stopInertia(){
    if (this._inertiaRAF) cancelAnimationFrame(this._inertiaRAF);
    this._inertiaRAF = null;
  }
  stopAnimations(){
    this.stopInertia();
    if (this._zoomAnim?.raf) cancelAnimationFrame(this._zoomAnim.raf);
    this._zoomAnim = null;
    if (this._flyAnim?.raf) cancelAnimationFrame(this._flyAnim.raf);
    this._flyAnim = null;
  }
  resetVelocitySamples(){ this._moveSamples = []; }
  pushVelocitySample(x, y){
    const t = performance.now();
    this._moveSamples.push({t, x, y});
    const cutoff = t - VELOCITY_WINDOW_MS;
    while (this._moveSamples.length && this._moveSamples[0].t < cutoff) {
      this._moveSamples.shift();
    }
  }
  computeVelocity(){
    if (this._moveSamples.length < 2) return { vx:0, vy:0 };
    const last = this._moveSamples[this._moveSamples.length - 1];
    let i = this._moveSamples.length - 2;
    while (i > 0 && last.t - this._moveSamples[i].t < VELOCITY_WINDOW_MS * 0.5) i--;
    const ref = this._moveSamples[i];
    const dt = Math.max(1, last.t - ref.t);
    return { vx: (last.x - ref.x)/dt, vy: (last.y - ref.y)/dt };
  }
  panByPixels(dx, dy){
    const res = GISUtils.getResolution(this.center.lat, this.zoom);
    const lonDx = (dx * res) * 360 / EARTH_CIRCUMFERENCE;
    const latDy = (dy * res) * 360 / EARTH_CIRCUMFERENCE;
    this.center = {
      lon: GISUtils.wrapLongitude(this.center.lon - lonDx),
      lat: GISUtils.clampLatitude(this.center.lat + latDy)
    };
  }
  startInertia(vx, vy){
    const speed = Math.hypot(vx, vy);
    if (speed < INERTIA_STOP_SPEED) return;
    this.stopInertia();
    let lastT = performance.now();
    const step = ()=>{
      const now = performance.now();
      const dt = now - lastT; lastT = now;

      const dx = vx * dt, dy = vy * dt;
      this.panByPixels(dx, dy);

      const vmag = Math.hypot(vx, vy);
      const newVmag = Math.max(0, vmag - INERTIA_DECEL * dt);
      if (newVmag <= INERTIA_STOP_SPEED) {
        this.render();
        this._inertiaRAF = null; return;
      }
      const s = newVmag / (vmag || 1);
      vx *= s; vy *= s;

      this.render();
      this._inertiaRAF = requestAnimationFrame(step);
    };
    this._inertiaRAF = requestAnimationFrame(step);
  }

  // -------- Anchor-based zoom/rotate helpers --------
  // Compute the lat/lon at screen point (ax, ay) under current state
  screenToLatLon(ax, ay, zoom = this.zoom, bearing = this.bearing, center = this.center){
    const w = this.canvas.width / this.dpr;
    const h = this.canvas.height / this.dpr;
    const zInt = Math.floor(zoom);
    const ts = TILE_SIZE * Math.pow(2, zoom - zInt);
    const ct = this.lonLatToTile(center.lon, center.lat, zInt);
    const anchorVec = { x: ax - w/2, y: ay - h/2 };
    const v = rot(anchorVec.x/ts, anchorVec.y/ts, -bearing);
    const tpt = { x: ct.x + v.x, y: ct.y + v.y };
    return GISUtils.tileToLonLat(tpt.x, tpt.y, zInt);
  }

  // Apply zoom and/or rotation about screen point (ax, ay), keeping that lat/lon fixed
  applyZoomRotateAbout(ax, ay, newZoom, newBearing, anchorLL = null){
    newZoom = Math.max(CONFIG.minZoom, Math.min(CONFIG.maxZoom, newZoom));
    const w = this.canvas.width / this.dpr;
    const h = this.canvas.height / this.dpr;

    const anchorVec = { x: ax - w/2, y: ay - h/2 };
    // Determine anchor world point once
    const currAnchorLL = anchorLL || this.screenToLatLon(ax, ay, this.zoom, this.bearing, this.center);

    const zInt = Math.floor(newZoom);
    const ts = TILE_SIZE * Math.pow(2, newZoom - zInt);
    const Ptile = this.lonLatToTile(currAnchorLA.lon, currAnchorLA.lat, zInt);
    const v = rot(anchorVec.x/ts, anchorVec.y/ts, -newBearing);
    const ctNew = { x: Ptile.x - v.x, y: Ptile.y - v.y };
    const newCenter = GISUtils.tileToLonLat(ctNew.x, ctNew.y, zInt);

    this.center = { lon: GISUtils.wrapLongitude(newCenter.lon), lat: GISUtils.clampLatitude(newCenter.lat) };
    this.zoom = newZoom;
    this.bearing = normalizeAngle(newBearing);
  }

  // Smooth zoom/rotate about point with easing
  animateZoomRotateAbout(ax, ay, toZoom, toBearing = this.bearing, duration = WHEEL_ZOOM_DURATION, easing = EASING.easeInOutCubic){
    this.stopAnimations(); // stop inertia and other anims, but keep the current state as start
    const startT = performance.now();
    const sZoom = this.zoom;
    const sBear = this.bearing;
    const deltaBear = shortestAngleDiff(sBear, toBearing);
    const anchorLL = this.screenToLatLon(ax, ay, this.zoom, this.bearing, this.center);

    const step = ()=>{
      const t = (performance.now() - startT) / Math.max(1, duration);
      const p = t >= 1 ? 1 : easing(Math.max(0, Math.min(1, t)));
      const z = sZoom + (toZoom - sZoom) * p;
      const b = sBear + deltaBear * p;
      this.applyZoomRotateAbout(ax, ay, z, b, anchorLL);
      this.render();
      if (t < 1) {
        this._zoomAnim = { raf: requestAnimationFrame(step) };
      } else {
        this._zoomAnim = null;
      }
    };
    this._zoomAnim = { raf: requestAnimationFrame(step) };
  }

  smoothZoomAt(ax, ay, deltaZ){
    const target = Math.max(CONFIG.minZoom, Math.min(CONFIG.maxZoom, this.zoom + deltaZ));
    this.animateZoomRotateAbout(ax, ay, target, this.bearing, WHEEL_ZOOM_DURATION, EASING.easeInOutCubic);
  }

  // Fly-to animation (center/zoom/bearing)
  flyTo({ center = this.center, zoom = this.zoom, bearing = this.bearing, duration = FLYTO_DURATION, easing = EASING.easeInOutCubic } = {}){
    this.stopAnimations();
    const startT = performance.now();
    const sC = {...this.center}; const eC = {...center};
    // Shortest-path lon
    const dLon = wrapDeltaLon(eC.lon - sC.lon);
    const dLat = eC.lat - sC.lat;
    const sZ = this.zoom, eZ = Math.max(CONFIG.minZoom, Math.min(CONFIG.maxZoom, zoom));
    const sB = this.bearing, dB = shortestAngleDiff(sB, bearing);

    const step = ()=>{
      const t = (performance.now() - startT) / Math.max(1, duration);
      const p = t >= 1 ? 1 : easing(Math.max(0, Math.min(1, t)));
      this.center = { lon: GISUtils.wrapLongitude(sC.lon + dLon * p), lat: GISUtils.clampLatitude(sC.lat + dLat * p) };
      this.zoom = sZ + (eZ - sZ) * p;
      this.bearing = normalizeAngle(sB + dB * p);
      this.render();
      if (t < 1) {
        this._flyAnim = { raf: requestAnimationFrame(step) };
      } else {
        this._flyAnim = null;
      }
    };
    this._flyAnim = { raf: requestAnimationFrame(step) };
  }

  // ---------------- Interaction ----------------
  setupEvents(){
    window.addEventListener("resize",()=>this.resize());

    // Mouse panning
    this.canvas.addEventListener("mousedown",(e)=>{
      this.stopAnimations();
      this.isDragging = true;
      this.dragStart = { x:e.clientX, y:e.clientY, center:{...this.center} };
      this.resetVelocitySamples();
      this.pushVelocitySample(e.clientX, e.clientY);
    });
    window.addEventListener("mousemove",(e)=>{
      if(!this.isDragging) return;
      const dx = e.clientX - this.dragStart.x, dy = e.clientY - this.dragStart.y;
      const res = GISUtils.getResolution(this.center.lat, this.zoom);
      const lonDx = (dx * res) * 360 / EARTH_CIRCUMFERENCE;
      const latDy = (dy * res) * 360 / EARTH_CIRCUMFERENCE;
      this.center = {
        lon: GISUtils.wrapLongitude(this.dragStart.center.lon - lonDx),
        lat: GISUtils.clampLatitude(this.dragStart.center.lat + latDy)
      };
      this.pushVelocitySample(e.clientX, e.clientY);
      this.render();
    });
    window.addEventListener("mouseup",()=>{
      if (!this.isDragging) return;
      this.isDragging=false;
      const {vx, vy} = this.computeVelocity();
      this.startInertia(vx, vy);
    });

    // Wheel zoom (smooth; anchored at cursor)
    this.canvas.addEventListener("wheel",(e)=>{
      e.preventDefault();
      const dz = (e.deltaY < 0 ? WHEEL_ZOOM_STEP : -WHEEL_ZOOM_STEP);
      this.smoothZoomAt(e.clientX, e.clientY, dz);
    }, { passive:false });

    // Mouse double-click zoom in at cursor
    this.canvas.addEventListener("dblclick",(e)=>{
      e.preventDefault();
      this.animateZoomRotateAbout(e.clientX, e.clientY, this.zoom + 1, this.bearing, TAP_ZOOM_DURATION);
    });

    // Buttons (centered)
    document.getElementById("zoom-in").onclick = () => { this.stopAnimations(); this.setZoom(this.zoom + 1); };
    document.getElementById("zoom-out").onclick = () => { this.stopAnimations(); this.setZoom(this.zoom - 1); };

    // Keyboard
    window.addEventListener("keydown",(e)=>{
      if(e.key==="+"||e.key==="=") { this.stopAnimations(); this.setZoom(this.zoom+1); }
      else if(e.key==="-") { this.stopAnimations(); this.setZoom(this.zoom-1); }
      else if(e.key==="ArrowUp") { this.stopAnimations(); this.center.lat = GISUtils.clampLatitude(this.center.lat + 1); this.render(); }
      else if(e.key==="ArrowDown") { this.stopAnimations(); this.center.lat = GISUtils.clampLatitude(this.center.lat - 1); this.render(); }
      else if(e.key==="ArrowLeft") { this.stopAnimations(); this.center.lon = GISUtils.wrapLongitude(this.center.lon - 1); this.render(); }
      else if(e.key==="ArrowRight") { this.stopAnimations(); this.center.lon = GISUtils.wrapLongitude(this.center.lon + 1); this.render(); }
      else if(e.key.toLowerCase()==="n") { // reset north
        const w = this.canvas.width/this.dpr, h = this.canvas.height/this.dpr;
        this.animateZoomRotateAbout(w/2, h/2, this.zoom, 0, SNAP_DURATION);
      }
    });

    // ---------------- Touch support ----------------
    const onTouchStart = (e)=>{
      if (!e.touches.length) return;
      e.preventDefault();
      this.stopAnimations();

      if (e.touches.length === 1) {
        this.isPinching = false;
        const t = e.touches[0];
        this.isDragging = true;
        this.dragStart = { x:t.clientX, y:t.clientY, center:{...this.center} };
        this.resetVelocitySamples();
        this.pushVelocitySample(t.clientX, t.clientY);

        // Single-tap tracking
        this._singleTouchStart = { x: t.clientX, y: t.clientY, t: performance.now() };
        this._singleTouchMoved = false;
      } else if (e.touches.length === 2) {
        this.isDragging = false;
        this.isPinching = true;
        const t1 = e.touches[0], t2 = e.touches[1];
        this.pinchStartDist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
        this.pinchStartAngle = Math.atan2(t2.clientY - t1.clientY, t2.clientX - t1.clientX);
        this.pinchStartZoom = this.zoom;
        this.pinchStartBearing = this.bearing;
        this.pinchStartTime = performance.now();
        this.pinchLastCenter = {
          x: (t1.clientX + t2.clientX) / 2,
          y: (t1.clientY + t2.clientY) / 2
        };
        // Anchor: lat/lon at pinch centroid
        this._pinchAnchorLL = this.screenToLatLon(this.pinchLastCenter.x, this.pinchLastCenter.y, this.zoom, this.bearing, this.center);
        this._pinchAnchorVec = null; // computed on the fly
        this.resetVelocitySamples();
        this.pushVelocitySample(this.pinchLastCenter.x, this.pinchLastCenter.y);
        this._pinchMoved = false;
      }
    };

    const onTouchMove = (e)=>{
      if (!e.touches.length) return;
      e.preventDefault();

      if (this.isPinching && e.touches.length >= 2) {
        const t1 = e.touches[0], t2 = e.touches[1];
        const dist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
        const angle = Math.atan2(t2.clientY - t1.clientY, t2.clientX - t1.clientX);
        const center = {
          x: (t1.clientX + t2.clientX) / 2,
          y: (t1.clientY + t2.clientY) / 2
        };
        const targetZoom = this.pinchStartZoom + Math.log2(dist / Math.max(1, this.pinchStartDist));
        const deltaAngle = normalizeAngle(angle - this.pinchStartAngle);
        const targetBearing = normalizeAngle(this.pinchStartBearing + deltaAngle);

        // Movement thresholds to detect "tap vs pinch"
        if (Math.abs(Math.log(dist / Math.max(1, this.pinchStartDist))) > Math.log(1 + TWO_FINGER_TAP_MOVE_THRESH/Math.max(1, this.pinchStartDist)) ||
            Math.abs(deltaAngle) > ROTATE_MOVE_THRESH_RAD) {
          this._pinchMoved = true;
        }

        this.applyZoomRotateAbout(center.x, center.y, targetZoom, targetBearing, this._pinchAnchorLL);
        this.pinchLastCenter = center;
        this.pushVelocitySample(center.x, center.y);
        this.render();
      } else if (this.isDragging && e.touches.length === 1) {
        const t = e.touches[0];
        const dx = t.clientX - this.dragStart.x, dy = t.clientY - this.dragStart.y;
        if (this._singleTouchStart) {
          const md = Math.hypot(t.clientX - this._singleTouchStart.x, t.clientY - this._singleTouchStart.y);
          if (md > DOUBLE_TAP_MAX_MOVE) this._singleTouchMoved = true;
        }
        const res = GISUtils.getResolution(this.center.lat, this.zoom);
        const lonDx = (dx * res) * 360 / EARTH_CIRCUMFERENCE;
        const latDy = (dy * res) * 360 / EARTH_CIRCUMFERENCE;
        this.center = {
          lon: GISUtils.wrapLongitude(this.dragStart.center.lon - lonDx),
          lat: GISUtils.clampLatitude(this.dragStart.center.lat + latDy)
        };
        this.pushVelocitySample(t.clientX, t.clientY);
        this.render();
      }
    };

    const onTouchEnd = (e)=>{
      // Two-finger tap to zoom out if quick and no movement
      if (this.isPinching && e.touches.length === 0) {
        const dt = performance.now() - this.pinchStartTime;
        if (!_hasAnyTouch(e) && !_hasAnyMouseDown() && dt <= TWO_FINGER_TAP_MAX_DELAY && !this._pinchMoved) {
          // Zoom out anchored at start centroid
          const ax = this.pinchLastCenter ? this.pinchLastCenter.x : (this.canvas.width/this.dpr)/2;
          const ay = this.pinchLastCenter ? this.pinchLastCenter.y : (this.canvas.height/this.dpr)/2;
          this.animateZoomRotateAbout(ax, ay, this.zoom - 1, this.bearing, TAP_ZOOM_DURATION);
        }
        this.isPinching = false;
      }

      // Single-touch end: double-tap to zoom in
      if (this.isDragging && e.touches.length === 0) {
        const now = performance.now();
        const s = this._singleTouchStart;
        if (s && !this._singleTouchMoved) {
          const dt = now - s.t;
          const distFromLast = Math.hypot(s.x - this._lastTapPos.x, s.y - this._lastTapPos.y);
          if (now - this._lastTapTime <= DOUBLE_TAP_MAX_DELAY && distFromLast <= DOUBLE_TAP_MAX_MOVE) {
            // This is a double-tap
            this.animateZoomRotateAbout(s.x, s.y, this.zoom + 1, this.bearing, TAP_ZOOM_DURATION);
            this._lastTapTime = 0; // reset
          } else {
            // Store as potential first tap
            this._lastTapTime = now;
            this._lastTapPos = { x: s.x, y: s.y };
          }
        }
        this.isDragging=false;
        const {vx, vy} = this.computeVelocity();
        this.startInertia(vx, vy);
      }
    };

    this.canvas.addEventListener("touchstart", onTouchStart, { passive:false });
    this.canvas.addEventListener("touchmove", onTouchMove, { passive:false });
    this.canvas.addEventListener("touchend", onTouchEnd, { passive:false });
    this.canvas.addEventListener("touchcancel", onTouchEnd, { passive:false });

    function _hasAnyTouch(e){ return (e.touches && e.touches.length>0); }
    function _hasAnyMouseDown(){ return false; } // placeholder (not needed here)
  }

  // ---------------- Controls (Snap-back) ----------------
  initControls(){
    const stack = this.container.querySelector(".zoom-controls");
    if (!stack) return;

    // Compass (reset north/up)
    const compass = document.createElement("button");
    compass.className = "zoom-btn";
    compass.title = "Reset North";
    compass.setAttribute("aria-label", "Reset North");
    compass.textContent = "N";
    compass.style.display = "none";
    compass.onclick = ()=>{
      const w = this.canvas.width/this.dpr, h = this.canvas.height/this.dpr;
      this.animateZoomRotateAbout(w/2, h/2, this.zoom, 0, SNAP_DURATION);
    };
    stack.appendChild(compass);
    this._compassBtn = compass;

    // Reset zoom to default
    const resetZoom = document.createElement("button");
    resetZoom.className = "zoom-btn";
    resetZoom.title = "Reset Zoom";
    resetZoom.setAttribute("aria-label", "Reset Zoom");
    resetZoom.textContent = "⤢"; // simple icon
    resetZoom.onclick = ()=>{
      const w = this.canvas.width/this.dpr, h = this.canvas.height/this.dpr;
      // animate zoom about center
      this.animateZoomRotateAbout(w/2, h/2, CONFIG.defaultZoom, this.bearing, SNAP_DURATION);
    };
    stack.appendChild(resetZoom);
    this._resetZoomBtn = resetZoom;
  }

  updateControlsUI(){
    if (this._compassBtn) {
      const visible = Math.abs(this.bearing) > 0.001;
      this._compassBtn.style.display = visible ? "block" : "none";
      // Rotate N to point at north
      this._compassBtn.style.transform = `rotate(${-this.bearing*RAD2DEG}deg)`;
    }
  }
}

// ---------------- Init ----------------
const atlas = new Atlas("map"); // <-- CHANGED: Variable name from 'map' to 'atlas'
</script>
</body>
</html>
