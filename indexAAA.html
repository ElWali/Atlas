<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Atlas.js - Lightweight Mapping Library</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      min-height: 100vh;
      font-family: system-ui, -apple-system, sans-serif;
      background: #f5f5f5;
    }
    #map {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      image-rendering: pixelated;
      cursor: grab;
    }
    #map.dragging {
      cursor: grabbing;
    }
    #controls {
      position: absolute;
      top: 1rem;
      left: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      z-index: 10;
    }
    #controls button {
      font-size: 1.5rem;
      padding: 0.5rem 1rem;
      background: #ffffff;
      border: 1px solid #cccccc;
      border-radius: 0.25rem;
      cursor: pointer;
      transition: background 0.2s, transform 0.1s;
    }
    #controls button:hover {
      background: #e6e6e6;
    }
    #controls button:focus {
      outline: 2px solid #007bff;
      outline-offset: 2px;
    }
    #controls button:active {
      transform: scale(0.95);
    }
    #loading {
      position: absolute;
      top: 1rem;
      right: 1rem;
      background: #ffffff;
      padding: 0.5rem 1rem;
      border: 1px solid #cccccc;
      border-radius: 0.25rem;
      font-size: 0.9rem;
      z-index: 10;
    }
    #loading.hidden {
      display: none;
    }
    #attribution {
      position: absolute;
      bottom: 1rem;
      right: 1rem;
      background: rgba(255, 255, 255, 0.8);
      padding: 0.5rem;
      border-radius: 0.25rem;
      font-size: 0.85rem;
      z-index: 10;
    }
    #attribution a {
      color: #007bff;
      text-decoration: none;
    }
    #attribution a:hover {
      text-decoration: underline;
    }
    #coordinates {
      position: absolute;
      bottom: 1rem;
      left: 1rem;
      background: rgba(255, 255, 255, 0.8);
      padding: 0.5rem;
      border-radius: 0.25rem;
      font-size: 0.85rem;
      z-index: 10;
    }
    @media (max-width: 600px) {
      #controls button {
        font-size: 1rem;
        padding: 0.4rem 0.8rem;
      }
      #loading, #attribution, #coordinates {
        font-size: 0.75rem;
        padding: 0.4rem;
      }
    }
  </style>
</head>
<body>
  <header>
    <div id="controls">
      <button id="zoom-in" aria-label="Zoom In">+</button>
      <button id="zoom-out" aria-label="Zoom Out">‚àí</button>
      <button id="reset" aria-label="Reset Map View">üåê</button>
      <button id="fullscreen" aria-label="Toggle Fullscreen">‚õ∂</button>
    </div>
    <div id="loading">Loading: 0/9</div>
  </header>
  <main>
    <canvas id="map" tabindex="0" aria-label="Interactive Map"></canvas>
  </main>
  <footer>
    <div id="attribution">
      <a href="https://www.openstreetmap.org/copyright" target="_blank">¬© OpenStreetMap contributors</a>
    </div>
    <div id="coordinates">Lat: 0, Lng: 0</div>
  </footer>
  <script>
    class Atlas {
      constructor(canvasId, options = {}) {
        // Validate canvas element
        this.canvas = document.getElementById(canvasId);
        if (!this.canvas) throw new Error(`Canvas element with ID '${canvasId}' not found`);

        // Validate Canvas API support
        this.ctx = this.canvas.getContext('2d');
        if (!this.ctx) throw new Error('Canvas API not supported in this browser');

        // Initialize map state
        this.zoom = options.zoom || 2;
        this.center = options.center || { lat: 0, lng: 0 };
        this.tileSource = options.tileSource || 'https://tile.openstreetmap.org/{z}/{x}/{y}.png';
        this.tileSize = 256;
        this.tileCache = new Map(); // Cache for loaded tiles
        this.loadingEl = document.getElementById('loading');
        this.coordinatesEl = document.getElementById('coordinates');
        this.loadedTiles = 0;
        this.totalTiles = 9; // 3x3 tile grid
        this.isDragging = false;
        this.lastMousePos = null;
        this.pinchDistance = null;
        this.velocity = { x: 0, y: 0 }; // For inertia
        this.isAnimating = false;
        this.plugins = [];
        this.markers = options.markers || []; // Array of { lat, lng, color }
        this.retryAttempts = 3; // Number of retries for failed tiles

        // Initialize canvas and events
        this.init();
      }

      // Initialize canvas and event listeners
      init() {
        this.updateCanvasSize();
        window.addEventListener('resize', () => this.updateCanvasSize());
        this.bindEvents();
        this.draw();
      }

      // Update canvas size on window resize
      updateCanvasSize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.draw();
      }

      // Convert latitude/longitude to tile coordinates (Web Mercator)
      latLngToTile(lat, lng, zoom) {
        const n = Math.pow(2, zoom);
        const x = ((lng + 180) / 360) * n;
        const y = (1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * n;
        return { x: Math.floor(x), y: Math.floor(y) };
      }

      // Convert tile coordinates to canvas pixel position
      tileToCanvas(x, y, centerTile, zoom) {
        const centerX = centerTile.x * this.tileSize;
        const centerY = centerTile.y * this.tileSize;
        const pixelX = (x * this.tileSize - centerX) + this.canvas.width / 2;
        const pixelY = (y * this.tileSize - centerY) + this.canvas.height / 2;
        return { x: pixelX, y: pixelY };
      }

      // Convert canvas pixel to lat/lng
      canvasToLatLng(x, y) {
        const centerTile = this.latLngToTile(this.center.lat, this.center.lng, this.zoom);
        const tileX = (x - this.canvas.width / 2) / this.tileSize + centerTile.x;
        const tileY = (y - this.canvas.height / 2) / this.tileSize + centerTile.y;
        const n = Math.pow(2, this.zoom);
        const lng = (tileX / n) * 360 - 180;
        const latRad = Math.atan(Math.sinh(Math.PI * (1 - 2 * tileY / n)));
        const lat = latRad * 180 / Math.PI;
        return { lat, lng };
      }

      // Draw map tiles and markers
      draw() {
        if (this.isAnimating) return;
        requestAnimationFrame(() => {
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
          this.loadedTiles = 0;
          this.loadingEl.textContent = `Loading: ${this.loadedTiles}/${this.totalTiles}`;
          this.loadingEl.classList.remove('hidden');

          const centerTile = this.latLngToTile(this.center.lat, this.center.lng, this.zoom);
          const tilesToDraw = [];

          // Load 3x3 tile grid around center
          for (let i = -1; i <= 1; i++) {
            for (let j = -1; j <= 1; j++) {
              const tileX = centerTile.x + i;
              const tileY = centerTile.y + j;
              const tileKey = `${this.zoom}/${tileX}/${tileY}`;
              const tileUrl = this.tileSource
                .replace('{z}', this.zoom)
                .replace('{x}', tileX)
                .replace('{y}', tileY);

              tilesToDraw.push({ tileX, tileY, tileKey, tileUrl, attempts: 0 });
            }
          }

          tilesToDraw.forEach(tile => this.loadTile(tile, centerTile));

          // Draw markers
          this.markers.forEach(marker => {
            const tilePos = this.latLngToTile(marker.lat, marker.lng, this.zoom);
            const { x, y } = this.tileToCanvas(tilePos.x, tilePos.y, centerTile, this.zoom);
            this.ctx.fillStyle = marker.color || 'red';
            this.ctx.beginPath();
            this.ctx.arc(x + this.tileSize / 2, y + this.tileSize / 2, 5, 0, 2 * Math.PI);
            this.ctx.fill();
          });

          // Run plugins
          this.plugins.forEach(plugin => plugin.render?.(this));
        });
      }

      // Load a tile with retry logic
      loadTile({ tileX, tileY, tileKey, tileUrl, attempts }, centerTile) {
        if (this.tileCache.has(tileKey)) {
          const img = this.tileCache.get(tileKey);
          const { x, y } = this.tileToCanvas(tileX, tileY, centerTile, this.zoom);
          this.ctx.drawImage(img, x, y, this.tileSize, this.tileSize);
          this.loadedTiles++;
          this.updateLoadingState();
        } else {
          const img = new Image();
          img.src = tileUrl;
          img.onload = () => {
            this.tileCache.set(tileKey, img);
            const { x, y } = this.tileToCanvas(tileX, tileY, centerTile, this.zoom);
            this.ctx.drawImage(img, x, y, this.tileSize, this.tileSize);
            this.loadedTiles++;
            this.updateLoadingState();
          };
          img.onerror = () => {
            if (attempts < this.retryAttempts) {
              setTimeout(() => {
                this.loadTile({ tileX, tileY, tileKey, tileUrl, attempts: attempts + 1 }, centerTile);
              }, 1000 * (attempts + 1));
            } else {
              console.error(`Failed to load tile at ${tileUrl} after ${this.retryAttempts} attempts`);
              this.loadedTiles++;
              this.updateLoadingState();
            }
          };
        }
      }

      // Update loading indicator
      updateLoadingState() {
        this.loadingEl.textContent = `Loading: ${this.loadedTiles}/${this.totalTiles}`;
        if (this.loadedTiles >= this.totalTiles) {
          this.loadingEl.classList.add('hidden');
        }
      }

      // Bind mouse, touch, and keyboard events
      bindEvents() {
        // Zoom controls
        document.getElementById('zoom-in').addEventListener('click', () => this.zoomIn());
        document.getElementById('zoom-out').addEventListener('click', () => this.zoomOut());
        document.getElementById('reset').addEventListener('click', () => this.reset());
        document.getElementById('fullscreen').addEventListener('click', () => this.toggleFullscreen());

        // Mouse events
        this.canvas.addEventListener('mousedown', (e) => this.startDrag(e));
        this.canvas.addEventListener('mousemove', (e) => this.drag(e));
        this.canvas.addEventListener('mouseup', () => this.endDrag());
        this.canvas.addEventListener('mouseleave', () => this.endDrag());
        this.canvas.addEventListener('dblclick', (e) => this.zoomAtPoint(e));
        this.canvas.addEventListener('mousemove', (e) => this.updateCoordinates(e));

        // Touch events
        this.canvas.addEventListener('touchstart', (e) => this.startTouch(e));
        this.canvas.addEventListener('touchmove', (e) => this.touchMove(e));
        this.canvas.addEventListener('touchend', () => this.endTouch());

        // Keyboard support
        this.canvas.addEventListener('keydown', (e) => {
          if (e.key === 'ArrowUp') this.pan(0, 50);
          if (e.key === 'ArrowDown') this.pan(0, -50);
          if (e.key === 'ArrowLeft') this.pan(50, 0);
          if (e.key === 'ArrowRight') this.pan(-50, 0);
          if (e.key === '+') this.zoomIn();
          if (e.key === '-') this.zoomOut();
        });
      }

      // Start mouse drag
      startDrag(e) {
        e.preventDefault();
        this.isDragging = true;
        this.canvas.classList.add('dragging');
        this.lastMousePos = this.getEventPosition(e);
        this.velocity = { x: 0, y: 0 };
      }

      // Handle mouse drag
      drag(e) {
        if (!this.isDragging) return;
        e.preventDefault();
        const pos = this.getEventPosition(e);
        const dx = pos.x - this.lastMousePos.x;
        const dy = pos.y - this.lastMousePos.y;
        this.velocity = { x: dx, y: dy };
        this.pan(dx, dy);
        this.lastMousePos = pos;
      }

      // End mouse drag with inertia
      endDrag() {
        if (!this.isDragging) return;
        this.isDragging = false;
        this.canvas.classList.remove('dragging');
        if (Math.abs(this.velocity.x) > 2 || Math.abs(this.velocity.y) > 2) {
          this.animateInertia();
        }
        this.lastMousePos = null;
      }

      // Start touch interaction
      startTouch(e) {
        e.preventDefault();
        this.isDragging = true;
        this.canvas.classList.add('dragging');
        if (e.touches.length === 1) {
          this.lastMousePos = this.getEventPosition(e);
          this.velocity = { x: 0, y: 0 };
        } else if (e.touches.length === 2) {
          this.pinchDistance = this.getPinchDistance(e);
        }
      }

      // Handle touch move
      touchMove(e) {
        e.preventDefault();
        if (e.touches.length === 1 && this.isDragging) {
          const pos = this.getEventPosition(e);
          const dx = pos.x - this.lastMousePos.x;
          const dy = pos.y - this.lastMousePos.y;
          this.velocity = { x: dx, y: dy };
          this.pan(dx, dy);
          this.lastMousePos = pos;
        } else if (e.touches.length === 2) {
          const newDistance = this.getPinchDistance(e);
          if (this.pinchDistance) {
            const scale = newDistance / this.pinchDistance;
            this.zoomAtPoint(e, scale > 1 ? 1 : -1);
          }
          this.pinchDistance = newDistance;
        }
        this.updateCoordinates(e);
      }

      // End touch interaction
      endTouch() {
        this.isDragging = false;
        this.canvas.classList.remove('dragging');
        this.pinchDistance = null;
        if (Math.abs(this.velocity.x) > 2 || Math.abs(this.velocity.y) > 2) {
          this.animateInertia();
        }
        this.lastMousePos = null;
      }

      // Calculate pinch distance
      getPinchDistance(e) {
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        const dx = touch1.clientX - touch2.clientX;
        const dy = touch1.clientY - touch2.clientY;
        return Math.sqrt(dx * dx + dy * dy);
      }

      // Get mouse or touch position
      getEventPosition(e) {
        if (e.touches && e.touches.length > 0) {
          return { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
        return { x: e.clientX, y: e.clientY };
      }

      // Pan the map by pixel offsets
      pan(dx, dy) {
        const n = Math.pow(2, this.zoom);
        const dLng = (dx / this.tileSize) * (360 / n);
        const latRad = this.center.lat * Math.PI / 180;
        const dLat = (dy / this.tileSize) * (180 / n) * Math.cos(latRad);
        this.center.lng -= dLng;
        this.center.lat -= dLat;
        this.center.lat = Math.max(-85, Math.min(85, this.center.lat));
        this.draw();
      }

      // Zoom at a specific point
      zoomAtPoint(e, delta = 1) {
        const pos = this.getEventPosition(e);
        const { lat, lng } = this.canvasToLatLng(pos.x, pos.y);
        this.zoom = Math.max(0, Math.min(20, this.zoom + delta));
        this.center = { lat, lng }; // Re-center on clicked point
        this.draw();
      }

      // Animate inertia after dragging
      animateInertia() {
        if (this.isAnimating) return;
        this.isAnimating = true;
        const decay = 0.9;
        const minVelocity = 0.1;

        const animate = () => {
          if (Math.abs(this.velocity.x) < minVelocity && Math.abs(this.velocity.y) < minVelocity) {
            this.isAnimating = false;
            this.velocity = { x: 0, y: 0 };
            return;
          }
          this.pan(this.velocity.x, this.velocity.y);
          this.velocity.x *= decay;
          this.velocity.y *= decay;
          requestAnimationFrame(animate);
        };
        requestAnimationFrame(animate);
      }

      // Update coordinate display
      updateCoordinates(e) {
        const pos = this.getEventPosition(e);
        const { lat, lng } = this.canvasToLatLng(pos.x, pos.y);
        this.coordinatesEl.textContent = `Lat: ${lat.toFixed(4)}, Lng: ${lng.toFixed(4)}`;
      }

      // Zoom in
      zoomIn() {
        this.zoom = Math.min(this.zoom + 1, 20);
        this.draw();
      }

      // Zoom out
      zoomOut() {
        this.zoom = Math.max(this.zoom - 1, 0);
        this.draw();
      }

      // Reset map to default view
      reset() {
        this.zoom = 2;
        this.center = { lat: 0, lng: 0 };
        this.draw();
      }

      // Toggle fullscreen
      toggleFullscreen() {
        if (!document.fullscreenElement) {
          this.canvas.requestFullscreen().catch(err => console.error('Fullscreen request failed:', err));
        } else {
          document.exitFullscreen();
        }
      }

      // Add a plugin
      addPlugin(plugin) {
        this.plugins.push(plugin);
        plugin.init?.(this);
        this.draw();
      }

      // Add a marker
      addMarker(lat, lng, color = 'red') {
        this.markers.push({ lat, lng, color });
        this.draw();
      }
    }

    // Example plugin
    const markerPlugin = {
      init(map) {
        this.map = map;
      },
      render(map) {
        // Custom rendering logic can be added here
      }
    };

    // Initialize Atlas.js with sample markers
    const map = new Atlas('map', {
      zoom: 2,
      center: { lat: 0, lng: 0 },
      tileSource: 'https://tile.openstreetmap.org/{z}/{x}/{y}.png',
      markers: [
        { lat: 51.5074, lng: -0.1278, color: 'blue' }, // London
        { lat: 40.7128, lng: -74.0060, color: 'green' } // New York
      ]
    });

    // Add example plugin
    map.addPlugin(markerPlugin);

    // Add a dynamic marker on click
    map.canvas.addEventListener('click', (e) => {
      const pos = map.getEventPosition(e);
      const { lat, lng } = map.canvasToLatLng(pos.x, pos.y);
      map.addMarker(lat, lng, 'purple');
    });
  </script>
</body>
</html>
