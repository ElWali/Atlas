<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="referrer" content="origin">
  <title>Atlas.js - Lightweight JavaScript Mapping Library</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      font-family: sans-serif;
    }
    #map-container {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000; /* default, set per layer in JS */
      touch-action: none;
      cursor: grab;
    }
    #map-container.dragging {
      cursor: grabbing;
    }
    #map {
      width: 100%;
      height: 100%;
      display: block;
    }
    .controls {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      flex-direction: column;
      gap: 5px;
      z-index: 10;
    }
    .control-btn {
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #ccc;
      font-size: 16px;
      padding: 4px 8px;
      cursor: pointer;
      border-radius: 3px;
      user-select: none;
    }
    .control-btn:hover {
      background: rgba(240, 240, 240, 0.9);
    }
    .control-btn:active {
      background: rgba(224, 224, 224, 0.9);
      transform: scale(0.95);
      transition: transform 0.05s;
    }
    .control-btn:focus {
      outline: 2px solid #0078A8;
      outline-offset: 2px;
    }
    .control-btn:disabled {
      background: rgba(245, 245, 245, 0.9);
      color: #aaa;
      cursor: not-allowed;
      transform: none;
      border-color: #ddd;
    }
    #loading {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.9);
      padding: 4px 8px;
      border-radius: 3px;
      font-size: 12px;
      display: none;
      z-index: 10;
    }
    #loading.visible {
      display: block;
    }
    #coords {
      position: absolute;
      bottom: 25px;
      left: 5px;
      background: rgba(255, 255, 255, 0.7);
      font-size: 12px;
      padding: 2px 6px;
      border-radius: 2px;
      z-index: 10;
    }
    #zoom-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.8);
      font-size: 20px;
      padding: 6px 12px;
      border-radius: 4px;
      opacity: 0;
      transition: opacity 0.25s;
      pointer-events: none;
      z-index: 10;
    }
    .scale-bar-container {
      position: absolute;
      bottom: 5px;
      right: 10px;
      text-align: center;
      font-size: 11px;
      color: #fff; /* White text for satellite */
      cursor: pointer;
      z-index: 10;
    }
    .scale-bar {
      height: 4px;
      background: #fff; /* White bar for satellite */
      margin-bottom: 2px;
    }
    #attribution {
      position: absolute;
      bottom: 5px;
      left: 10px;
      background: rgba(0, 0, 0, 0.5); /* Dark background for satellite */
      color: #fff; /* White text for satellite */
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: sans-serif;
      z-index: 10;
    }
    #attribution a {
      text-decoration: none;
      color: #4d90fe; /* Light blue link for satellite */
    }
    #fullscreen {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #ccc;
      padding: 4px 8px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 16px;
      z-index: 10;
    }
    @keyframes zoom-indicator {
      0% {
        transform: scale(0.2);
        opacity: 0.8;
      }
      100% {
        transform: scale(1.2);
        opacity: 0;
      }
    }
  </style>
</head>
<body>
  <div id="map-container">
    <canvas id="map"></canvas>
    <div class="controls">
      <button id="zoom-in" class="control-btn" aria-label="Zoom in">+</button>
      <button id="zoom-out" class="control-btn" aria-label="Zoom out">‚àí</button>
      <button id="layer-toggle" class="control-btn" aria-label="Toggle layer">üåê</button>
    </div>
    <button id="fullscreen" class="control-btn" aria-label="Toggle fullscreen">‚õ∂</button>
    <div id="loading">Loading: <span id="loading-count">0</span></div>
    <div id="zoom-overlay"></div>
    <div id="coords"></div>
    <div class="scale-bar-container">
      <div class="scale-bar"></div>
      <div id="scale-text"></div>
    </div>
    <div id="attribution">
      <!-- Attribution will be updated dynamically -->
    </div>
  </div>
  <script>
    // --- Constants ---
    const EARTH_RADIUS = 6378137;
    const EARTH_CIRCUMFERENCE = 2 * Math.PI * EARTH_RADIUS;
    const MAX_LATITUDE = 85.05112878;
    const MIN_LATITUDE = -85.05112878;
    const TILE_SIZE = 256;
    const TILE_BUFFER = 3;
    const TILE_TTL = 1000 * 60 * 60 * 24; // 24 hours
    const TILE_LOAD_TIMEOUT_MS = 10000; // 10 seconds timeout for tile loading
    const SCALE_BAR_TARGET_PX = 120;
    const INERTIA_DECEL = 0.0025;
    const INERTIA_STOP_SPEED = 0.02;
    const VELOCITY_WINDOW_MS = 120;
    const DOUBLE_TAP_MAX_DELAY = 300;
    const DOUBLE_TAP_MAX_MOVE = 16;
    const TWO_FINGER_TAP_MAX_DELAY = 250;
    const TWO_FINGER_TAP_MOVE_THRESH = 10;
    const ROTATE_MOVE_THRESH_RAD = 0.08;
    const WHEEL_ZOOM_STEP = 0.25;
    const WHEEL_ZOOM_DURATION = 220;
    const TAP_ZOOM_DURATION = 280;
    const SNAP_DURATION = 300;
    const FLYTO_DURATION = 800;

    // --- Layer Configuration ---
    /**
     * Configuration for available map layers.
     * @type {Object.<string, Object>}
     */
    const LAYERS = {
      OSM: {
        name: "OpenStreetMap",
        minZoom: 0,
        maxZoom: 19,
        tileServers: ["https://tile.openstreetmap.org"],
        attribution: '¬© <a href="https://www.openstreetmap.org/copyright" target="_blank" rel="noopener noreferrer">OpenStreetMap contributors</a>',
        background: "#e6e6e6",
        supportsRetina: false, // DISABLED retina for OSM to avoid wasted 404s
        maxCacheSize: 500
      },
      ESRI: {
        name: "Esri Satellite",
        minZoom: 0,
        maxZoom: 19,
        tileServers: ["https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile"],
        attribution: 'Tiles ¬© <a href="https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer" target="_blank" rel="noopener noreferrer">Esri World Imagery</a>',
        background: "#000000",
        supportsRetina: false,
        maxCacheSize: 400
      }
    };

    // --- Default Configuration (used per-instance) ---
    const DEFAULT_CONFIG = {
      defaultLayer: "OSM",
      defaultCenter: { lon: 0, lat: 0 },
      defaultZoom: 3,
      retina: "auto",
      retinaSuffix: "@2x"
    };

    // --- Easing Functions ---
    const EASING = {
      easeInOutCubic: t => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2,
      easeOutCubic: t => 1 - Math.pow(1 - t, 3),
      linear: t => t
    };

    const RAD2DEG = 180 / Math.PI;
    const DEG2RAD = Math.PI / 180;

    // --- Utility Functions ---
    function normalizeAngle(rad) {
      return Math.atan2(Math.sin(rad), Math.cos(rad));
    }
    function shortestAngleDiff(from, to) {
      return normalizeAngle(to - from);
    }
    function wrapDeltaLon(delta) {
      delta = ((delta + 180) % 360 + 360) % 360 - 180;
      return delta;
    }
    function rot(x, y, ang) {
      const c = Math.cos(ang), s = Math.sin(ang);
      return { x: x * c - y * s, y: x * s + y * c };
    }

    // --- GIS Utility Class ---
    class GISUtils {
      static toRadians(d) { return d * Math.PI / 180; }
      static toDegrees(r) { return r * 180 / Math.PI; }
      static wrapLongitude(l) {
        while (l > 180) l -= 360;
        while (l < -180) l += 360;
        return l;
      }
      static clampLatitude(lat) {
        return Math.max(MIN_LATITUDE, Math.min(MAX_LATITUDE, lat));
      }
      static getResolution(lat, z) {
        return (EARTH_CIRCUMFERENCE * Math.cos(this.toRadians(lat))) / (Math.pow(2, z) * TILE_SIZE);
      }
      static formatDistance(m) {
        return m < 1000 ? Math.round(m) + " m" : (m / 1000).toFixed(1) + " km";
      }
      static tileToLonLat(x, y, z) {
        const scale = Math.pow(2, z);
        const lon = x / scale * 360 - 180;
        const n = Math.PI - 2 * Math.PI * y / scale;
        const lat = this.toDegrees(Math.atan(Math.sinh(n)));
        return { lon, lat };
      }
    }

    // --- Main Atlas Class ---
    class Atlas {
      /**
       * Creates a new Atlas map instance.
       * @param {string} id - The ID of the canvas element.
       * @param {Object} [options={}] - Optional configuration overrides.
       */
      constructor(id, options = {}) {
        // Instance-local configuration (no global mutation)
        this.config = { ...DEFAULT_CONFIG, ...options };

        this.canvas = document.getElementById(id);
        this.ctx = this.canvas.getContext("2d");
        this.container = document.getElementById("map-container");

        // Tile cache and loading tracking
        this.tileCache = new Map();
        this.loadingTiles = new Set();

        // Concurrency-limited tile loading queue
        this._queue = [];
        this._inflight = 0;
        this._maxConcurrent = 10; // tweakable

        this.currentLayer = this.config.defaultLayer;
        this.layerConfig = LAYERS[this.currentLayer];
        this.container.style.background = this.layerConfig.background;

        this.center = {
          lon: GISUtils.wrapLongitude(this.config.defaultCenter.lon),
          lat: GISUtils.clampLatitude(this.config.defaultCenter.lat)
        };
        this.zoom = this.config.defaultZoom;
        this.bearing = 0;

        this.isDragging = false;
        this.dragStart = null;
        this.renderScheduled = false;
        this.zoomOverlay = document.getElementById("zoom-overlay");
        this.loadingEl = document.getElementById("loading");
        this.loadingCountEl = document.getElementById("loading-count");
        this.coordsEl = document.getElementById("coords");
        this.scaleBarEl = document.querySelector(".scale-bar");
        this.scaleTextEl = document.getElementById("scale-text");
        this.attributionEl = document.getElementById("attribution");

        this._retinaAvailable = true;

        this._inertiaRAF = null;
        this._moveSamples = [];
        this.isPinching = false;
        this.pinchStartDist = 0;
        this.pinchStartAngle = 0;
        this.pinchStartZoom = this.zoom;
        this.pinchStartBearing = this.bearing;
        this.pinchStartTime = 0;
        this.pinchLastCenter = null;
        this._pinchMoved = false;
        this._pinchAnchorLL = null;
        this._lastTapTime = 0;
        this._lastTapPos = { x: 0, y: 0 };
        this._singleTouchStart = null;
        this._singleTouchMoved = false;
        this._zoomAnim = null;
        this._flyAnim = null;
        this._zoomIndicator = null;

        this._eventListeners = {
          resize: null,
          mousedown: null,
          mousemove: null,
          mouseup: null,
          wheel: null,
          dblclick: null,
          keydown: null,
          touchstart: null,
          touchmove: null,
          touchend: null,
          touchcancel: null,
          fullscreenClick: null,
          layerToggleClick: null
        };

        console.warn(
          `%c[Atlas] You are using map tiles.
%cPlease comply with the respective tile usage policies.
%c- OpenStreetMap: https://operations.osmfoundation.org/policies/tiles/
%c- Esri: https://www.esri.com/en-us/legal/terms/full-master-agreement`,
          "font-weight:bold;color:#e74c3c;",
          "color:#3498db;",
          "color:#2ecc71;",
          "color:#f39c12;"
        );

        this.resize();
        this.setupEvents();
        this.initControls();
        this.updateAttribution();
        this.render();
        this.updateControlsUI();
      }

      // --- Tile coordinate normalization and keys ---
      _normalizeTileXY(x, y, z) {
        const scale = 1 << z;
        const nx = ((Math.floor(x) % scale) + scale) % scale; // wrap x
        const ny = Math.max(0, Math.min(scale - 1, Math.floor(y))); // clamp y
        return { x: nx, y: ny };
      }
      _makeTileKey(layer, z, x, y) {
        const { x: nx, y: ny } = this._normalizeTileXY(x, y, z);
        return `${layer}_${z}/${nx}/${ny}`;
      }

      resize() {
        const w = this.container.offsetWidth, h = this.container.offsetHeight;
        this.dpr = window.devicePixelRatio || 1;
        this.canvas.width = w * this.dpr;
        this.canvas.height = h * this.dpr;
        this.canvas.style.width = w + "px";
        this.canvas.style.height = h + "px";
        this.ctx.setTransform(this.dpr, 0, 0, this.dpr, 0, 0);
        this.render();
      }

      getCurrentLayerConfig() {
        return this.layerConfig;
      }

      switchLayer(layerName) {
        if (LAYERS[layerName] && layerName !== this.currentLayer) {
          this.currentLayer = layerName;
          this.layerConfig = LAYERS[layerName];
          this.container.style.background = this.layerConfig.background;
          this.updateAttribution();
          // Clear cache and in-flight/queued loads
          this.tileCache.clear();
          this.loadingTiles.clear();
          this._queue.length = 0;
          this._inflight = 0;
          // Clamp zoom to layer range
          this.zoom = Math.max(this.layerConfig.minZoom, Math.min(this.layerConfig.maxZoom, this.zoom));
          this.render();
          this.updateControlsUI();
        }
      }

      lonLatToTile(lon, lat, z) {
        lat = GISUtils.clampLatitude(lat);
        lon = GISUtils.wrapLongitude(lon);
        const scale = Math.pow(2, z);
        const x = (lon + 180) / 360 * scale;
        const y = (1 - Math.log(Math.tan(GISUtils.toRadians(lat)) + 1 / Math.cos(GISUtils.toRadians(lat))) / Math.PI) / 2 * scale;
        return { x, y };
      }

      shouldRequestRetina() {
        const mode = this.config.retina;
        const want = (mode === true) || (mode === "auto" && (window.devicePixelRatio || 1) > 1.5);
        return want && this._retinaAvailable;
      }

      /**
       * Gets the URL for a specific tile.
       * @param {number} x - Tile X coordinate (may be non-normalized).
       * @param {number} y - Tile Y coordinate (may be non-normalized).
       * @param {number} z - Tile Z coordinate (zoom level).
       * @returns {string} The URL for the tile.
       */
      getTileUrl(x, y, z) {
        const layerConfig = this.getCurrentLayerConfig();
        const { x: intX, y: intY } = this._normalizeTileXY(x, y, z);
        const baseUrl = layerConfig.tileServers[0];
        let url;
        if (this.currentLayer === "ESRI") {
          // Esri URL format: {baseUrl}/{z}/{y}/{x}
          url = `${baseUrl}/${z}/${intY}/${intX}`;
        } else {
          // OSM URL format: {baseUrl}/{z}/{x}/{y}.png
          url = `${baseUrl}/${z}/${intX}/${intY}.png`;
        }
        // Retina suffix when supported and desired
        if (layerConfig.supportsRetina && this.shouldRequestRetina()) {
          url += this.config.retinaSuffix;
        }
        return url;
      }

      // --- Concurrency-limited tile loading ---
      _enqueueTileLoad(job) {
        // job: { key, url, img, tile }
        this._queue.push(job);
        this._drainQueue();
      }

      _drainQueue() {
        while (this._inflight < this._maxConcurrent && this._queue.length > 0) {
          const job = this._queue.shift();
          this._startTileLoadJob(job);
        }
      }

      _startTileLoadJob(job) {
        this._inflight++;
        const { key, url, img, tile } = job;
        let currentUrl = url;
        let attemptedRetinaFallback = false;
        let finished = false;
        let timeoutId = null;

        const cleanup = () => {
          img.onload = null;
          img.onerror = null;
          if (timeoutId) clearTimeout(timeoutId);
          if (this._inflight > 0) this._inflight--;
          this._drainQueue();
        };

        const onLoad = () => {
          if (finished) return;
          finished = true;
          tile.loaded = true;
          tile.loadedAt = Date.now();
          this.loadingTiles.delete(key);
          this.scheduleRender();
          cleanup();
        };

        const onError = (e) => {
          if (finished) return;
          const suffix = this.config.retinaSuffix;
          // Retina fallback if the URL has suffix and layer supports retina
          if (!attemptedRetinaFallback &&
              currentUrl.includes(suffix)) {
            // Mark retina unavailable for this instance going forward
            this._retinaAvailable = false;
            attemptedRetinaFallback = true;
            currentUrl = currentUrl.replace(suffix, "");
            // Retry with non-retina
            img.src = currentUrl;
            return;
          }
          // Final failure
          finished = true;
          this.loadingTiles.delete(key);
          // Remove from cache so it can be retried later
          if (this.tileCache.has(key)) this.tileCache.delete(key);
          console.warn(`Failed to load tile: ${currentUrl}`, e);
          cleanup();
        };

        img.onload = onLoad;
        img.onerror = onError;

        timeoutId = setTimeout(() => {
          if (finished) return;
          finished = true;
          this.loadingTiles.delete(key);
          if (this.tileCache.has(key)) this.tileCache.delete(key);
          console.warn(`Tile load timeout for: ${currentUrl}`);
          cleanup();
        }, TILE_LOAD_TIMEOUT_MS);

        // Start actual request
        img.src = currentUrl;
      }

      /**
       * Loads a tile image (queued with concurrency limit).
       * @param {string} key - The cache key for the tile.
       * @param {string} url - The URL of the tile image.
       */
      loadTile(key, url) {
        if (this.tileCache.has(key)) return;
        const img = new Image();
        img.crossOrigin = "anonymous";
        const tile = { img, loaded: false, loadedAt: 0, lastUsed: Date.now() };
        this.tileCache.set(key, tile);
        this.loadingTiles.add(key);
        // Queue the load (concurrency-limited)
        this._enqueueTileLoad({ key, url, img, tile });
      }

      /**
       * Reloads a tile, bypassing the cache (TTL refresh).
       * Uses requestIdleCallback for scheduling.
       * @param {string} key - The cache key for the tile.
       * @param {string} url - The URL of the tile image.
       */
      reloadTile(key, url) {
        const existing = this.tileCache.get(key);
        if (!existing) return;
        const token = key + "#r";
        if (this.loadingTiles.has(token)) return;

        const doReload = () => {
          const img = new Image();
          img.crossOrigin = "anonymous";
          this.loadingTiles.add(token);
          let done = false;
          let timeoutId = setTimeout(() => {
            if (done) return;
            done = true;
            this.loadingTiles.delete(token);
          }, TILE_LOAD_TIMEOUT_MS);

          img.onload = () => {
            if (done) return;
            done = true;
            existing.img = img;
            existing.loaded = true;
            existing.loadedAt = Date.now();
            this.loadingTiles.delete(token);
            clearTimeout(timeoutId);
            this.scheduleRender();
          };
          img.onerror = () => {
            if (done) return;
            done = true;
            this.loadingTiles.delete(token);
            clearTimeout(timeoutId);
          };
          // Cache-busting parameter
          img.src = url + (url.includes("?") ? "&" : "?") + "v=" + Date.now();
        };

        if ('requestIdleCallback' in window) {
          requestIdleCallback(doReload);
        } else {
          setTimeout(doReload, 100); // Fallback
        }
      }

      evict() {
        const layerConfig = this.getCurrentLayerConfig();
        if (this.tileCache.size <= (layerConfig.maxCacheSize || 0)) return;
        if ('requestIdleCallback' in window) {
          requestIdleCallback(() => this._performEviction());
        } else {
          setTimeout(() => this._performEviction(), 100);
        }
      }

      _performEviction() {
        const layerConfig = this.getCurrentLayerConfig();
        const maxCacheSize = layerConfig.maxCacheSize || 800;
        if (this.tileCache.size <= maxCacheSize) return;

        const entries = Array.from(this.tileCache.entries());
        entries.sort((a, b) => a[1].lastUsed - b[1].lastUsed);
        const removeCount = this.tileCache.size - maxCacheSize;
        for (let i = 0; i < removeCount; i++) {
          this.tileCache.delete(entries[i][0]);
        }
      }

      scheduleRender() {
        if (this.renderScheduled) return;
        this.renderScheduled = true;
        requestAnimationFrame(() => {
          this.renderScheduled = false;
          this._draw();
        });
      }

      render() {
        this.scheduleRender();
      }

      preloadAdjacentZoomTiles() {
        const layerConfig = this.getCurrentLayerConfig();
        const zInt = Math.floor(this.zoom);
        const nextZoom = Math.min(layerConfig.maxZoom, zInt + 1);
        const prevZoom = Math.max(layerConfig.minZoom, zInt - 1);
        if (Math.abs(this.zoom - zInt) > 0.3) return;

        const ct = this.lonLatToTile(this.center.lon, this.center.lat, zInt);
        const ts = TILE_SIZE;
        const w = this.canvas.width / this.dpr;
        const h = this.canvas.height / this.dpr;
        const viewportTiles = Math.ceil(Math.max(w, h) / ts) + TILE_BUFFER;

        for (let dz of [prevZoom, nextZoom]) {
          if (dz === zInt) continue;
          const scaleDiff = Math.pow(2, Math.abs(dz - zInt));
          const scaleFactor = (dz > zInt) ? scaleDiff : 1 / scaleDiff;

          const startX = Math.floor(ct.x * scaleFactor - viewportTiles / 2);
          const startY = Math.floor(ct.y * scaleFactor - viewportTiles / 2);

          for (let dx = 0; dx < viewportTiles; dx++) {
            for (let dy = 0; dy < viewportTiles; dy++) {
              const X = startX + dx, Y = startY + dy;
              const key = this._makeTileKey(this.currentLayer, dz, X, Y);
              if (!this.tileCache.has(key) && !this.loadingTiles.has(key)) {
                const url = this.getTileUrl(X, Y, dz);
                this.loadTile(key, url);
              }
            }
          }
        }
      }

      _draw() {
        const layerConfig = this.getCurrentLayerConfig();
        const w = this.canvas.width / this.dpr, h = this.canvas.height / this.dpr;

        // Clear with layer background color
        this.ctx.fillStyle = layerConfig.background;
        this.ctx.fillRect(0, 0, w, h);

        const zInt = Math.floor(this.zoom);
        const scaleFactor = Math.pow(2, this.zoom - zInt);
        const ts = TILE_SIZE;
        const ct = this.lonLatToTile(this.center.lon, this.center.lat, zInt);

        const absCos = Math.abs(Math.cos(this.bearing)), absSin = Math.abs(Math.sin(this.bearing));
        const needW = w * absCos + h * absSin;
        const needH = w * absSin + h * absCos;
        const cols = Math.ceil(needW / (ts * scaleFactor)) + TILE_BUFFER;
        const rows = Math.ceil(needH / (ts * scaleFactor)) + TILE_BUFFER;
        const startX = Math.floor(ct.x - cols / 2);
        const startY = Math.floor(ct.y - rows / 2);

        this.ctx.save();
        this.ctx.translate(w / 2, h / 2);
        this.ctx.rotate(this.bearing);
        this.ctx.scale(scaleFactor, scaleFactor);
        this.ctx.imageSmoothingEnabled = false;

        for (let dx = 0; dx < cols; dx++) {
          for (let dy = 0; dy < rows; dy++) {
            const X = startX + dx, Y = startY + dy;
            const key = this._makeTileKey(this.currentLayer, zInt, X, Y);
            const url = this.getTileUrl(X, Y, zInt);
            const trX = (X - ct.x) * ts;
            const trY = (Y - ct.y) * ts;

            const tile = this.tileCache.get(key);
            if (!tile) {
              this.loadTile(key, url);
            } else if (tile.loaded) {
              // Overdraw by 1px to hide seams
              this.ctx.drawImage(tile.img, trX - 0.5, trY - 0.5, ts + 1, ts + 1);
              tile.lastUsed = Date.now();
              // TTL-based refresh
              if (tile.loadedAt && (Date.now() - tile.loadedAt > TILE_TTL)) {
                this.reloadTile(key, url);
              }
            }
          }
        }
        this.ctx.restore();

        this.evict();
        this.preloadAdjacentZoomTiles();

        this.loadingEl.classList.toggle("visible", this.loadingTiles.size > 0);
        this.loadingCountEl.textContent = this.loadingTiles.size;

        this.coordsEl.textContent =
          `${this.center.lat.toFixed(6)}¬∞, ${this.center.lon.toFixed(6)}¬∞ | Z: ${this.zoom.toFixed(2)} | Bearing: ${(this.bearing * RAD2DEG).toFixed(1)}¬∞ | Layer: ${this.currentLayer}`;

        this.updateScaleBar();
        this.updateControlsUI();
      }

      updateScaleBar() {
        if (!this.scaleBarEl || !this.scaleTextEl) return;
        const mPerPx = GISUtils.getResolution(this.center.lat, this.zoom);
        const targetMeters = mPerPx * SCALE_BAR_TARGET_PX;
        const pow = Math.pow(10, Math.floor(Math.log10(targetMeters)));
        const base = targetMeters / pow;
        const niceBase = base >= 5 ? 5 : base >= 2 ? 2 : 1;
        const niceMeters = niceBase * pow;
        const widthPx = Math.max(20, Math.min(300, niceMeters / mPerPx));
        this.scaleBarEl.style.width = `${widthPx}px`;
        if (!this.scaleTextEl.dataset.unit) this.scaleTextEl.dataset.unit = "metric";
        let displayText;
        if (this.scaleTextEl.dataset.unit === "metric") {
          displayText = GISUtils.formatDistance(niceMeters);
        } else {
          const feet = niceMeters * 3.28084;
          displayText = feet < 5280 ? Math.round(feet) + " ft" : (feet / 5280).toFixed(1) + " mi";
        }
        this.scaleTextEl.textContent = displayText;
        if (!this.scaleTextEl._hasClickListener) {
          const clickHandler = () => {
            this.scaleTextEl.dataset.unit = this.scaleTextEl.dataset.unit === "metric" ? "imperial" : "metric";
            this.updateScaleBar();
          };
          this.scaleTextEl.addEventListener("click", clickHandler);
          this.scaleTextEl._hasClickListener = true;
        }
      }

      setZoom(z) {
        const layerConfig = this.getCurrentLayerConfig();
        const nz = Math.max(layerConfig.minZoom, Math.min(layerConfig.maxZoom, z));
        if (nz === this.zoom) return;
        this.zoom = nz;
        this.render();
        this.showZoomOverlay();
        this.updateControlsUI();
      }

      setBearing(rad) {
        const nr = normalizeAngle(rad);
        if (Math.abs(nr - this.bearing) < 1e-6) return;
        this.bearing = nr;
        this.render();
      }

      showZoomOverlay() {
        const overlay = this.zoomOverlay;
        overlay.textContent = `Zoom: ${this.zoom.toFixed(2)}`;
        overlay.style.opacity = 1;
        clearTimeout(this._zTimer);
        this._zTimer = setTimeout(() => overlay.style.opacity = 0, 500);
      }

      stopInertia() {
        if (this._inertiaRAF) cancelAnimationFrame(this._inertiaRAF);
        this._inertiaRAF = null;
      }

      stopAnimations() {
        this.stopInertia();
        if (this._zoomAnim?.raf) cancelAnimationFrame(this._zoomAnim.raf);
        this._zoomAnim = null;
        if (this._flyAnim?.raf) cancelAnimationFrame(this._flyAnim.raf);
        this._flyAnim = null;
      }

      resetVelocitySamples() {
        this._moveSamples = [];
      }

      pushVelocitySample(x, y) {
        const t = performance.now();
        this._moveSamples.push({ t, x, y });
        const cutoff = t - VELOCITY_WINDOW_MS;
        while (this._moveSamples.length && this._moveSamples[0].t < cutoff) {
          this._moveSamples.shift();
        }
      }

      computeVelocity() {
        if (this._moveSamples.length < 2) return { vx: 0, vy: 0 };
        const last = this._moveSamples[this._moveSamples.length - 1];
        let i = this._moveSamples.length - 2;
        while (i > 0 && last.t - this._moveSamples[i].t < VELOCITY_WINDOW_MS * 0.5) i--;
        const ref = this._moveSamples[i];
        const dt = Math.max(1, last.t - ref.t);
        return { vx: (last.x - ref.x) / dt, vy: (last.y - ref.y) / dt };
      }

      startInertia(vx, vy) {
        const speed = Math.hypot(vx, vy);
        if (speed < INERTIA_STOP_SPEED) return;
        this.stopInertia();
        let lastT = performance.now();
        const step = () => {
          const now = performance.now();
          const dt = now - lastT;
          lastT = now;
          const dx = vx * dt, dy = vy * dt;
          const w = this.canvas.width / this.dpr;
          const h = this.canvas.height / this.dpr;
          this.center = this.screenToLatLon(w / 2 - dx, h / 2 - dy);
          const vmag = Math.hypot(vx, vy);
          const newVmag = Math.max(0, vmag - INERTIA_DECEL * dt);
          if (newVmag <= INERTIA_STOP_SPEED) {
            this.render();
            this._inertiaRAF = null;
            return;
          }
          const s = newVmag / (vmag || 1);
          vx *= s;
          vy *= s;
          this.render();
          this._inertiaRAF = requestAnimationFrame(step);
        };
        this._inertiaRAF = requestAnimationFrame(step);
      }

      screenToLatLon(ax, ay, zoom = this.zoom, bearing = this.bearing, center = this.center) {
        const w = this.canvas.width / this.dpr;
        const h = this.canvas.height / this.dpr;
        const zInt = Math.floor(zoom);
        const ts = TILE_SIZE * Math.pow(2, zoom - zInt);
        const ct = this.lonLatToTile(center.lon, center.lat, zInt);
        const anchorVec = { x: ax - w / 2, y: ay - h / 2 };
        const v = rot(anchorVec.x / ts, anchorVec.y / ts, -bearing);
        const tpt = { x: ct.x + v.x, y: ct.y + v.y };
        const ll = GISUtils.tileToLonLat(tpt.x, tpt.y, zInt);
        return {
          lon: GISUtils.wrapLongitude(ll.lon),
          lat: GISUtils.clampLatitude(ll.lat)
        };
      }

      applyZoomRotateAbout(ax, ay, newZoom, newBearing, anchorLL = null) {
        const layerConfig = this.getCurrentLayerConfig();
        newZoom = Math.max(layerConfig.minZoom, Math.min(layerConfig.maxZoom, newZoom));
        const w = this.canvas.width / this.dpr;
        const h = this.canvas.height / this.dpr;
        const anchorVec = { x: ax - w / 2, y: ay - h / 2 };
        const currAnchorLL = anchorLL || this.screenToLatLon(ax, ay, this.zoom, this.bearing, this.center);
        const zInt = Math.floor(newZoom);
        const ts = TILE_SIZE * Math.pow(2, newZoom - zInt);
        const Ptile = this.lonLatToTile(currAnchorLL.lon, currAnchorLL.lat, zInt);
        const v = rot(anchorVec.x / ts, anchorVec.y / ts, -newBearing);
        const ctNew = { x: Ptile.x - v.x, y: Ptile.y - v.y };
        const newCenter = GISUtils.tileToLonLat(ctNew.x, ctNew.y, zInt);
        this.center = {
          lon: GISUtils.wrapLongitude(newCenter.lon),
          lat: GISUtils.clampLatitude(newCenter.lat)
        };
        this.zoom = newZoom;
        this.bearing = normalizeAngle(newBearing);
      }

      showZoomIndicator(x, y) {
        if (this._zoomIndicator) {
          this.container.removeChild(this._zoomIndicator);
        }
        const indicator = document.createElement("div");
        indicator.style.position = "absolute";
        indicator.style.left = (x - 15) + "px";
        indicator.style.top = (y - 15) + "px";
        indicator.style.width = "30px";
        indicator.style.height = "30px";
        indicator.style.borderRadius = "50%";
        indicator.style.border = "2px solid #333";
        indicator.style.opacity = "0.8";
        indicator.style.pointerEvents = "none";
        indicator.style.zIndex = "100";
        indicator.style.animation = "zoom-indicator 0.6s ease-out forwards";
        this.container.appendChild(indicator);
        this._zoomIndicator = indicator;
        setTimeout(() => {
          if (this._zoomIndicator && this._zoomIndicator.parentNode) {
            this.container.removeChild(this._zoomIndicator);
            this._zoomIndicator = null;
          }
        }, 600);
      }

      animateZoomRotateAbout(ax, ay, toZoom, toBearing = this.bearing, duration = WHEEL_ZOOM_DURATION, easing = EASING.easeInOutCubic) {
        this.showZoomIndicator(ax, ay);
        this.stopAnimations();
        const startT = performance.now();
        const sZoom = this.zoom;
        const sBear = this.bearing;
        const deltaBear = shortestAngleDiff(sBear, toBearing);
        const anchorLL = this.screenToLatLon(ax, ay, this.zoom, this.bearing, this.center);
        const step = () => {
          const t = (performance.now() - startT) / Math.max(1, duration);
          const p = t >= 1 ? 1 : easing(Math.max(0, Math.min(1, t)));
          const z = sZoom + (toZoom - sZoom) * p;
          const b = sBear + deltaBear * p;
          this.applyZoomRotateAbout(ax, ay, z, b, anchorLL);
          this.render();
          if (t < 1) {
            this._zoomAnim = { raf: requestAnimationFrame(step) };
          } else {
            this._zoomAnim = null;
            this.updateControlsUI();
          }
        };
        this._zoomAnim = { raf: requestAnimationFrame(step) };
      }

      smoothZoomAt(ax, ay, deltaZ) {
        const layerConfig = this.getCurrentLayerConfig();
        const target = Math.max(layerConfig.minZoom, Math.min(layerConfig.maxZoom, this.zoom + deltaZ));
        this.animateZoomRotateAbout(ax, ay, target, this.bearing, WHEEL_ZOOM_DURATION, EASING.easeInOutCubic);
      }

      flyTo({ center = this.center, zoom = this.zoom, bearing = this.bearing, duration = FLYTO_DURATION, easing = EASING.easeInOutCubic } = {}) {
        const layerConfig = this.getCurrentLayerConfig();
        this.stopAnimations();
        const startT = performance.now();
        const sC = { ...this.center };
        const eC = { ...center };
        const dLon = wrapDeltaLon(eC.lon - sC.lon);
        const dLat = eC.lat - sC.lat;
        const sZ = this.zoom, eZ = Math.max(layerConfig.minZoom, Math.min(layerConfig.maxZoom, zoom));
        const sB = this.bearing, dB = shortestAngleDiff(sB, bearing);
        const step = () => {
          const t = (performance.now() - startT) / Math.max(1, duration);
          const p = t >= 1 ? 1 : easing(Math.max(0, Math.min(1, t)));
          this.center = {
            lon: GISUtils.wrapLongitude(sC.lon + dLon * p),
            lat: GISUtils.clampLatitude(sC.lat + dLat * p)
          };
          this.zoom = sZ + (eZ - sZ) * p;
          this.bearing = normalizeAngle(sB + dB * p);
          this.render();
          if (t < 1) {
            this._flyAnim = { raf: requestAnimationFrame(step) };
          } else {
            this._flyAnim = null;
            this.updateControlsUI();
          }
        };
        this._flyAnim = { raf: requestAnimationFrame(step) };
      }

      // --- Touch Event Handler Helpers ---

      _handleSingleTouchStart(e) {
        const t = e.touches[0];
        this.isDragging = true;
        this.container.classList.add('dragging');
        this.dragStart = { x: t.clientX, y: t.clientY, center: { ...this.center } };
        this.resetVelocitySamples();
        this.pushVelocitySample(t.clientX, t.clientY);
        this._singleTouchStart = { x: t.clientX, y: t.clientY, t: performance.now() };
        this._singleTouchMoved = false;
      }

      _handlePinchStart(e) {
        const t1 = e.touches[0], t2 = e.touches[1];
        this.isDragging = false;
        this.isPinching = true;
        this.pinchStartDist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
        this.pinchStartAngle = Math.atan2(t2.clientY - t1.clientY, t2.clientX - t1.clientX);
        this.pinchStartZoom = this.zoom;
        this.pinchStartBearing = this.bearing;
        this.pinchStartTime = performance.now();
        this.pinchLastCenter = { x: (t1.clientX + t2.clientX) / 2, y: (t1.clientY + t2.clientY) / 2 };
        this._pinchAnchorLL = this.screenToLatLon(this.pinchLastCenter.x, this.pinchLastCenter.y, this.zoom, this.bearing, this.center);
        this.resetVelocitySamples();
        this.pushVelocitySample(this.pinchLastCenter.x, this.pinchLastCenter.y);
        this._pinchMoved = false;
      }

      _handleSingleTouchMove(e) {
        const t = e.touches[0];
        if (this._singleTouchStart) {
          const md = Math.hypot(t.clientX - this._singleTouchStart.x, t.clientY - this._singleTouchStart.y);
          if (md > DOUBLE_TAP_MAX_MOVE) this._singleTouchMoved = true;
        }
        const dx = t.clientX - this.dragStart.x;
        const dy = t.clientY - this.dragStart.y;
        const w = this.canvas.width / this.dpr;
        const h = this.canvas.height / this.dpr;
        this.center = this.screenToLatLon(w / 2 - dx, h / 2 - dy, this.zoom, this.bearing, this.dragStart.center);
        this.pushVelocitySample(t.clientX, t.clientY);
        this.render();
      }

      _handlePinchMove(e) {
        const t1 = e.touches[0], t2 = e.touches[1];
        const dist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
        const angle = Math.atan2(t2.clientY - t1.clientY, t2.clientX - t1.clientX);
        const center = { x: (t1.clientX + t2.clientX) / 2, y: (t1.clientY + t2.clientY) / 2 };
        const targetZoom = this.pinchStartZoom + Math.log2(dist / Math.max(1, this.pinchStartDist));
        const deltaAngle = normalizeAngle(angle - this.pinchStartAngle);
        const targetBearing = normalizeAngle(this.pinchStartBearing + deltaAngle);
        if (
          Math.abs(Math.log(dist / Math.max(1, this.pinchStartDist))) >
            Math.log(1 + TWO_FINGER_TAP_MOVE_THRESH / Math.max(1, this.pinchStartDist)) ||
          Math.abs(deltaAngle) > ROTATE_MOVE_THRESH_RAD
        ) {
          this._pinchMoved = true;
        }
        this.applyZoomRotateAbout(center.x, center.y, targetZoom, targetBearing, this._pinchAnchorLL);
        this.pinchLastCenter = center;
        this.pushVelocitySample(center.x, center.y);
        this.render();
      }

      _handleTouchEndSingle(e) {
        const now = performance.now();
        const s = this._singleTouchStart;
        if (s && !this._singleTouchMoved) {
          const dt = now - s.t;
          const distFromLast = Math.hypot(s.x - this._lastTapPos.x, s.y - this._lastTapPos.y);
          if (now - this._lastTapTime <= DOUBLE_TAP_MAX_DELAY && distFromLast <= DOUBLE_TAP_MAX_MOVE) {
            this.animateZoomRotateAbout(s.x, s.y, this.zoom + 1, this.bearing, TAP_ZOOM_DURATION);
            this._lastTapTime = 0;
          } else {
            this._lastTapTime = now;
            this._lastTapPos = { x: s.x, y: s.y };
          }
        }
        this.isDragging = false;
        this.container.classList.remove('dragging');
        const { vx, vy } = this.computeVelocity();
        this.startInertia(vx, vy);
      }

      _handleTouchEndPinch(e) {
        const dt = performance.now() - this.pinchStartTime;
        if (dt <= TWO_FINGER_TAP_MAX_DELAY && !this._pinchMoved) {
          const ax = this.pinchLastCenter ? this.pinchLastCenter.x : (this.canvas.width / this.dpr) / 2;
          const ay = this.pinchLastCenter ? this.pinchLastCenter.y : (this.canvas.height / this.dpr) / 2;
          this.animateZoomRotateAbout(ax, ay, this.zoom - 1, this.bearing, TAP_ZOOM_DURATION);
        }
        this.isPinching = false;
      }

      // --- Events and controls ---

      setupEvents() {
        this._eventListeners.resize = () => this.resize();
        window.addEventListener("resize", this._eventListeners.resize);

        this._eventListeners.mousedown = (e) => {
          this.stopAnimations();
          this.isDragging = true;
          this.container.classList.add('dragging');
          this.dragStart = { x: e.clientX, y: e.clientY, center: { ...this.center } };
          this.resetVelocitySamples();
          this.pushVelocitySample(e.clientX, e.clientY);
        };
        this.canvas.addEventListener("mousedown", this._eventListeners.mousedown);

        this._eventListeners.mousemove = (e) => {
          if (!this.isDragging) return;
          const dx = e.clientX - this.dragStart.x;
          const dy = e.clientY - this.dragStart.y;
          const w = this.canvas.width / this.dpr;
          const h = this.canvas.height / this.dpr;
          this.center = this.screenToLatLon(w / 2 - dx, h / 2 - dy, this.zoom, this.bearing, this.dragStart.center);
          this.pushVelocitySample(e.clientX, e.clientY);
          this.render();
        };
        window.addEventListener("mousemove", this._eventListeners.mousemove);

        this._eventListeners.mouseup = () => {
          if (!this.isDragging) return;
          this.isDragging = false;
          this.container.classList.remove('dragging');
          const { vx, vy } = this.computeVelocity();
          this.startInertia(vx, vy);
        };
        window.addEventListener("mouseup", this._eventListeners.mouseup);

        this._eventListeners.wheel = (e) => {
          e.preventDefault();
          const dz = (e.deltaY < 0 ? WHEEL_ZOOM_STEP : -WHEEL_ZOOM_STEP);
          this.smoothZoomAt(e.clientX, e.clientY, dz);
        };
        this.canvas.addEventListener("wheel", this._eventListeners.wheel, { passive: false });

        this._eventListeners.dblclick = (e) => {
          e.preventDefault();
          this.animateZoomRotateAbout(e.clientX, e.clientY, this.zoom + 1, this.bearing, TAP_ZOOM_DURATION);
        };
        this.canvas.addEventListener("dblclick", this._eventListeners.dblclick);

        const zoomInHandler = () => {
          this.stopAnimations();
          this.setZoom(this.zoom + 1);
        };
        const zoomOutHandler = () => {
          this.stopAnimations();
          this.setZoom(this.zoom - 1);
        };
        document.getElementById("zoom-in").addEventListener("click", zoomInHandler);
        document.getElementById("zoom-out").addEventListener("click", zoomOutHandler);

        this._eventListeners.layerToggleClick = () => {
          const nextLayer = this.currentLayer === "OSM" ? "ESRI" : "OSM";
          this.switchLayer(nextLayer);
        };
        document.getElementById("layer-toggle").addEventListener("click", this._eventListeners.layerToggleClick);

        this._eventListeners.keydown = (e) => {
          if (e.key === "+" || e.key === "=") {
            this.stopAnimations();
            this.setZoom(this.zoom + 1);
          } else if (e.key === "-") {
            this.stopAnimations();
            this.setZoom(this.zoom - 1);
          } else if (e.key === "ArrowUp") {
            this.stopAnimations();
            this.center.lat = GISUtils.clampLatitude(this.center.lat + 1);
            this.render();
          } else if (e.key === "ArrowDown") {
            this.stopAnimations();
            this.center.lat = GISUtils.clampLatitude(this.center.lat - 1);
            this.render();
          } else if (e.key === "ArrowLeft") {
            this.stopAnimations();
            this.center.lon = GISUtils.wrapLongitude(this.center.lon - 1);
            this.render();
          } else if (e.key === "ArrowRight") {
            this.stopAnimations();
            this.center.lon = GISUtils.wrapLongitude(this.center.lon + 1);
            this.render();
          } else if (e.key.toLowerCase() === "n") {
            const w = this.canvas.width / this.dpr, h = this.canvas.height / this.dpr;
            this.animateZoomRotateAbout(w / 2, h / 2, this.zoom, 0, SNAP_DURATION);
          } else if (e.key === "r") {
            this.setBearing(this.bearing + DEG2RAD * 15);
          } else if (e.key === "l") {
            this.setBearing(this.bearing - DEG2RAD * 15);
          } else if (e.key === "s") {
            const nextLayer = this.currentLayer === "OSM" ? "ESRI" : "OSM";
            this.switchLayer(nextLayer);
          }
        };
        window.addEventListener("keydown", this._eventListeners.keydown);

        // Touch events
        const onTouchStart = (e) => {
          if (!e.touches.length) return;
          e.preventDefault();
          this.stopAnimations();

          if (e.touches.length === 1) {
            this._handleSingleTouchStart(e);
          } else if (e.touches.length === 2) {
            this._handlePinchStart(e);
          }
        };

        const onTouchMove = (e) => {
          if (!e.touches.length) return;
          e.preventDefault();
          if (this.isPinching && e.touches.length >= 2) {
            this._handlePinchMove(e);
          } else if (this.isDragging && e.touches.length === 1) {
            this._handleSingleTouchMove(e);
          }
        };

        const onTouchEnd = (e) => {
          if (this.isPinching) {
            this._handleTouchEndPinch(e);
          }
          if (this.isDragging) {
            this._handleTouchEndSingle(e);
          }
        };

        this._eventListeners.touchstart = onTouchStart;
        this._eventListeners.touchmove = onTouchMove;
        this._eventListeners.touchend = onTouchEnd;
        this._eventListeners.touchcancel = onTouchEnd;
        this.canvas.addEventListener("touchstart", this._eventListeners.touchstart, { passive: false });
        this.canvas.addEventListener("touchmove", this._eventListeners.touchmove, { passive: false });
        this.canvas.addEventListener("touchend", this._eventListeners.touchend, { passive: false });
        this.canvas.addEventListener("touchcancel", this._eventListeners.touchcancel, { passive: false });

        this._eventListeners.fullscreenClick = () => {
          if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch(err => {
              console.warn(`Error attempting to enable fullscreen: ${err.message}`);
            });
          } else {
            document.exitFullscreen().catch(err => {
              console.warn(`Error attempting to exit fullscreen: ${err.message}`);
            });
          }
        };
        document.getElementById("fullscreen").addEventListener("click", this._eventListeners.fullscreenClick);
      }

      initControls() {
        const stack = this.container.querySelector(".controls");
        if (!stack) return;
        const existingCompass = stack.querySelector("#compass");
        const existingResetZoom = stack.querySelector("#reset-zoom");
        if (existingCompass) {
          stack.removeChild(existingCompass);
        }
        if (existingResetZoom) {
          stack.removeChild(existingResetZoom);
        }

        const compass = document.createElement("button");
        compass.id = "compass";
        compass.className = "control-btn";
        compass.title = "Reset North";
        compass.setAttribute("aria-label", "Reset North");
        compass.textContent = "N";
        compass.style.display = "none";
        compass.onclick = () => {
          const w = this.canvas.width / this.dpr, h = this.canvas.height / this.dpr;
          this.animateZoomRotateAbout(w / 2, h / 2, this.zoom, 0, SNAP_DURATION);
        };
        compass.onmouseenter = () => { compass.style.background = "rgba(240, 240, 240, 0.9)"; };
        compass.onmouseleave = () => { compass.style.background = "rgba(255, 255, 255, 0.9)"; };
        compass.onmousedown = () => { compass.style.transform = "scale(0.95) rotate(" + (-this.bearing * RAD2DEG) + "deg)"; };
        compass.onmouseup = () => { compass.style.transform = "rotate(" + (-this.bearing * RAD2DEG) + "deg)"; };
        stack.appendChild(compass);
        this._compassBtn = compass;

        const resetZoom = document.createElement("button");
        resetZoom.id = "reset-zoom";
        resetZoom.className = "control-btn";
        resetZoom.title = "Reset Zoom";
        resetZoom.setAttribute("aria-label", "Reset Zoom");
        resetZoom.textContent = "‚§¢";
        resetZoom.onclick = () => {
          const w = this.canvas.width / this.dpr, h = this.canvas.height / this.dpr;
          this.animateZoomRotateAbout(w / 2, h / 2, this.config.defaultZoom, this.bearing, SNAP_DURATION);
        };
        resetZoom.onmouseenter = () => { resetZoom.style.background = "rgba(240, 240, 240, 0.9)"; };
        resetZoom.onmouseleave = () => { resetZoom.style.background = "rgba(255, 255, 255, 0.9)"; };
        resetZoom.onmousedown = () => { resetZoom.style.transform = "scale(0.95)"; };
        resetZoom.onmouseup = () => { resetZoom.style.transform = "scale(1)"; };
        stack.appendChild(resetZoom);
        this._resetZoomBtn = resetZoom;
      }

      updateControlsUI() {
        const zoomInBtn = document.getElementById("zoom-in");
        const zoomOutBtn = document.getElementById("zoom-out");
        const layerConfig = this.getCurrentLayerConfig();
        if (zoomInBtn) {
          zoomInBtn.disabled = this.zoom >= layerConfig.maxZoom;
        }
        if (zoomOutBtn) {
          zoomOutBtn.disabled = this.zoom <= layerConfig.minZoom;
        }
        if (this._compassBtn) {
          const visible = Math.abs(this.bearing) > 0.001;
          this._compassBtn.style.display = visible ? "block" : "none";
          this._compassBtn.style.transition = "transform 0.3s ease-out";
          this._compassBtn.style.transform = `rotate(${-this.bearing * RAD2DEG}deg)`;
        }
      }

      updateAttribution() {
        if (this.attributionEl) {
          this.attributionEl.innerHTML = this.layerConfig.attribution;
        }
      }

      destroy() {
        this.stopAnimations();
        this.stopInertia();
        if (this._eventListeners.resize) window.removeEventListener("resize", this._eventListeners.resize);
        if (this._eventListeners.mousedown) this.canvas.removeEventListener("mousedown", this._eventListeners.mousedown);
        if (this._eventListeners.mousemove) window.removeEventListener("mousemove", this._eventListeners.mousemove);
        if (this._eventListeners.mouseup) window.removeEventListener("mouseup", this._eventListeners.mouseup);
        if (this._eventListeners.wheel) this.canvas.removeEventListener("wheel", this._eventListeners.wheel);
        if (this._eventListeners.dblclick) this.canvas.removeEventListener("dblclick", this._eventListeners.dblclick);
        if (this._eventListeners.keydown) window.removeEventListener("keydown", this._eventListeners.keydown);
        if (this._eventListeners.touchstart) this.canvas.removeEventListener("touchstart", this._eventListeners.touchstart);
        if (this._eventListeners.touchmove) this.canvas.removeEventListener("touchmove", this._eventListeners.touchmove);
        if (this._eventListeners.touchend) this.canvas.removeEventListener("touchend", this._eventListeners.touchend);
        if (this._eventListeners.touchcancel) this.canvas.removeEventListener("touchcancel", this._eventListeners.touchcancel);
        if (this._eventListeners.fullscreenClick) document.getElementById("fullscreen").removeEventListener("click", this._eventListeners.fullscreenClick);
        if (this._eventListeners.layerToggleClick) document.getElementById("layer-toggle").removeEventListener("click", this._eventListeners.layerToggleClick);
        this.tileCache.clear();
        this.loadingTiles.clear();
        this._queue.length = 0;
        this._inflight = 0;
        console.log("Atlas instance destroyed.");
      }
    }

    let atlasInstance = null;

    /**
     * Initializes the Atlas map instance, attempting geolocation first.
     */
    function initializeAtlas() {
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(pos => {
          atlasInstance = new Atlas("map");
          const lat = pos.coords.latitude;
          const lon = pos.coords.longitude;
          atlasInstance.flyTo({ center: { lat, lon }, zoom: 10 });
        }, (error) => {
          console.warn("Geolocation failed:", error.message);
          alert("Could not determine your location. Loading map with default view.");
          atlasInstance = new Atlas("map");
        });
      } else {
        console.warn("Geolocation is not supported by this browser.");
        alert("Geolocation is not supported by your browser. Loading map with default view.");
        atlasInstance = new Atlas("map");
      }
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeAtlas);
    } else {
      initializeAtlas();
    }
  </script>
</body>
</html>
