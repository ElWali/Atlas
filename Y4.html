<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Atlas.js - JavaScript Mapping Library</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }
    #map-container {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      touch-action: none;
      cursor: grab;
    }
    #map-container.dragging {
      cursor: grabbing;
    }
    #map {
      width: 100%;
      height: 100%;
      display: block;
    }
    .atlas-control-container {
      position: absolute;
      z-index: 1000;
      pointer-events: none;
    }
    .atlas-control-container > * {
      pointer-events: auto;
    }
    .atlas-control-top-left { top: 10px; left: 10px; }
    .atlas-control-top-right { top: 10px; right: 10px; }
    .atlas-control-bottom-left { bottom: 10px; left: 10px; }
    .atlas-control-bottom-right { bottom: 10px; right: 10px; }
    .atlas-control-vertical {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    .control-btn {
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #ccc;
      font-size: 16px;
      padding: 4px 8px;
      cursor: pointer;
      border-radius: 4px;
      user-select: none;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      transition: all 0.15s ease;
      min-width: 30px;
      text-align: center;
    }
    .control-btn:hover {
      background: rgba(240, 240, 240, 0.95);
      box-shadow: 0 2px 5px rgba(0,0,0,0.15);
    }
    .control-btn:active {
      background: rgba(224, 224, 224, 0.95);
      transform: scale(0.98);
    }
    .control-btn:disabled {
      background: rgba(245, 245, 245, 0.9);
      color: #aaa;
      cursor: not-allowed;
      transform: none;
      border-color: #ddd;
    }
    #loading {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.9);
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      display: none;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    #loading.visible {
      display: block;
    }
    #coords {
      position: absolute;
      bottom: 25px;
      left: 5px;
      background: rgba(255, 255, 255, 0.7);
      font-size: 12px;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: monospace;
    }
    #zoom-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.9);
      font-size: 20px;
      padding: 6px 12px;
      border-radius: 6px;
      opacity: 0;
      transition: opacity 0.25s ease-in-out;
      pointer-events: none;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      font-weight: bold;
      z-index: 1000;
    }
    .scale-bar-container {
      text-align: center;
      font-size: 11px;
      color: #fff;
      cursor: pointer;
      background: rgba(0,0,0,0.5);
      padding: 2px 4px;
      border-radius: 3px;
    }
    .scale-bar {
      height: 4px;
      background: #fff;
      margin-bottom: 2px;
      border-radius: 2px;
    }
    #attribution {
      position: absolute;
      bottom: 5px;
      left: 10px;
      background: rgba(0, 0, 0, 0.6);
      color: #fff;
      font-size: 11px;
      padding: 3px 6px;
      border-radius: 3px;
      max-width: 50%;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    #attribution a {
      text-decoration: none;
      color: #4d90fe;
      font-weight: bold;
    }
    #attribution a:hover {
      text-decoration: underline;
    }
    .atlas-marker {
      position: absolute;
      width: 24px;
      height: 36px;
      cursor: pointer;
      z-index: 1000;
      transition: transform 0.2s cubic-bezier(0.2, 0.8, 0.4, 1.0);
    }
    .atlas-marker-icon {
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 24px;
      height: 36px;
      filter: drop-shadow(0 1px 2px rgba(0,0,0,0.3));
    }
    .atlas-marker-shadow {
      position: absolute;
      bottom: 0;
      left: 50%;
      width: 24px;
      height: 12px;
      transform: translateX(-50%);
      border-radius: 50%;
      background: radial-gradient(ellipse at center, rgba(0,0,0,0.3) 0%, rgba(0,0,0,0) 70%);
      filter: blur(1px);
    }
    .atlas-marker.hover {
      transform: translate(-50%, -100%) scale(1.1) !important;
    }
    .atlas-popup {
      position: absolute;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 6px;
      box-shadow: 0 3px 15px rgba(0,0,0,0.2);
      padding: 12px;
      font-size: 14px;
      line-height: 1.4;
      z-index: 1001;
      opacity: 0;
      transition: opacity 0.2s ease-in-out;
      max-width: 300px;
      min-width: 50px;
    }
    .atlas-popup.open {
      opacity: 1;
    }
    .popup-close {
      position: absolute;
      top: 8px;
      right: 8px;
      background: none;
      border: none;
      font-size: 18px;
      cursor: pointer;
      width: 24px;
      height: 24px;
      line-height: 24px;
      text-align: center;
      color: #666;
      border-radius: 50%;
    }
    .popup-close:hover {
      background: #f0f0f0;
    }
    .popup-tip {
      position: absolute;
      width: 0;
      height: 0;
      border: 8px solid transparent;
    }
    .tip-bottom {
      top: -16px;
      left: 50%;
      margin-left: -8px;
      border-top-color: #ddd;
      border-bottom: none;
    }
    .tip-bottom::after {
      content: '';
      position: absolute;
      top: 1px;
      left: -8px;
      border: 8px solid transparent;
      border-top-color: white;
    }
    .tip-top {
      bottom: -16px;
      left: 50%;
      margin-left: -8px;
      border-bottom-color: #ddd;
      border-top: none;
    }
    .tip-top::after {
      content: '';
      position: absolute;
      bottom: 1px;
      left: -8px;
      border: 8px solid transparent;
      border-bottom-color: white;
    }
    .tip-left {
      top: 50%;
      right: -16px;
      margin-top: -8px;
      border-left-color: #ddd;
      border-right: none;
    }
    .tip-left::after {
      content: '';
      position: absolute;
      top: -8px;
      right: 1px;
      border: 8px solid transparent;
      border-left-color: white;
    }
    .tip-right {
      top: 50%;
      left: -16px;
      margin-top: -8px;
      border-right-color: #ddd;
      border-left: none;
    }
    .tip-right::after {
      content: '';
      position: absolute;
      top: -8px;
      left: 1px;
      border: 8px solid transparent;
      border-right-color: white;
    }
  </style>
</head>
<body>
  <div id="map-container">
    <canvas id="map"></canvas>
    <div id="loading">Loading: <span id="loading-count">0</span></div>
    <div id="zoom-overlay"></div>
    <div id="coords"></div>
    <div id="attribution"></div>
  </div>
  <script>
    const EARTH_RADIUS = 6378137;
    const EARTH_CIRCUMFERENCE = 2 * Math.PI * EARTH_RADIUS;
    const MAX_LATITUDE = 85.05112878;
    const MIN_LATITUDE = -85.05112878;
    const TILE_SIZE = 256;
    const TILE_BUFFER = 3;
    const TILE_TTL = 86400000;
    const TILE_LOAD_TIMEOUT_MS = 10000;
    const INERTIA_DECEL = 0.0025;
    const INERTIA_STOP_SPEED = 0.02;
    const VELOCITY_WINDOW_MS = 120;
    const TWO_FINGER_TAP_MAX_DELAY = 250;
    const TWO_FINGER_TAP_MOVE_THRESH = 10;
    const ROTATE_MOVE_THRESH_RAD = 0.08;
    const WHEEL_ZOOM_STEP = 0.25;
    const WHEEL_ZOOM_DURATION = 220;
    const TAP_ZOOM_DURATION = 280;
    const SNAP_DURATION = 300;
    const FLYTO_DURATION = 800;
    
    // Enhanced configuration with instance-level support
    const DEFAULT_CONFIG = {
      defaultLayer: "OSM",
      defaultCenter: { lon: 0, lat: 0 },
      defaultZoom: 3,
      retina: "auto",
      retinaSuffix: "@2x"
    };
    
    const EASING = {
      easeInOutCubic: t => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2
    };
    const RAD2DEG = 180 / Math.PI;
    const DEG2RAD = Math.PI / 180;
    
    /**
     * Normalizes an angle to the range [-π, π]
     * @param {number} rad - Angle in radians
     * @returns {number} Normalized angle in radians
     */
    function normalizeAngle(rad) {
      return Math.atan2(Math.sin(rad), Math.cos(rad));
    }
    
    /**
     * Wraps longitude difference to [-180, 180] range
     * @param {number} delta - Longitude difference in degrees
     * @returns {number} Wrapped longitude difference
     */
    function wrapDeltaLon(delta) {
      return ((delta + 180) % 360 + 360) % 360 - 180;
    }
    
    /**
     * Rotates a point around the origin
     * @param {number} x - X coordinate
     * @param {number} y - Y coordinate
     * @param {number} ang - Rotation angle in radians
     * @returns {Object} Rotated point {x, y}
     */
    function rot(x, y, ang) {
      const c = Math.cos(ang), s = Math.sin(ang);
      return { x: x * c - y * s, y: x * s + y * c };
    }
    
    /**
     * Base class for map projections
     */
    class Projection {
      project(latlng) { throw new Error('project() must be implemented'); }
      unproject(point) { throw new Error('unproject() must be implemented'); }
    }
    
    /**
     * Web Mercator projection implementation
     */
    class WebMercatorProjection extends Projection {
      project(latlng) {
        // Validate input
        if (typeof latlng.lat !== 'number' || typeof latlng.lon !== 'number') {
          throw new Error('LatLng must contain numeric lat and lon properties');
        }
        
        const lat = Math.max(Math.min(MAX_LATITUDE, latlng.lat), -MAX_LATITUDE);
        const sin = Math.sin(lat * DEG2RAD);
        return {
          x: EARTH_RADIUS * latlng.lon * DEG2RAD,
          y: EARTH_RADIUS * Math.log((1 + sin) / (1 - sin)) / 2
        };
      }
      
      unproject(point) {
        // Validate input
        if (typeof point.x !== 'number' || typeof point.y !== 'number') {
          throw new Error('Point must contain numeric x and y properties');
        }
        
        return {
          lon: (point.x / EARTH_RADIUS) * RAD2DEG,
          lat: (2 * Math.atan(Math.exp(point.y / EARTH_RADIUS)) - Math.PI / 2) * RAD2DEG
        };
      }
      
      latLngToTile(latlng, zoom) {
        // Validate zoom level
        if (typeof zoom !== 'number' || zoom < 0) {
          throw new Error('Zoom must be a non-negative number');
        }
        
        const scale = Math.pow(2, zoom);
        const projected = this.project(latlng);
        return {
          x: (projected.x + Math.PI * EARTH_RADIUS) / (2 * Math.PI * EARTH_RADIUS) * scale,
          y: (Math.PI * EARTH_RADIUS - projected.y) / (2 * Math.PI * EARTH_RADIUS) * scale
        };
      }
      
      tileToLatLng(x, y, zoom) {
        // Validate parameters
        if (typeof x !== 'number' || typeof y !== 'number' || typeof zoom !== 'number' || zoom < 0) {
          throw new Error('x, y, and zoom must be numbers, zoom must be non-negative');
        }
        
        const scale = Math.pow(2, zoom);
        const projected = {
          x: x / scale * 2 * Math.PI * EARTH_RADIUS - Math.PI * EARTH_RADIUS,
          y: Math.PI * EARTH_RADIUS - y / scale * 2 * Math.PI * EARTH_RADIUS
        };
        return this.unproject(projected);
      }
    }
    
    const DEFAULT_PROJECTION = new WebMercatorProjection();
    
    /**
     * GIS utility functions
     */
    class GISUtils {
      static toRadians(d) { 
        if (typeof d !== 'number') throw new Error('Input must be a number');
        return d * DEG2RAD; 
      }
      
      static toDegrees(r) { 
        if (typeof r !== 'number') throw new Error('Input must be a number');
        return r * RAD2DEG; 
      }
      
      static wrapLongitude(l) {
        if (typeof l !== 'number') throw new Error('Input must be a number');
        while (l > 180) l -= 360;
        while (l < -180) l += 360;
        return l;
      }
      
      static clampLatitude(lat) {
        if (typeof lat !== 'number') throw new Error('Input must be a number');
        return Math.max(MIN_LATITUDE, Math.min(MAX_LATITUDE, lat));
      }
      
      static getResolution(lat, z) {
        if (typeof lat !== 'number' || typeof z !== 'number') {
          throw new Error('Latitude and zoom must be numbers');
        }
        return (EARTH_CIRCUMFERENCE * Math.cos(this.toRadians(lat))) / (Math.pow(2, z) * TILE_SIZE);
      }
      
      static formatDistance(m) {
        if (typeof m !== 'number') throw new Error('Input must be a number');
        return m < 1000 ? Math.round(m) + " m" : (m / 1000).toFixed(1) + " km";
      }
      
      static tileToLonLat(x, y, z) {
        return DEFAULT_PROJECTION.tileToLatLng(x, y, z);
      }
    }
    
    /**
     * Base class for map layers
     */
    class Layer {
      constructor(options = {}) {
        this.options = options;
        this._map = null;
        this._events = {};
      }
      
      addTo(map) {
        if (!(map instanceof Atlas)) {
          throw new Error('addTo() argument must be an instance of Atlas');
        }
        if (this._map) this._map.removeLayer(this);
        this._map = map;
        map.addLayer(this);
        return this;
      }
      
      remove() {
        if (this._map) {
          this._map.removeLayer(this);
          this._map = null;
        }
        return this;
      }
      
      on(type, fn) {
        if (typeof type !== 'string') {
          throw new Error('Event type must be a string');
        }
        if (typeof fn !== 'function') {
          throw new Error('Event handler must be a function');
        }
        if (!this._events[type]) this._events[type] = [];
        this._events[type].push(fn);
        return this;
      }
      
      off(type, fn) {
        if (typeof type !== 'string') {
          throw new Error('Event type must be a string');
        }
        if (!this._events[type]) return this;
        if (!fn) this._events[type] = [];
        else this._events[type] = this._events[type].filter(cb => cb !== fn);
        return this;
      }
      
      fire(type, data = {}) {
        if (typeof type !== 'string') {
          throw new Error('Event type must be a string');
        }
        if (!this._events[type]) return;
        data.type = type;
        data.target = this;
        this._events[type].forEach(fn => {
          try {
            fn(data);
          } catch (error) {
            console.error(`Error in event handler for ${type}:`, error);
          }
        });
      }
      
      onAdd() {}
      onRemove() {}
      render() {}
    }
    
    /**
     * Tile layer for rendering map tiles
     */
    class TileLayer extends Layer {
      constructor(urlTemplate, options = {}) {
        super(options);
        
        // Validate required parameters
        if (typeof urlTemplate !== 'string') {
          throw new Error('urlTemplate must be a string');
        }
        
        this.urlTemplate = urlTemplate;
        this.options = {
          minZoom: typeof options.minZoom === 'number' ? Math.max(0, options.minZoom) : 0,
          maxZoom: typeof options.maxZoom === 'number' ? Math.max(0, options.maxZoom) : 18,
          attribution: typeof options.attribution === 'string' ? options.attribution : '',
          background: typeof options.background === 'string' ? options.background : '#ffffff',
          supportsRetina: !!options.supportsRetina,
          maxCacheSize: typeof options.maxCacheSize === 'number' ? Math.max(1, options.maxCacheSize) : 500,
          ...options
        };
        
        // Ensure maxZoom >= minZoom
        if (this.options.maxZoom < this.options.minZoom) {
          this.options.maxZoom = this.options.minZoom;
        }
        
        this.tileCache = new Map();
        this.loadingTiles = new Set();
        this.loadingControllers = new Map();
        this._retinaAvailable = true;
        this._retryCounts = new Map(); // Track retry attempts for tiles
        this._timeoutIds = new Map(); // Store timeout IDs for cleanup
      }
      
      _getTileUrl(x, y, z) {
        // Validate parameters
        if (typeof x !== 'number' || typeof y !== 'number' || typeof z !== 'number') {
          throw new Error('x, y, z must be numbers');
        }
        
        const scale = Math.pow(2, z);
        let wrappedX = ((x % scale) + scale) % scale;
        const intX = Math.floor(wrappedX);
        const intY = Math.max(0, Math.min(scale - 1, Math.floor(y)));
        let url = this.urlTemplate
          .replace('{z}', z)
          .replace('{x}', intX)
          .replace('{y}', intY);
        if (this.options.supportsRetina && this._shouldRequestRetina()) {
          url += DEFAULT_CONFIG.retinaSuffix;
        }
        return url;
      }
      
      _shouldRequestRetina() {
        const mode = DEFAULT_CONFIG.retina;
        const want = mode === true || (mode === "auto" && (window.devicePixelRatio || 1) > 1.5);
        return want && this._retinaAvailable;
      }
      
      async _loadTile(key, url) {
        // Check if tile is already loaded
        if (this.tileCache.has(key)) {
          const existing = this.tileCache.get(key);
          existing.lastUsed = Date.now();
          return existing;
        }
        
        // Check if tile is already loading
        if (this.loadingTiles.has(key)) {
          // Return a promise that resolves when the loading completes
          return new Promise((resolve) => {
            const checkLoading = () => {
              if (this.tileCache.has(key)) {
                resolve(this.tileCache.get(key));
              } else {
                setTimeout(checkLoading, 50);
              }
            };
            checkLoading();
          });
        }
        
        // Initialize retry count
        if (!this._retryCounts.has(key)) {
          this._retryCounts.set(key, 0);
        }
        
        const controller = new AbortController();
        const signal = controller.signal;
        this.loadingControllers.set(key, controller);
        
        const img = new Image();
        img.crossOrigin = "anonymous";
        
        const tile = { 
          img, 
          loaded: false, 
          loadedAt: Date.now(), 
          lastUsed: Date.now(), 
          controller 
        };
        
        this.tileCache.set(key, tile);
        this.loadingTiles.add(key);
        
        const loadPromise = new Promise((resolve, reject) => {
          img.onload = () => {
            tile.loaded = true;
            tile.loadedAt = Date.now();
            this.loadingTiles.delete(key);
            this.loadingControllers.delete(key);
            this._retryCounts.delete(key);
            
            if (this._map) {
              this._map.scheduleRender();
            }
            this.fire('tileload', { tile: key, url });
            resolve(tile);
          };
          
          img.onerror = (e) => {
            if (signal.aborted) {
              this.loadingTiles.delete(key);
              this.loadingControllers.delete(key);
              if (this.tileCache.has(key)) {
                this.tileCache.delete(key);
              }
              this._retryCounts.delete(key);
              return;
            }
            
            // Retry logic for retina failure
            if (this.options.supportsRetina && url.includes(DEFAULT_CONFIG.retinaSuffix)) {
              this._retinaAvailable = false;
              img.src = url.replace(DEFAULT_CONFIG.retinaSuffix, "");
              return;
            }
            
            // Retry logic for general failures (up to 2 retries)
            const retryCount = this._retryCounts.get(key) || 0;
            if (retryCount < 2) {
              this._retryCounts.set(key, retryCount + 1);
              console.log(`Retrying tile ${key} (attempt ${retryCount + 1})`);
              setTimeout(() => {
                img.src = url + (url.includes("?") ? "&" : "?") + "retry=" + (retryCount + 1);
              }, 500 * (retryCount + 1)); // Exponential backoff
              return;
            }
            
            // Give up after retries
            this.loadingTiles.delete(key);
            this.loadingControllers.delete(key);
            this._retryCounts.delete(key);
            
            if (this.tileCache.has(key)) {
              this.tileCache.delete(key);
            }
            
            this.fire('tileerror', { tile: key, url, error: e });
            reject(e);
          };
          
          img.src = url;
        });
        
        const timeoutId = setTimeout(() => {
          if (this.loadingTiles.has(key)) {
            controller.abort();
            this.loadingTiles.delete(key);
            this.loadingControllers.delete(key);
            this._retryCounts.delete(key);
            
            if (this.tileCache.has(key)) {
              this.tileCache.delete(key);
            }
            
            this.fire('tileerror', { tile: key, url, error: new Error('Timeout') });
          }
        }, TILE_LOAD_TIMEOUT_MS);
        
        this._timeoutIds.set(key, timeoutId);
        
        try {
          await Promise.race([loadPromise, 
            new Promise((_, reject) => {
              setTimeout(() => reject(new Error(`Timeout loading tile: ${url}`)), TILE_LOAD_TIMEOUT_MS);
            })
          ]);
        } catch (error) {
          console.warn(`Failed to load tile ${key}:`, error.message);
        } finally {
          // Clean up timeout
          if (this._timeoutIds.has(key)) {
            clearTimeout(this._timeoutIds.get(key));
            this._timeoutIds.delete(key);
          }
        }
        
        return tile;
      }
      
      _reloadTile(key, url) {
        const existing = this.tileCache.get(key);
        if (!existing) return;
        
        const token = key + "#r";
        if (this.loadingTiles.has(token)) return;
        
        const doReload = () => {
          const img = new Image();
          img.crossOrigin = "anonymous";
          this.loadingTiles.add(token);
          
          img.onload = () => {
            existing.img = img;
            existing.loaded = true;
            existing.loadedAt = Date.now();
            this.loadingTiles.delete(token);
            if (this._map) this._map.scheduleRender();
          };
          
          img.onerror = () => {
            this.loadingTiles.delete(token);
            console.warn(`Failed to reload tile: ${url}`);
          };
          
          img.src = url + (url.includes("?") ? "&" : "?") + "v=" + Date.now();
        };
        
        if (requestIdleCallback) {
          requestIdleCallback(doReload, { timeout: 2000 });
        } else {
          setTimeout(doReload, 100);
        }
      }
      
      _evict() {
        if (this.tileCache.size <= this.options.maxCacheSize) return;
        
        const doEviction = () => {
          if (this.tileCache.size <= this.options.maxCacheSize) return;
          
          // Sort tiles by last used time (oldest first)
          const entries = Array.from(this.tileCache.entries());
          entries.sort((a, b) => a[1].lastUsed - b[1].lastUsed);
          
          // Remove oldest tiles
          const removeCount = this.tileCache.size - this.options.maxCacheSize;
          for (let i = 0; i < removeCount; i++) {
            const key = entries[i][0];
            this.tileCache.delete(key);
            
            // Clean up any associated timeouts
            if (this._timeoutIds.has(key)) {
              clearTimeout(this._timeoutIds.get(key));
              this._timeoutIds.delete(key);
            }
          }
        };
        
        if (requestIdleCallback) {
          requestIdleCallback(doEviction, { timeout: 2000 });
        } else {
          setTimeout(doEviction, 100);
        }
      }
      
      _preloadAdjacentZoomTiles() {
        if (!this._map) return;
        
        const zInt = Math.floor(this._map.zoom);
        const nextZoom = Math.min(this.options.maxZoom, zInt + 1);
        const prevZoom = Math.max(this.options.minZoom, zInt - 1);
        
        // Only preload if we're close to an integer zoom level
        if (Math.abs(this._map.zoom - zInt) > 0.3) return;
        
        const wrappedCenterLon = GISUtils.wrapLongitude(this._map.center.lon);
        const ct = this._map.projection.latLngToTile({ lat: this._map.center.lat, lon: wrappedCenterLon }, zInt);
        const w = this._map.canvas.width / this._map.dpr;
        const h = this._map.canvas.height / this._map.dpr;
        const viewportTiles = Math.ceil(Math.max(w, h) / TILE_SIZE) + TILE_BUFFER;
        
        for (let dz of [prevZoom, nextZoom]) {
          if (dz === zInt) continue;
          
          const scaleDiff = Math.pow(2, Math.abs(dz - zInt));
          const startX = Math.floor(ct.x * (dz > zInt ? scaleDiff : 1 / scaleDiff) - viewportTiles / 2);
          const startY = Math.floor(ct.y * (dz > zInt ? scaleDiff : 1 / scaleDiff) - viewportTiles / 2);
          
          for (let dx = 0; dx < viewportTiles; dx++) {
            for (let dy = 0; dy < viewportTiles; dy++) {
              const X = startX + dx, Y = startY + dy;
              const key = `${dz}/${X}/${Y}`;
              
              if (!this.tileCache.has(key) && !this.loadingTiles.has(key)) {
                const url = this._getTileUrl(X, Y, dz);
                this._loadTile(key, url);
              }
            }
          }
        }
      }
      
      render() {
        if (!this._map) return;
        
        const w = this._map.canvas.width / this._map.dpr;
        const h = this._map.canvas.height / this._map.dpr;
        const zInt = Math.floor(this._map.zoom);
        const scaleFactor = Math.pow(2, this._map.zoom - zInt);
        const wrappedCenterLon = GISUtils.wrapLongitude(this._map.center.lon);
        const ct = this._map.projection.latLngToTile({ lat: this._map.center.lat, lon: wrappedCenterLon }, zInt);
        const absCos = Math.abs(Math.cos(this._map.bearing)), absSin = Math.abs(Math.sin(this._map.bearing));
        const needW = w * absCos + h * absSin;
        const needH = w * absSin + h * absCos;
        const cols = Math.ceil(needW / (TILE_SIZE * scaleFactor)) + TILE_BUFFER;
        const rows = Math.ceil(needH / (TILE_SIZE * scaleFactor)) + TILE_BUFFER;
        const startX = Math.floor(ct.x - cols / 2);
        const startY = Math.floor(ct.y - rows / 2);
        
        // Collect tiles with distance for sorting
        const tiles = [];
        for (let dx = 0; dx < cols; dx++) {
          for (let dy = 0; dy < rows; dy++) {
            const X = startX + dx, Y = startY + dy;
            const dist = Math.hypot(dx - cols / 2, dy - rows / 2);
            tiles.push({ X, Y, dist });
          }
        }
        
        // Sort by distance (center first)
        tiles.sort((a, b) => a.dist - b.dist);
        
        const ctx = this._map.ctx;
        ctx.save();
        ctx.translate(w / 2, h / 2);
        ctx.rotate(this._map.bearing);
        ctx.scale(scaleFactor, scaleFactor);
        ctx.imageSmoothingEnabled = false;
        
        // Draw tiles
        for (const { X, Y } of tiles) {
          const key = `${zInt}/${X}/${Y}`;
          const url = this._getTileUrl(X, Y, zInt);
          const trX = (X - ct.x) * TILE_SIZE;
          const trY = (Y - ct.y) * TILE_SIZE;
          
          let tile = this.tileCache.get(key);
          if (!tile) {
            this._loadTile(key, url);
          } else if (tile.loaded) {
            ctx.drawImage(tile.img, trX, trY, TILE_SIZE, TILE_SIZE);
            tile.lastUsed = Date.now();
            
            // Reload if tile is too old
            if (tile.loadedAt && (Date.now() - tile.loadedAt > TILE_TTL)) {
              this._reloadTile(key, url);
            }
          }
        }
        
        ctx.restore();
        
        // Perform cache eviction and preloading
        this._evict();
        this._preloadAdjacentZoomTiles();
      }
      
      onAdd() { 
        this.fire('add'); 
      }
      
      onRemove() {
        // Abort all loading requests
        for (const controller of this.loadingControllers.values()) {
          controller.abort();
        }
        
        // Clear all timeouts
        for (const timeoutId of this._timeoutIds.values()) {
          clearTimeout(timeoutId);
        }
        
        // Clear all data structures
        this.loadingTiles.clear();
        this.loadingControllers.clear();
        this.tileCache.clear();
        this._retryCounts.clear();
        this._timeoutIds.clear();
        
        this.fire('remove');
      }
      
      getAttribution() { return this.options.attribution; }
      getBackground() { return this.options.background; }
      getMinZoom() { return this.options.minZoom; }
      getMaxZoom() { return this.options.maxZoom; }
    }
    
    /**
     * GeoJSON layer for rendering vector data
     */
    class GeoJSONLayer extends Layer {
      constructor(geojson, options = {}) {
        super(options);
        this._geojson = this._normalizeGeoJSON(geojson);
        this._features = [];
        this._featureCache = new Map();
        this._hitCache = new Map();
        this._lastRenderZoom = null;
        this._lastRenderBearing = null;
        this._lastRenderCenter = null;
        
        // Default style with validation
        this.options.style = options.style || { 
          color: '#3388ff', 
          weight: 3, 
          opacity: 1, 
          fillColor: '#3388ff', 
          fillOpacity: 0.2 
        };
        
        this.options.interactive = options.interactive !== undefined ? options.interactive : true;
        this._onMouseMove = this._onMouseMove.bind(this);
        this._onMouseOut = this._onMouseOut.bind(this);
        this._onClick = this._onClick.bind(this);
      }
      
      _normalizeGeoJSON(input) {
        // Validate input
        if (!input || typeof input !== 'object') {
          throw new Error('GeoJSON input must be an object');
        }
        
        if (Array.isArray(input)) {
          return { 
            type: 'FeatureCollection', 
            features: input.map(f => {
              if (!f || typeof f !== 'object') {
                throw new Error('Feature must be an object');
              }
              return f.type === 'Feature' ? f : { 
                type: 'Feature', 
                geometry: this._validateGeometry(f), 
                properties: f.properties || {} 
              };
            })
          };
        }
        
        if (input.type === 'FeatureCollection') {
          if (!Array.isArray(input.features)) {
            throw new Error('FeatureCollection must have a features array');
          }
          return input;
        }
        
        if (input.type === 'Feature') {
          if (!input.geometry) {
            throw new Error('Feature must have a geometry');
          }
          return { 
            type: 'FeatureCollection', 
            features: [{ 
              type: 'Feature', 
              geometry: this._validateGeometry(input.geometry), 
              properties: input.properties || {} 
            }] 
          };
        }
        
        // Assume it's a geometry
        return { 
          type: 'FeatureCollection', 
          features: [{ 
            type: 'Feature', 
            geometry: this._validateGeometry(input), 
            properties: {} 
          }] 
        };
      }
      
      _validateGeometry(geometry) {
        if (!geometry || typeof geometry !== 'object') {
          throw new Error('Geometry must be an object');
        }
        
        if (!geometry.type || typeof geometry.type !== 'string') {
          throw new Error('Geometry must have a type property');
        }
        
        // Validate coordinates based on geometry type
        switch (geometry.type) {
          case 'Point':
            if (!Array.isArray(geometry.coordinates) || geometry.coordinates.length < 2) {
              throw new Error('Point geometry must have coordinates array with at least 2 elements');
            }
            this._validateCoordinate(geometry.coordinates);
            break;
            
          case 'LineString':
            if (!Array.isArray(geometry.coordinates) || geometry.coordinates.length < 2) {
              throw new Error('LineString geometry must have coordinates array with at least 2 points');
            }
            geometry.coordinates.forEach(coord => this._validateCoordinate(coord));
            break;
            
          case 'Polygon':
            if (!Array.isArray(geometry.coordinates) || geometry.coordinates.length === 0) {
              throw new Error('Polygon geometry must have coordinates array with at least one ring');
            }
            geometry.coordinates.forEach(ring => {
              if (!Array.isArray(ring) || ring.length < 4) {
                throw new Error('Polygon ring must have at least 4 points');
              }
              ring.forEach(coord => this._validateCoordinate(coord));
              // Ensure first and last points are the same (closed ring)
              if (ring.length > 0 && 
                  (ring[0][0] !== ring[ring.length-1][0] || ring[0][1] !== ring[ring.length-1][1])) {
                // Auto-close the ring
                ring.push([...ring[0]]);
              }
            });
            break;
            
          case 'MultiPoint':
          case 'MultiLineString':
          case 'MultiPolygon':
            if (!Array.isArray(geometry.coordinates)) {
              throw new Error(`${geometry.type} geometry must have coordinates array`);
            }
            break;
        }
        
        return geometry;
      }
      
      _validateCoordinate(coord) {
        if (!Array.isArray(coord) || coord.length < 2) {
          throw new Error('Coordinate must be an array with at least 2 elements');
        }
        
        if (typeof coord[0] !== 'number' || typeof coord[1] !== 'number') {
          throw new Error('Coordinate elements must be numbers');
        }
        
        // Validate longitude and latitude ranges
        if (coord[0] < -180 || coord[0] > 180) {
          throw new Error(`Longitude ${coord[0]} is out of valid range [-180, 180]`);
        }
        if (coord[1] < -90 || coord[1] > 90) {
          throw new Error(`Latitude ${coord[1]} is out of valid range [-90, 90]`);
        }
      }
      
      _latLngToScreenPoint(coord) {
        if (!this._map) return { x: 0, y: 0 };
        
        // Validate coordinate
        if (!Array.isArray(coord) || coord.length < 2) {
          return { x: 0, y: 0 };
        }
        
        const [lon, lat] = coord;
        const w = this._map.canvas.width / this._map.dpr;
        const h = this._map.canvas.height / this._map.dpr;
        const zInt = Math.floor(this._map.zoom);
        const ts = TILE_SIZE * Math.pow(2, this._map.zoom - zInt);
        const ct = this._map.projection.latLngToTile(this._map.center, zInt);
        const pt = this._map.projection.latLngToTile({ lat, lon }, zInt);
        const trX = (pt.x - ct.x) * ts;
        const trY = (pt.y - ct.y) * ts;
        const anchorVec = rot(trX, trY, this._map.bearing);
        return { x: w / 2 + anchorVec.x, y: h / 2 + anchorVec.y };
      }
      
      _getFeatureStyle(feature) {
        return typeof this.options.style === 'function' ? this.options.style(feature) : this.options.style;
      }
      
      _processFeature(feature) {
        if (!feature || !feature.geometry) return null;
        
        const cacheKey = JSON.stringify(feature);
        if (this._featureCache.has(cacheKey)) return this._featureCache.get(cacheKey);
        
        const geometry = feature.geometry;
        const processed = { type: geometry.type, coordinates: null, properties: feature.properties || {} };
        
        try {
          switch (geometry.type) {
            case 'Point':
              processed.coordinates = this._latLngToScreenPoint(geometry.coordinates);
              break;
              
            case 'MultiPoint':
              if (!Array.isArray(geometry.coordinates)) return null;
              processed.coordinates = geometry.coordinates.map(coord => this._latLngToScreenPoint(coord));
              break;
              
            case 'LineString':
              if (!Array.isArray(geometry.coordinates)) return null;
              processed.coordinates = geometry.coordinates.map(coord => this._latLngToScreenPoint(coord));
              break;
              
            case 'MultiLineString':
              if (!Array.isArray(geometry.coordinates)) return null;
              processed.coordinates = geometry.coordinates.map(ring => {
                if (!Array.isArray(ring)) return [];
                return ring.map(coord => this._latLngToScreenPoint(coord));
              });
              break;
              
            case 'Polygon':
              if (!Array.isArray(geometry.coordinates)) return null;
              processed.coordinates = geometry.coordinates.map(ring => {
                if (!Array.isArray(ring)) return [];
                return ring.map(coord => this._latLngToScreenPoint(coord));
              });
              break;
              
            case 'MultiPolygon':
              if (!Array.isArray(geometry.coordinates)) return null;
              processed.coordinates = geometry.coordinates.map(polygon => {
                if (!Array.isArray(polygon)) return [];
                return polygon.map(ring => {
                  if (!Array.isArray(ring)) return [];
                  return ring.map(coord => this._latLngToScreenPoint(coord));
                });
              });
              break;
              
            default:
              return null;
          }
          
          this._featureCache.set(cacheKey, processed);
          return processed;
        } catch (error) {
          console.error('Error processing feature:', error);
          return null;
        }
      }
      
      _renderPoint(ctx, feature, style) {
        if (!feature.coordinates) return;
        
        const { x, y } = feature.coordinates;
        ctx.beginPath();
        ctx.arc(x, y, style.radius || 5, 0, 2 * Math.PI);
        ctx.fillStyle = style.fillColor || style.color || '#3388ff';
        ctx.fill();
        
        if (style.stroke !== false) {
          ctx.strokeStyle = style.color || '#3388ff';
          ctx.lineWidth = style.weight || 2;
          ctx.globalAlpha = style.opacity || 1;
          ctx.stroke();
        }
        ctx.globalAlpha = 1;
      }
      
      _renderLineString(ctx, feature, style) {
        if (!feature.coordinates || feature.coordinates.length < 2) return;
        
        ctx.beginPath();
        ctx.moveTo(feature.coordinates[0].x, feature.coordinates[0].y);
        for (let i = 1; i < feature.coordinates.length; i++) {
          ctx.lineTo(feature.coordinates[i].x, feature.coordinates[i].y);
        }
        ctx.strokeStyle = style.color || '#3388ff';
        ctx.lineWidth = style.weight || 3;
        ctx.globalAlpha = style.opacity || 1;
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
      
      _renderPolygon(ctx, feature, style) {
        if (!feature.coordinates || feature.coordinates.length === 0) return;
        
        ctx.beginPath();
        for (let r = 0; r < feature.coordinates.length; r++) {
          const ring = feature.coordinates[r];
          if (ring.length < 3) continue;
          ctx.moveTo(ring[0].x, ring[0].y);
          for (let i = 1; i < ring.length; i++) {
            ctx.lineTo(ring[i].x, ring[i].y);
          }
          ctx.closePath();
        }
        
        if (style.fill !== false) {
          ctx.fillStyle = style.fillColor || style.color || '#3388ff';
          ctx.globalAlpha = style.fillOpacity || 0.2;
          ctx.fill();
          ctx.globalAlpha = 1;
        }
        
        if (style.stroke !== false) {
          ctx.strokeStyle = style.color || '#3388ff';
          ctx.lineWidth = style.weight || 3;
          ctx.globalAlpha = style.opacity || 1;
          ctx.stroke();
          ctx.globalAlpha = 1;
        }
      }
      
      _pointInPolygon(x, y, ring) {
        if (!ring || ring.length < 3) return false;
        
        let inside = false;
        for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
          const xi = ring[i].x, yi = ring[i].y;
          const xj = ring[j].x, yj = ring[j].y;
          const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
          if (intersect) inside = !inside;
        }
        return inside;
      }
      
      _hitDetect(x, y) {
        const viewKey = `${this._map.zoom.toFixed(6)}_${this._map.bearing}_${this._map.center.lon}_${this._map.center.lat}`;
        
        if (!this._hitCache.has(viewKey)) {
          const hitMap = new Map();
          
          for (const feature of this._features) {
            const processed = this._processFeature(feature);
            if (!processed) continue;
            
            switch (processed.type) {
              case 'Point':
                if (processed.coordinates) {
                  const dist = Math.hypot(x - processed.coordinates.x, y - processed.coordinates.y);
                  if (dist <= (this._getFeatureStyle(feature).radius || 5) + 5) {
                    hitMap.set(`${x}_${y}`, feature);
                  }
                }
                break;
                
              case 'Polygon':
                if (processed.coordinates) {
                  for (const ring of processed.coordinates) {
                    if (this._pointInPolygon(x, y, ring)) {
                      hitMap.set(`${x}_${y}`, feature);
                      break;
                    }
                  }
                }
                break;
            }
          }
          
          this._hitCache.set(viewKey, hitMap);
        }
        
        return this._hitCache.get(viewKey)?.get(`${x}_${y}`) || null;
      }
      
      _onMouseMove(e) {
        const rect = this._map.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const feature = this._hitDetect(x, y);
        
        this._map.canvas.style.cursor = feature ? 'pointer' : 'grab';
        
        if (feature) {
          this.fire('mousemove', { originalEvent: e, feature });
        } else {
          this.fire('mouseout', { originalEvent: e });
        }
      }
      
      _onMouseOut(e) {
        this._map.canvas.style.cursor = 'grab';
        this.fire('mouseout', { originalEvent: e });
      }
      
      _onClick(e) {
        const rect = this._map.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const feature = this._hitDetect(x, y);
        
        if (feature) {
          this.fire('click', { originalEvent: e, feature });
        }
      }
      
      onAdd() {
        this._features = this._geojson.features || [];
        
        if (this.options.interactive) {
          this._map.canvas.addEventListener('mousemove', this._onMouseMove);
          this._map.canvas.addEventListener('mouseout', this._onMouseOut);
          this._map.canvas.addEventListener('click', this._onClick);
        }
        
        this.fire('add');
      }
      
      onRemove() {
        if (this.options.interactive) {
          this._map.canvas.removeEventListener('mousemove', this._onMouseMove);
          this._map.canvas.removeEventListener('mouseout', this._onMouseOut);
          this._map.canvas.removeEventListener('click', this._onClick);
        }
        
        this._featureCache.clear();
        this._hitCache.clear();
        this.fire('remove');
      }
      
      render() {
        if (!this._map) return;
        
        const ctx = this._map.ctx;
        const needsRebuild = (
          this._lastRenderZoom !== this._map.zoom ||
          this._lastRenderBearing !== this._map.bearing ||
          !this._lastRenderCenter || 
          this._lastRenderCenter.lon !== this._map.center.lon ||
          this._lastRenderCenter.lat !== this._map.center.lat
        );
        
        if (needsRebuild) {
          this._featureCache.clear();
          this._hitCache.clear();
          this._lastRenderZoom = this._map.zoom;
          this._lastRenderBearing = this._map.bearing;
          this._lastRenderCenter = { ...this._map.center };
        }
        
        for (const feature of this._features) {
          const processed = this._processFeature(feature);
          if (!processed) continue;
          
          const style = this._getFeatureStyle(feature);
          switch (processed.type) {
            case 'Point':
              this._renderPoint(ctx, processed, style);
              break;
            case 'LineString':
              this._renderLineString(ctx, processed, style);
              break;
            case 'Polygon':
              this._renderPolygon(ctx, processed, style);
              break;
          }
        }
      }
      
      setData(geojson) {
        this._geojson = this._normalizeGeoJSON(geojson);
        this._features = this._geojson.features || [];
        this._featureCache.clear();
        this._hitCache.clear();
        
        if (this._map) {
          this._map.render();
        }
        
        return this;
      }
      
      getData() { return this._geojson; }
    }
    
    /**
     * Base class for map controls
     */
    class Control {
      constructor(options = {}) {
        this.options = { 
          position: typeof options.position === 'string' ? options.position : 'top-left'
        };
        this._map = null;
        this._container = null;
        this._events = {};
      }
      
      on(type, fn) {
        if (typeof type !== 'string') {
          throw new Error('Event type must be a string');
        }
        if (typeof fn !== 'function') {
          throw new Error('Event handler must be a function');
        }
        if (!this._events[type]) this._events[type] = [];
        this._events[type].push(fn);
        return this;
      }
      
      off(type, fn) {
        if (typeof type !== 'string') {
          throw new Error('Event type must be a string');
        }
        if (!this._events[type]) return this;
        if (!fn) this._events[type] = [];
        else this._events[type] = this._events[type].filter(cb => cb !== fn);
        return this;
      }
      
      fire(type, data = {}) {
        if (typeof type !== 'string') {
          throw new Error('Event type must be a string');
        }
        if (!this._events[type]) return;
        data.type = type;
        data.target = this;
        this._events[type].forEach(fn => {
          try {
            fn(data);
          } catch (error) {
            console.error(`Error in event handler for ${type}:`, error);
          }
        });
      }
      
      onAdd() { 
        return document.createElement('div'); 
      }
      
      onRemove() {}
      
      addTo(map) {
        if (!(map instanceof Atlas)) {
          throw new Error('addTo() argument must be an instance of Atlas');
        }
        
        this.remove();
        this._map = map;
        this._container = this.onAdd();
        this._addToContainer();
        return this;
      }
      
      remove() {
        if (!this._map) return this;
        this.onRemove();
        if (this._container?.parentNode) {
          this._container.parentNode.removeChild(this._container);
        }
        this._map = null;
        this._container = null;
        return this;
      }
      
      getContainer() { return this._container; }
      
      _addToContainer() {
        if (!this._map || !this._container) return;
        
        const position = this.options.position;
        let container = this._map._controlCorners[position];
        
        if (!container) {
          container = document.createElement('div');
          container.className = `atlas-control-container atlas-control-${position} atlas-control-vertical`;
          this._map.container.appendChild(container);
          this._map._controlCorners[position] = container;
        }
        
        container.appendChild(this._container);
      }
    }
    
    /**
     * Zoom control for map
     */
    class ZoomControl extends Control {
      constructor(options = {}) {
        super(options);
        this.options = { 
          ...this.options, 
          zoomInTitle: options.zoomInTitle || 'Zoom in', 
          zoomOutTitle: options.zoomOutTitle || 'Zoom out' 
        };
      }
      
      onAdd() {
        const container = document.createElement('div');
        
        const zoomInBtn = document.createElement('button');
        zoomInBtn.className = 'control-btn';
        zoomInBtn.title = this.options.zoomInTitle;
        zoomInBtn.textContent = '+';
        zoomInBtn.onclick = () => {
          if (this._map) {
            this._map.stopAnimations();
            const rect = this._map.canvas.getBoundingClientRect();
            this._map.smoothZoomAt(rect.width / 2, rect.height / 2, WHEEL_ZOOM_STEP);
          }
        };
        
        const zoomOutBtn = document.createElement('button');
        zoomOutBtn.className = 'control-btn';
        zoomOutBtn.title = this.options.zoomOutTitle;
        zoomOutBtn.textContent = '−';
        zoomOutBtn.onclick = () => {
          if (this._map) {
            this._map.stopAnimations();
            const rect = this._map.canvas.getBoundingClientRect();
            this._map.smoothZoomAt(rect.width / 2, rect.height / 2, -WHEEL_ZOOM_STEP);
          }
        };
        
        container.appendChild(zoomInBtn);
        container.appendChild(zoomOutBtn);
        
        this._zoomInBtn = zoomInBtn;
        this._zoomOutBtn = zoomOutBtn;
        
        return container;
      }
      
      _update() {
        if (!this._map || !this._zoomInBtn || !this._zoomOutBtn) return;
        
        const minZoom = this._map.getBaseLayer()?.getMinZoom() || 0;
        const maxZoom = this._map.getBaseLayer()?.getMaxZoom() || 18;
        const currentZoom = this._map.getZoom();
        
        this._zoomInBtn.disabled = currentZoom >= maxZoom;
        this._zoomOutBtn.disabled = currentZoom <= minZoom;
      }
    }
    
    /**
     * Layer control for switching between map layers
     */
    class LayerControl extends Control {
      constructor(options = {}) {
        super(options);
        this.options = { 
          ...this.options, 
          title: options.title || 'Toggle layer' 
        };
      }
      
      onAdd() {
        const container = document.createElement('div');
        const toggleBtn = document.createElement('button');
        toggleBtn.className = 'control-btn';
        toggleBtn.title = this.options.title;
        toggleBtn.textContent = '🌐';
        
        toggleBtn.onclick = () => {
          if (this._map) {
            const current = this._map.getBaseLayer();
            let newLayer;
            
            if (!current || !current.urlTemplate?.includes('arcgisonline')) {
              newLayer = new TileLayer(
                "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
                { 
                  minZoom: 0, 
                  maxZoom: 19, 
                  attribution: 'Tiles © <a href="https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer" target="_blank" rel="noopener noreferrer">Esri World Imagery</a>', 
                  background: "#000000", 
                  supportsRetina: false, 
                  maxCacheSize: 400 
                }
              );
            } else {
              const subdomains = ['a', 'b', 'c'];
              const randomSubdomain = subdomains[Math.floor(Math.random() * subdomains.length)];
              newLayer = new TileLayer(
                `https://${randomSubdomain}.tile.openstreetmap.org/{z}/{x}/{y}.png`,
                { 
                  minZoom: 0, 
                  maxZoom: 19, 
                  attribution: '© <a href="https://www.openstreetmap.org/copyright" target="_blank" rel="noopener noreferrer">OpenStreetMap contributors</a>', 
                  background: "#e6e6e6", 
                  supportsRetina: true, 
                  maxCacheSize: 500 
                }
              );
            }
            
            this._map.setBaseLayer(newLayer);
          }
        };
        
        container.appendChild(toggleBtn);
        return container;
      }
    }
    
    /**
     * Fullscreen control for map
     */
    class FullscreenControl extends Control {
      constructor(options = {}) {
        super(options);
        this.options = { 
          ...this.options, 
          title: options.title || 'Toggle fullscreen' 
        };
      }
      
      onAdd() {
        const container = document.createElement('div');
        const fullscreenBtn = document.createElement('button');
        fullscreenBtn.className = 'control-btn';
        fullscreenBtn.title = this.options.title;
        fullscreenBtn.textContent = '⛶';
        
        fullscreenBtn.onclick = () => {
          if (!document.fullscreenElement) {
            this._map.container.requestFullscreen().catch(err => {
              console.warn('Fullscreen request failed:', err);
            });
          } else {
            document.exitFullscreen().catch(err => {
              console.warn('Exit fullscreen failed:', err);
            });
          }
        };
        
        container.appendChild(fullscreenBtn);
        return container;
      }
    }
    
    /**
     * Scale control for map
     */
    class ScaleControl extends Control {
      constructor(options = {}) {
        super(options);
        this.options = { 
          ...this.options, 
          maxWidth: typeof options.maxWidth === 'number' ? Math.max(50, options.maxWidth) : 150, 
          unit: ['metric', 'imperial'].includes(options.unit) ? options.unit : 'metric' 
        };
      }
      
      onAdd() {
        const container = document.createElement('div');
        container.className = 'scale-bar-container';
        
        this._scaleBar = document.createElement('div');
        this._scaleBar.className = 'scale-bar';
        
        this._scaleText = document.createElement('div');
        this._scaleText.dataset.unit = this.options.unit;
        
        container.appendChild(this._scaleBar);
        container.appendChild(this._scaleText);
        
        this._scaleText.addEventListener('click', () => {
          this._scaleText.dataset.unit = this._scaleText.dataset.unit === 'metric' ? 'imperial' : 'metric';
          this._update();
        });
        
        return container;
      }
      
      _update() {
        if (!this._map || !this._scaleBar || !this._scaleText) return;
        
        const mPerPx = GISUtils.getResolution(this._map.getCenter().lat, this._map.getZoom());
        const targetMeters = mPerPx * this.options.maxWidth;
        const pow = Math.pow(10, Math.floor(Math.log10(targetMeters)));
        const base = targetMeters / pow;
        const niceBase = base >= 5 ? 5 : base >= 2 ? 2 : 1;
        const niceMeters = niceBase * pow;
        const widthPx = Math.max(20, Math.min(this.options.maxWidth, niceMeters / mPerPx));
        
        this._scaleBar.style.width = `${widthPx}px`;
        
        let displayText;
        if (this._scaleText.dataset.unit === "metric") {
          displayText = GISUtils.formatDistance(niceMeters);
        } else {
          const feet = niceMeters * 3.28084;
          displayText = feet < 5280 ? Math.round(feet) + " ft" : (feet / 5280).toFixed(1) + " mi";
        }
        
        this._scaleText.textContent = displayText;
      }
    }
    
    /**
     * Attribution control for map
     */
    class AttributionControl extends Control {
      constructor(options = {}) {
        super(options);
        this.options = { 
          ...this.options, 
          prefix: typeof options.prefix === 'string' ? options.prefix : '' 
        };
      }
      
      onAdd() {
        const container = document.createElement('div');
        container.id = 'attribution';
        container.innerHTML = this.options.prefix;
        this._container = container;
        return container;
      }
      
      _update() {
        if (!this._map || !this._container) return;
        const attribution = this._map.getBaseLayer()?.getAttribution() || '';
        this._container.innerHTML = this.options.prefix + (this.options.prefix && attribution ? ' | ' : '') + attribution;
      }
    }
    
    /**
     * Compass control for resetting map bearing
     */
    class CompassControl extends Control {
      constructor(options = {}) {
        super(options);
        this.options = { 
          ...this.options, 
          title: options.title || 'Reset North' 
        };
      }
      
      onAdd() {
        const container = document.createElement('div');
        const compassBtn = document.createElement('button');
        compassBtn.className = 'control-btn';
        compassBtn.title = this.options.title;
        compassBtn.textContent = 'N';
        compassBtn.style.display = 'none';
        
        compassBtn.onclick = () => {
          if (this._map) {
            const w = this._map.canvas.width / this._map.dpr;
            const h = this._map.canvas.height / this._map.dpr;
            this._map.animateZoomRotateAbout(w / 2, h / 2, this._map.getZoom(), 0, SNAP_DURATION);
          }
        };
        
        container.appendChild(compassBtn);
        this._compassBtn = compassBtn;
        return container;
      }
      
      _update() {
        if (!this._compassBtn || !this._map) return;
        const visible = Math.abs(this._map.getBearing()) > 0.001;
        this._compassBtn.style.display = visible ? "block" : "none";
        this._compassBtn.style.transform = `rotate(${-this._map.getBearing() * RAD2DEG}deg)`;
      }
    }
    
    /**
     * Reset zoom control for returning to default view
     */
    class ResetZoomControl extends Control {
      constructor(options = {}) {
        super(options);
        this.options = { 
          ...this.options, 
          title: options.title || 'Reset Zoom' 
        };
      }
      
      onAdd() {
        const container = document.createElement('div');
        const resetBtn = document.createElement('button');
        resetBtn.className = 'control-btn';
        resetBtn.title = this.options.title;
        resetBtn.textContent = '⤢';
        
        resetBtn.onclick = () => {
          if (this._map) {
            this._map.flyTo({ 
              center: { 
                lon: DEFAULT_CONFIG.defaultCenter.lon, 
                lat: DEFAULT_CONFIG.defaultCenter.lat 
              }, 
              zoom: DEFAULT_CONFIG.defaultZoom, 
              duration: SNAP_DURATION 
            });
          }
        };
        
        container.appendChild(resetBtn);
        return container;
      }
    }
    
    /**
     * Base class for map interaction handlers
     */
    class Handler {
      constructor(map) {
        if (!(map instanceof Atlas)) {
          throw new Error('Handler must be initialized with an Atlas instance');
        }
        this._map = map;
        this._enabled = false;
      }
      
      enable() {
        if (this._enabled) return this;
        this._enabled = true;
        this._addEvents();
        return this;
      }
      
      disable() {
        if (!this._enabled) return this;
        this._enabled = false;
        this._removeEvents();
        return this;
      }
      
      isEnabled() { return this._enabled; }
      
      _addEvents() {}
      _removeEvents() {}
      
      destroy() { 
        this.disable(); 
      }
    }
    
    /**
     * Drag pan handler for map panning
     */
    class DragPanHandler extends Handler {
      constructor(map) {
        super(map);
        this._isDragging = false;
        this._dragStart = null;
        this._moveSamples = [];
        this._inertiaCleanup = null;
      }
      
      _addEvents() {
        this._map.canvas.addEventListener('mousedown', this._onMouseDown = this._onMouseDown.bind(this));
        this._map.canvas.addEventListener('touchstart', this._onTouchStart = this._onTouchStart.bind(this), { passive: false });
      }
      
      _removeEvents() {
        this._map.canvas.removeEventListener('mousedown', this._onMouseDown);
        this._map.canvas.removeEventListener('touchstart', this._onTouchStart);
        this._removeMoveEvents();
      }
      
      _removeMoveEvents() {
        document.removeEventListener('mousemove', this._onMouseMove);
        document.removeEventListener('mouseup', this._onMouseUp);
        document.removeEventListener('touchmove', this._onTouchMove, { passive: false });
        document.removeEventListener('touchend', this._onTouchEnd);
        document.removeEventListener('touchcancel', this._onTouchEnd);
      }
      
      _onMouseDown(e) {
        if (e.button !== 0) return;
        this._startDrag(e.clientX, e.clientY);
        document.addEventListener('mousemove', this._onMouseMove = this._onMouseMove.bind(this));
        document.addEventListener('mouseup', this._onMouseUp = this._onMouseUp.bind(this));
      }
      
      _onMouseMove(e) {
        if (!this._isDragging) return;
        e.preventDefault();
        
        const dx = e.clientX - this._dragStart.x;
        const dy = e.clientY - this._dragStart.y;
        const w = this._map.canvas.width / this._map.dpr;
        const h = this._map.canvas.height / this._map.dpr;
        
        this._map.center = this._map.screenToLatLon(w / 2 - dx, h / 2 - dy, this._map.zoom, this._map.bearing, this._dragStart.center);
        this._pushVelocitySample(e.clientX, e.clientY);
        this._map.render();
      }
      
      _onMouseUp() { 
        this._endDrag(); 
      }
      
      _onTouchStart(e) {
        if (e.touches.length !== 1) return;
        e.preventDefault();
        this._startDrag(e.touches[0].clientX, e.touches[0].clientY);
        document.addEventListener('touchmove', this._onTouchMove = this._onTouchMove.bind(this), { passive: false });
        document.addEventListener('touchend', this._onTouchEnd = this._onTouchEnd.bind(this));
        document.addEventListener('touchcancel', this._onTouchEnd);
      }
      
      _onTouchMove(e) {
        if (!this._isDragging || e.touches.length !== 1) return;
        e.preventDefault();
        
        const dx = e.touches[0].clientX - this._dragStart.x;
        const dy = e.touches[0].clientY - this._dragStart.y;
        const w = this._map.canvas.width / this._map.dpr;
        const h = this._map.canvas.height / this._map.dpr;
        
        this._map.center = this._map.screenToLatLon(w / 2 - dx, h / 2 - dy, this._map.zoom, this._map.bearing, this._dragStart.center);
        this._pushVelocitySample(e.touches[0].clientX, e.touches[0].clientY);
        this._map.render();
      }
      
      _onTouchEnd() { 
        this._endDrag(); 
      }
      
      _startDrag(clientX, clientY) {
        this._isDragging = true;
        this._map.stopAnimations();
        this._map.isDragging = true;
        this._map.container.classList.add('dragging');
        this._dragStart = { x: clientX, y: clientY, center: { ...this._map.center } };
        this._moveSamples = [];
        this._pushVelocitySample(clientX, clientY);
      }
      
      _endDrag() {
        if (!this._isDragging) return;
        
        this._isDragging = false;
        this._map.isDragging = false;
        this._map.container.classList.remove('dragging');
        
        const { vx, vy } = this._computeVelocity();
        this._startInertia(vx, vy);
        this._removeMoveEvents();
      }
      
      _pushVelocitySample(x, y) {
        const t = performance.now();
        this._moveSamples.push({ t, x, y });
        const cutoff = t - VELOCITY_WINDOW_MS;
        
        while (this._moveSamples.length && this._moveSamples[0].t < cutoff) {
          this._moveSamples.shift();
        }
      }
      
      _computeVelocity() {
        if (this._moveSamples.length < 2) return { vx: 0, vy: 0 };
        
        const last = this._moveSamples[this._moveSamples.length - 1];
        let i = this._moveSamples.length - 2;
        
        while (i > 0 && last.t - this._moveSamples[i].t < VELOCITY_WINDOW_MS * 0.5) {
          i--;
        }
        
        const ref = this._moveSamples[i];
        const dt = Math.max(1, last.t - ref.t);
        return { vx: (last.x - ref.x) / dt, vy: (last.y - ref.y) / dt };
      }
      
      _startInertia(vx, vy) {
        const speed = Math.hypot(vx, vy);
        if (speed < INERTIA_STOP_SPEED) return;
        
        let lastT = performance.now();
        const step = () => {
          const now = performance.now();
          const dt = now - lastT;
          lastT = now;
          
          const dx = vx * dt, dy = vy * dt;
          const w = this._map.canvas.width / this._map.dpr;
          const h = this._map.canvas.height / this._map.dpr;
          
          this._map.center = this._map.screenToLatLon(w / 2 - dx, h / 2 - dy);
          const vmag = Math.hypot(vx, vy);
          const newVmag = Math.max(0, vmag - INERTIA_DECEL * dt);
          
          if (newVmag <= INERTIA_STOP_SPEED) {
            this._map.render();
            this._map._inertiaRAF = null;
            this._map.fire('moveend');
            return;
          }
          
          const s = newVmag / (vmag || 1);
          vx *= s;
          vy *= s;
          this._map.render();
          this._map._inertiaRAF = requestAnimationFrame(step);
        };
        
        this._map._inertiaRAF = requestAnimationFrame(step);
        
        // Clean up inertia animation on destroy
        this._inertiaCleanup = () => {
          if (this._map._inertiaRAF) {
            cancelAnimationFrame(this._map._inertiaRAF);
            this._map._inertiaRAF = null;
          }
        };
      }
      
      destroy() {
        this.disable();
        if (this._inertiaCleanup) {
          this._inertiaCleanup();
          this._inertiaCleanup = null;
        }
      }
    }
    
    /**
     * Scroll zoom handler for zooming with mouse wheel
     */
    class ScrollZoomHandler extends Handler {
      constructor(map) {
        super(map);
        this._wheelTimeout = null;
      }
      
      _addEvents() {
        this._map.canvas.addEventListener('wheel', this._onWheel = this._onWheel.bind(this), { passive: false });
      }
      
      _removeEvents() {
        this._map.canvas.removeEventListener('wheel', this._onWheel);
        if (this._wheelTimeout) {
          clearTimeout(this._wheelTimeout);
          this._wheelTimeout = null;
        }
      }
      
      _onWheel(e) {
        e.preventDefault();
        
        // Debounce rapid wheel events
        if (this._wheelTimeout) {
          clearTimeout(this._wheelTimeout);
        }
        
        this._wheelTimeout = setTimeout(() => {
          this._wheelTimeout = null;
        }, 50);
        
        const dz = e.deltaY < 0 ? WHEEL_ZOOM_STEP : -WHEEL_ZOOM_STEP;
        this._map.smoothZoomAt(e.clientX, e.clientY, dz);
      }
    }
    
    /**
     * Double click zoom handler
     */
    class DoubleClickZoomHandler extends Handler {
      _addEvents() {
        this._map.canvas.addEventListener('dblclick', this._onDoubleClick = this._onDoubleClick.bind(this));
      }
      
      _removeEvents() {
        this._map.canvas.removeEventListener('dblclick', this._onDoubleClick);
      }
      
      _onDoubleClick(e) {
        e.preventDefault();
        this._map.animateZoomRotateAbout(e.clientX, e.clientY, this._map.getZoom() + 1, this._map.getBearing(), TAP_ZOOM_DURATION);
      }
    }
    
    /**
     * Touch zoom and rotate handler for mobile devices
     */
    class TouchZoomRotateHandler extends Handler {
      constructor(map) {
        super(map);
        this._isPinching = false;
        this._pinchStartDist = 0;
        this._pinchStartAngle = 0;
        this._pinchStartZoom = map.getZoom();
        this._pinchStartBearing = map.getBearing();
        this._pinchStartTime = 0;
        this._pinchLastCenter = null;
        this._pinchMoved = false;
        this._pinchAnchorLL = null;
      }
      
      _addEvents() {
        this._map.canvas.addEventListener('touchstart', this._onTouchStart = this._onTouchStart.bind(this), { passive: false });
      }
      
      _removeEvents() {
        this._map.canvas.removeEventListener('touchstart', this._onTouchStart);
        this._removeMoveEvents();
      }
      
      _removeMoveEvents() {
        document.removeEventListener('touchmove', this._onTouchMove, { passive: false });
        document.removeEventListener('touchend', this._onTouchEnd);
        document.removeEventListener('touchcancel', this._onTouchEnd);
      }
      
      _onTouchStart(e) {
        if (e.touches.length < 2) return;
        e.preventDefault();
        this._startPinch(e);
        document.addEventListener('touchmove', this._onTouchMove = this._onTouchMove.bind(this), { passive: false });
        document.addEventListener('touchend', this._onTouchEnd = this._onTouchEnd.bind(this));
        document.addEventListener('touchcancel', this._onTouchEnd);
      }
      
      _startPinch(e) {
        this._map.stopAnimations();
        this._isPinching = true;
        
        const t1 = e.touches[0], t2 = e.touches[1];
        this._pinchStartDist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
        this._pinchStartAngle = Math.atan2(t2.clientY - t1.clientY, t2.clientX - t1.clientX);
        this._pinchStartZoom = this._map.getZoom();
        this._pinchStartBearing = this._map.getBearing();
        this._pinchStartTime = performance.now();
        this._pinchLastCenter = { x: (t1.clientX + t2.clientX) / 2, y: (t1.clientY + t2.clientY) / 2 };
        this._pinchAnchorLL = this._map.screenToLatLon(this._pinchLastCenter.x, this._pinchLastCenter.y, this._map.getZoom(), this._map.getBearing(), this._map.getCenter());
        this._pinchMoved = false;
      }
      
      _onTouchMove(e) {
        if (!this._isPinching || e.touches.length < 2) return;
        e.preventDefault();
        
        const t1 = e.touches[0], t2 = e.touches[1];
        const dist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
        const angle = Math.atan2(t2.clientY - t1.clientY, t2.clientX - t1.clientX);
        const center = { x: (t1.clientX + t2.clientX) / 2, y: (t1.clientY + t2.clientY) / 2 };
        
        const targetZoom = this._pinchStartZoom + Math.log2(dist / Math.max(1, this._pinchStartDist));
        const deltaAngle = normalizeAngle(angle - this._pinchStartAngle);
        const targetBearing = normalizeAngle(this._pinchStartBearing + deltaAngle);
        
        if (Math.abs(Math.log(dist / Math.max(1, this._pinchStartDist))) > Math.log(1 + TWO_FINGER_TAP_MOVE_THRESH / Math.max(1, this._pinchStartDist)) ||
          Math.abs(deltaAngle) > ROTATE_MOVE_THRESH_RAD) {
          this._pinchMoved = true;
        }
        
        this._map.applyZoomRotateAbout(center.x, center.y, targetZoom, targetBearing, this._pinchAnchorLL);
        this._pinchLastCenter = center;
        this._map.render();
      }
      
      _onTouchEnd(e) {
        if (!this._isPinching) return;
        
        const dt = performance.now() - this._pinchStartTime;
        if (dt <= TWO_FINGER_TAP_MAX_DELAY && !this._pinchMoved) {
          const ax = this._pinchLastCenter ? this._pinchLastCenter.x : (this._map.canvas.width / this._map.dpr) / 2;
          const ay = this._pinchLastCenter ? this._pinchLastCenter.y : (this._map.canvas.height / this._map.dpr) / 2;
          this._map.animateZoomRotateAbout(ax, ay, this._map.getZoom() - 1, this._map.getBearing(), TAP_ZOOM_DURATION);
        }
        
        this._isPinching = false;
        this._removeMoveEvents();
      }
    }
    
    /**
     * Keyboard pan handler for keyboard navigation
     */
    class KeyboardPanHandler extends Handler {
      constructor(map) {
        super(map);
        this._keyStates = new Set();
      }
      
      _addEvents() {
        window.addEventListener('keydown', this._onKeyDown = this._onKeyDown.bind(this));
        window.addEventListener('keyup', this._onKeyUp = this._onKeyUp.bind(this));
      }
      
      _removeEvents() {
        window.removeEventListener('keydown', this._onKeyDown);
        window.removeEventListener('keyup', this._onKeyUp);
        this._keyStates.clear();
      }
      
      _onKeyDown(e) {
        // Prevent repeated key events while holding down
        if (this._keyStates.has(e.key)) return;
        this._keyStates.add(e.key);
        
        let dx = 0, dy = 0;
        const step = 1;
        
        if (e.key === "ArrowUp") dy = step;
        else if (e.key === "ArrowDown") dy = -step;
        else if (e.key === "ArrowLeft") dx = -step;
        else if (e.key === "ArrowRight") dx = step;
        else if (e.key.toLowerCase() === "n") {
          const w = this._map.canvas.width / this._map.dpr, h = this._map.canvas.height / this._map.dpr;
          this._map.animateZoomRotateAbout(w / 2, h / 2, this._map.getZoom(), 0, SNAP_DURATION);
          return;
        } else if (e.key === "r") {
          this._map.setBearing(this._map.getBearing() + DEG2RAD * 15);
          return;
        } else if (e.key === "l") {
          this._map.setBearing(this._map.getBearing() - DEG2RAD * 15);
          return;
        } else if (e.key === "s") {
          const current = this._map.getBaseLayer();
          let newLayer;
          
          if (current && current.urlTemplate && current.urlTemplate.includes('arcgisonline')) {
            const subdomains = ['a', 'b', 'c'];
            const randomSubdomain = subdomains[Math.floor(Math.random() * subdomains.length)];
            newLayer = new TileLayer(
              `https://${randomSubdomain}.tile.openstreetmap.org/{z}/{x}/{y}.png`,
              { 
                minZoom: 0, 
                maxZoom: 19, 
                attribution: '© <a href="https://www.openstreetmap.org/copyright" target="_blank" rel="noopener noreferrer">OpenStreetMap contributors</a>', 
                background: "#e6e6e6", 
                supportsRetina: true, 
                maxCacheSize: 500 
              }
            );
          } else {
            newLayer = new TileLayer(
              "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
              { 
                minZoom: 0, 
                maxZoom: 19, 
                attribution: 'Tiles © <a href="https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer" target="_blank" rel="noopener noreferrer">Esri World Imagery</a>', 
                background: "#000000", 
                supportsRetina: false, 
                maxCacheSize: 400 
              }
            );
          }
          
          this._map.setBaseLayer(newLayer);
          return;
        } else if (e.key === "+" || e.key === "=") {
          this._map.stopAnimations();
          this._map.smoothZoomAt(window.innerWidth / 2, window.innerHeight / 2, WHEEL_ZOOM_STEP);
          return;
        } else if (e.key === "-") {
          this._map.stopAnimations();
          this._map.smoothZoomAt(window.innerWidth / 2, window.innerHeight / 2, -WHEEL_ZOOM_STEP);
          return;
        }
        
        if (dx !== 0 || dy !== 0) {
          this._map.stopAnimations();
          this._map.center = {
            lat: GISUtils.clampLatitude(this._map.getCenter().lat + dy),
            lon: GISUtils.wrapLongitude(this._map.getCenter().lon + dx)
          };
          this._map.render();
        }
      }
      
      _onKeyUp(e) {
        this._keyStates.delete(e.key);
      }
    }
    
    /**
     * Popup manager for handling popup interactions
     */
    class PopupManager {
      constructor(map) {
        if (!(map instanceof Atlas)) {
          throw new Error('PopupManager must be initialized with an Atlas instance');
        }
        
        this._map = map;
        this._openPopup = null;
        this._boundCloseOnEscape = this._closeOnEscape.bind(this);
        this._boundCloseOnClickOutside = this._closeOnClickOutside.bind(this);
        
        document.addEventListener('keydown', this._boundCloseOnEscape);
        document.addEventListener('click', this._boundCloseOnClickOutside);
      }
      
      _closeOnEscape(e) {
        if (e.key === 'Escape' && this._openPopup) {
          this._openPopup.close();
        }
      }
      
      _closeOnClickOutside(e) {
        if (!this._openPopup) return;
        
        // Check if click is on the popup or its anchor
        if (this._openPopup._popupElement?.contains(e.target)) return;
        if (this._openPopup._anchor instanceof AtlasMarker && this._openPopup._anchor._iconElement?.contains(e.target)) return;
        
        // Close popup if clicked outside
        this._openPopup.close();
      }
      
      setOpenPopup(popup) {
        if (this._openPopup === popup) return;
        if (this._openPopup) this._openPopup.close();
        this._openPopup = popup;
      }
      
      clearOpenPopup(popup) {
        if (this._openPopup === popup) this._openPopup = null;
      }
      
      destroy() {
        document.removeEventListener('keydown', this._boundCloseOnEscape);
        document.removeEventListener('click', this._boundCloseOnClickOutside);
        this._openPopup = null;
      }
    }
    
    /**
     * Base class for map overlays
     */
    class Overlay {
      constructor(options = {}) {
        this.options = options;
        this._map = null;
        this._events = {};
      }
      
      on(type, fn) {
        if (typeof type !== 'string') {
          throw new Error('Event type must be a string');
        }
        if (typeof fn !== 'function') {
          throw new Error('Event handler must be a function');
        }
        if (!this._events[type]) this._events[type] = [];
        this._events[type].push(fn);
        return this;
      }
      
      off(type, fn) {
        if (typeof type !== 'string') {
          throw new Error('Event type must be a string');
        }
        if (!this._events[type]) return this;
        if (!fn) this._events[type] = [];
        else this._events[type] = this._events[type].filter(cb => cb !== fn);
        return this;
      }
      
      fire(type, data = {}) {
        if (typeof type !== 'string') {
          throw new Error('Event type must be a string');
        }
        if (!this._events[type]) return;
        data.type = type;
        data.target = this;
        this._events[type].forEach(fn => {
          try {
            fn(data);
          } catch (error) {
            console.error(`Error in event handler for ${type}:`, error);
          }
        });
      }
      
      addTo(map) {
        if (!(map instanceof Atlas)) {
          throw new Error('addTo() argument must be an instance of Atlas');
        }
        
        if (this._map) this._map.removeOverlay(this);
        this._map = map;
        map.addOverlay(this);
        return this;
      }
      
      remove() {
        if (this._map) {
          this._map.removeOverlay(this);
          this._map = null;
        }
        return this;
      }
      
      onAdd() {}
      onRemove() {}
      render() {}
    }
    
    /**
     * Marker overlay for the map
     */
    class AtlasMarker extends Overlay {
      constructor(latlng, options = {}) {
        super(options);
        
        // Validate latlng
        if (!latlng || typeof latlng.lat !== 'number' || typeof latlng.lon !== 'number') {
          throw new Error('Marker requires latlng object with numeric lat and lon properties');
        }
        
        this._latlng = { ...latlng };
        this._iconElement = null;
        this._isHovered = false;
        this._isDragging = false;
        this._dragStart = null;
        this._popup = null;
        
        this.options = { 
          draggable: !!options.draggable, 
          riseOnHover: options.riseOnHover !== undefined ? options.riseOnHover : true, 
          riseOffset: typeof options.riseOffset === 'number' ? options.riseOffset : 250, 
          zIndexOffset: typeof options.zIndexOffset === 'number' ? options.zIndexOffset : 0, 
          ...options 
        };
      }
      
      onAdd() {
        this._iconElement = this._createIcon();
        this._map.container.appendChild(this._iconElement);
        
        this._iconElement.addEventListener('click', this._onClick.bind(this));
        this._iconElement.addEventListener('mouseenter', this._onMouseEnter.bind(this));
        this._iconElement.addEventListener('mouseleave', this._onMouseLeave.bind(this));
        
        if (this.options.draggable) {
          this._iconElement.addEventListener('mousedown', this._onMouseDown.bind(this));
          this._iconElement.addEventListener('touchstart', this._onTouchStart.bind(this), { passive: false });
        }
        
        this._updatePosition();
        this._updateZIndex();
      }
      
      onRemove() {
        if (this._popup) this._popup.remove();
        if (this._iconElement?.parentNode) this._iconElement.parentNode.removeChild(this._iconElement);
        this._iconElement = null;
        this._popup = null;
      }
      
      render() {
        if (this._iconElement) this._updatePosition();
      }
      
      _createIcon() {
        const el = document.createElement('div');
        el.className = 'atlas-marker';
        
        const shadow = document.createElement('div');
        shadow.className = 'atlas-marker-shadow';
        el.appendChild(shadow);
        
        const icon = document.createElement('div');
        icon.className = 'atlas-marker-icon';
        icon.innerHTML = this.options.html || `
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 36" width="24" height="36">
            <path d="M12 0C5.4 0 0 5.4 0 12c0 10.5 12 24 12 24s12-13.5 12-24C24 5.4 18.6 0 12 0zm0 16.5c-2.5 0-4.5-2-4.5-4.5S9.5 7.5 12 7.5s4.5 2 4.5 4.5-2 4.5-4.5 4.5z" fill="#ff7800" stroke="#fff" stroke-width="1.5"/>
          </svg>
        `;
        el.appendChild(icon);
        
        return el;
      }
      
      _updatePosition() {
        if (!this._iconElement || !this._map) return;
        
        const point = this._map.latLngToContainerPoint(this._latlng);
        this._iconElement.style.transform = `translate(${point.x}px, ${point.y}px) translate(-50%, -100%)`;
        
        if (this._isDragging) {
          const newLatLng = this._map.screenToLatLon(point.x, point.y);
          this._latlng = { 
            lat: GISUtils.clampLatitude(newLatLng.lat), 
            lon: GISUtils.wrapLongitude(newLatLng.lon) 
          };
          this.fire('drag', { latlng: { ...this._latlng } });
        }
      }
      
      _updateZIndex() {
        if (!this._iconElement) return;
        
        let baseZIndex = 1000;
        if (this._isHovered && this.options.riseOnHover) baseZIndex += this.options.riseOffset;
        baseZIndex += this.options.zIndexOffset;
        this._iconElement.style.zIndex = baseZIndex;
      }
      
      _onClick(e) {
        e.stopPropagation();
        this.fire('click', { originalEvent: e });
        
        if (this._popup) {
          if (this._popup._isOpen) this._popup.close();
          else this._popup.openOn(this);
        }
      }
      
      _onMouseEnter(e) {
        if (!this._isDragging) {
          this._isHovered = true;
          this._updateZIndex();
          this._iconElement.classList.add('hover');
          this.fire('mouseover', { originalEvent: e });
        }
      }
      
      _onMouseLeave(e) {
        this._isHovered = false;
        this._updateZIndex();
        this._iconElement.classList.remove('hover');
        this.fire('mouseout', { originalEvent: e });
      }
      
      _onMouseDown(e) {
        if (e.button !== 0) return;
        e.stopPropagation();
        this._startDrag(e.clientX, e.clientY);
        
        document.addEventListener('mousemove', this._onMouseMove = this._onMouseMove.bind(this));
        document.addEventListener('mouseup', this._onMouseUp = this._onMouseUp.bind(this));
      }
      
      _onTouchStart(e) {
        if (e.touches.length !== 1) return;
        e.stopPropagation();
        e.preventDefault();
        this._startDrag(e.touches[0].clientX, e.touches[0].clientY);
        
        document.addEventListener('touchmove', this._onTouchMove = this._onTouchMove.bind(this), { passive: false });
        document.addEventListener('touchend', this._onTouchEnd = this._onTouchEnd.bind(this));
        document.addEventListener('touchcancel', this._onTouchEnd);
      }
      
      _startDrag(clientX, clientY) {
        this._isDragging = true;
        this._map.stopAnimations();
        this._map.isDragging = true;
        this._map.container.classList.add('dragging');
        this._dragStart = { x: clientX, y: clientY, latlng: { ...this._latlng } };
        this._iconElement.classList.add('dragging');
        this.fire('dragstart');
      }
      
      _onMouseMove(e) {
        if (!this._isDragging) return;
        e.preventDefault();
        this.render();
        this._map.render();
      }
      
      _onTouchMove(e) {
        if (!this._isDragging || e.touches.length !== 1) return;
        e.preventDefault();
        this.render();
        this._map.render();
      }
      
      _onMouseUp() { 
        this._endDrag(); 
      }
      
      _onTouchEnd() { 
        this._endDrag(); 
      }
      
      _endDrag() {
        if (!this._isDragging) return;
        
        this._isDragging = false;
        this._map.isDragging = false;
        this._map.container.classList.remove('dragging');
        this._iconElement.classList.remove('dragging');
        
        document.removeEventListener('mousemove', this._onMouseMove);
        document.removeEventListener('mouseup', this._onMouseUp);
        document.removeEventListener('touchmove', this._onTouchMove);
        document.removeEventListener('touchend', this._onTouchEnd);
        document.removeEventListener('touchcancel', this._onTouchEnd);
        
        this.fire('dragend', { latlng: { ...this._latlng } });
      }
      
      setLatLng(latlng) {
        if (!latlng || typeof latlng.lat !== 'number' || typeof latlng.lon !== 'number') {
          throw new Error('setLatLng requires latlng object with numeric lat and lon properties');
        }
        
        this._latlng = { ...latlng };
        if (this._map) this._map.render();
        return this;
      }
      
      getLatLng() { return { ...this._latlng }; }
      
      bindPopup(content, options = {}) {
        if (this._popup) this._popup.remove();
        this._popup = new AtlasPopup(content, options);
        this._popup.addTo(this._map);
        return this;
      }
      
      unbindPopup() {
        if (this._popup) {
          this._popup.remove();
          this._popup = null;
        }
        return this;
      }
      
      togglePopup() {
        if (this._popup) {
          if (this._popup._isOpen) this._popup.close();
          else this._popup.openOn(this);
        }
        return this;
      }
      
      openPopup() {
        if (this._popup) this._popup.openOn(this);
        return this;
      }
      
      closePopup() {
        if (this._popup && this._popup._isOpen) this._popup.close();
        return this;
      }
    }
    
    /**
     * Popup overlay for the map
     */
    class AtlasPopup extends Overlay {
      constructor(content, options = {}) {
        super(options);
        this._content = content;
        this._popupElement = null;
        this._isOpen = false;
        this._anchor = null;
        this._tipElement = null;
        
        this.options = { 
          closeButton: options.closeButton !== undefined ? options.closeButton : true,
          autoClose: options.autoClose !== undefined ? options.autoClose : true,
          closeOnClick: options.closeOnClick !== undefined ? options.closeOnClick : true,
          className: typeof options.className === 'string' ? options.className : '',
          maxWidth: typeof options.maxWidth === 'number' ? Math.max(50, options.maxWidth) : 300,
          minWidth: typeof options.minWidth === 'number' ? Math.max(10, options.minWidth) : 50,
          ...options 
        };
      }
      
      onAdd() {
        this._popupElement = this._createPopupElement();
        this._map.container.appendChild(this._popupElement);
        
        if (this.options.closeButton) {
          const closeButton = this._popupElement.querySelector('.popup-close');
          if (closeButton) {
            closeButton.addEventListener('click', (e) => { 
              e.stopPropagation(); 
              this.close(); 
            });
          }
        }
        
        if (!this._map._popupManager) {
          this._map._popupManager = new PopupManager(this._map);
        }
      }
      
      onRemove() {
        if (this._popupElement?.parentNode) {
          this._popupElement.parentNode.removeChild(this._popupElement);
        }
        this._popupElement = null;
        this._tipElement = null;
        this._isOpen = false;
        
        if (this._map && this._map._popupManager) {
          this._map._popupManager.clearOpenPopup(this);
        }
      }
      
      render() {
        if (!this._isOpen || !this._popupElement) return;
        this._updatePosition();
      }
      
      _createPopupElement() {
        const el = document.createElement('div');
        el.className = 'atlas-popup' + (this.options.className ? ' ' + this.options.className : '');
        
        let closeButtonHtml = '';
        if (this.options.closeButton) {
          closeButtonHtml = `<button class="popup-close" aria-label="Close popup">&times;</button>`;
        }
        
        el.innerHTML = `<div class="popup-content">${this._content}</div>${closeButtonHtml}<div class="popup-tip"></div>`;
        this._tipElement = el.querySelector('.popup-tip');
        
        el.style.maxWidth = `${this.options.maxWidth}px`;
        el.style.minWidth = `${this.options.minWidth}px`;
        
        return el;
      }
      
      _updatePosition() {
        if (!this._anchor || !this._popupElement || !this._tipElement) return;
        
        let anchorPoint;
        if (this._anchor instanceof AtlasMarker && this._anchor._iconElement) {
          const rect = this._anchor._iconElement.getBoundingClientRect();
          const containerRect = this._map.container.getBoundingClientRect();
          anchorPoint = { 
            x: rect.left - containerRect.left + rect.width / 2, 
            y: rect.top - containerRect.top 
          };
        } else if (this._anchor && typeof this._anchor.lat === 'number') {
          const point = this._map.latLngToContainerPoint(this._anchor);
          anchorPoint = { x: point.x, y: point.y };
        } else {
          return;
        }
        
        const popupRect = this._popupElement.getBoundingClientRect();
        const mapRect = this._map.container.getBoundingClientRect();
        
        const space = {
          top: anchorPoint.y,
          right: mapRect.width - anchorPoint.x,
          bottom: mapRect.height - anchorPoint.y,
          left: anchorPoint.x
        };
        
        let position = 'bottom';
        let tipClass = 'tip-bottom';
        
        if (space.bottom < popupRect.height && space.top >= popupRect.height) {
          position = 'top';
          tipClass = 'tip-top';
        } else if (space.right < popupRect.width / 2 && space.left >= popupRect.width / 2) {
          position = 'left';
          tipClass = 'tip-left';
        } else if (space.left < popupRect.width / 2 && space.right >= popupRect.width / 2) {
          position = 'right';
          tipClass = 'tip-right';
        }
        
        let left, top;
        switch (position) {
          case 'top':
            left = anchorPoint.x - popupRect.width / 2;
            top = anchorPoint.y - popupRect.height;
            break;
          case 'bottom':
            left = anchorPoint.x - popupRect.width / 2;
            top = anchorPoint.y;
            break;
          case 'left':
            left = anchorPoint.x - popupRect.width;
            top = anchorPoint.y - popupRect.height / 2;
            break;
          case 'right':
            left = anchorPoint.x;
            top = anchorPoint.y - popupRect.height / 2;
            break;
        }
        
        left = Math.max(5, Math.min(mapRect.width - popupRect.width - 5, left));
        top = Math.max(5, Math.min(mapRect.height - popupRect.height - 5, top));
        
        this._popupElement.style.left = `${left}px`;
        this._popupElement.style.top = `${top}px`;
        this._popupElement.classList.add('open');
        this._tipElement.className = 'popup-tip ' + tipClass;
      }
      
      openOn(anchor) {
        if (!(anchor instanceof AtlasMarker) && 
            (!anchor || typeof anchor.lat !== 'number' || typeof anchor.lon !== 'number')) {
          throw new Error('openOn requires a valid anchor (AtlasMarker or latlng object)');
        }
        
        this._anchor = anchor;
        this._isOpen = true;
        
        if (this._map && this._map._popupManager) {
          this._map._popupManager.setOpenPopup(this);
        }
        
        if (this._map) {
          this._map.render();
        }
        
        this.fire('open');
        return this;
      }
      
      close() {
        this._isOpen = false;
        
        if (this._popupElement) {
          this._popupElement.classList.remove('open');
        }
        
        if (this._map && this._map._popupManager) {
          this._map._popupManager.clearOpenPopup(this);
        }
        
        if (this._map) {
          this._map.render();
        }
        
        this.fire('close');
        return this;
      }
      
      setContent(content) {
        this._content = content;
        if (this._popupElement) {
          this._popupElement.querySelector('.popup-content').innerHTML = content;
        }
        return this;
      }
    }
    
    /**
     * Main Atlas map class
     */
    class Atlas {
      constructor(id, options = {}) {
        // Merge options with defaults
        this.config = { ...DEFAULT_CONFIG, ...options };
        
        this.canvas = document.getElementById(id);
        if (!this.canvas) {
          throw new Error(`Canvas element with id '${id}' not found`);
        }
        
        this.ctx = this.canvas.getContext("2d");
        this.container = document.getElementById("map-container");
        if (!this.container) {
          throw new Error('Map container element not found');
        }
        
        // Initialize with config values
        this.center = { 
          lon: GISUtils.wrapLongitude(this.config.defaultCenter.lon), 
          lat: GISUtils.clampLatitude(this.config.defaultCenter.lat) 
        };
        this.zoom = this.config.defaultZoom;
        this.bearing = 0;
        this.renderScheduled = false;
        
        // Get UI elements
        this.zoomOverlay = document.getElementById("zoom-overlay");
        this.loadingEl = document.getElementById("loading");
        this.loadingCountEl = document.getElementById("loading-count");
        this.coordsEl = document.getElementById("coords");
        
        // Initialize state
        this._inertiaRAF = null;
        this._events = {};
        this._layers = [];
        this._baseLayer = null;
        this._controls = [];
        this._controlCorners = {};
        this._overlays = [];
        this._handlers = {};
        this._popupManager = null;
        this.projection = DEFAULT_PROJECTION;
        this.isDragging = false;
        
        // Add handlers
        this.addHandler('dragPan', DragPanHandler);
        this.addHandler('scrollZoom', ScrollZoomHandler);
        this.addHandler('doubleClickZoom', DoubleClickZoomHandler);
        this.addHandler('touchZoomRotate', TouchZoomRotateHandler);
        this.addHandler('keyboardPan', KeyboardPanHandler);
        
        // Set up resize handler
        this._resizeObserver = new ResizeObserver(() => {
          this.resize();
        });
        this._resizeObserver.observe(this.container);
        
        // Add controls
        this.addControl(new ZoomControl({ position: 'top-left' }));
        this.addControl(new LayerControl({ position: 'top-left' }));
        this.addControl(new FullscreenControl({ position: 'top-right' }));
        this.addControl(new ScaleControl({ position: 'bottom-right' }));
        this.addControl(new AttributionControl({ position: 'bottom-left' }));
        this.addControl(new CompassControl({ position: 'top-left' }));
        this.addControl(new ResetZoomControl({ position: 'top-left' }));
        
        // Initialize
        this.updateAttribution();
        this.resize();
        this.render();
        this.fire('load');
      }
      
      on(type, fn) {
        if (typeof type !== 'string') {
          throw new Error('Event type must be a string');
        }
        if (typeof fn !== 'function') {
          throw new Error('Event handler must be a function');
        }
        if (!this._events[type]) this._events[type] = [];
        this._events[type].push(fn);
        return this;
      }
      
      off(type, fn) {
        if (typeof type !== 'string') {
          throw new Error('Event type must be a string');
        }
        if (!this._events[type]) return this;
        if (!fn) this._events[type] = [];
        else this._events[type] = this._events[type].filter(cb => cb !== fn);
        return this;
      }
      
      fire(type, data = {}) {
        if (typeof type !== 'string') {
          throw new Error('Event type must be a string');
        }
        if (!this._events[type]) return;
        data.type = type;
        data.target = this;
        this._events[type].forEach(fn => {
          try {
            fn(data);
          } catch (error) {
            console.error(`Error in event handler for ${type}:`, error);
          }
        });
      }
      
      addLayer(layer) {
        if (!(layer instanceof Layer)) {
          throw new Error('Argument must be an instance of Layer');
        }
        
        if (!this._layers.includes(layer)) {
          this._layers.push(layer);
          layer._map = this;
          layer.onAdd();
          this.render();
          
          if (!this._baseLayer || (layer instanceof TileLayer && !this._baseLayer)) {
            this._baseLayer = layer;
            this.container.style.background = layer.getBackground();
          }
        }
        
        return this;
      }
      
      removeLayer(layer) {
        const index = this._layers.indexOf(layer);
        if (index !== -1) {
          this._layers.splice(index, 1);
          layer.onRemove();
          layer._map = null;
          
          if (this._baseLayer === layer) {
            this._baseLayer = this._layers.find(l => l instanceof TileLayer) || null;
            if (this._baseLayer) {
              this.container.style.background = this._baseLayer.getBackground();
            }
          }
          
          this.render();
        }
        
        return this;
      }
      
      setBaseLayer(newLayer) {
        if (!(newLayer instanceof TileLayer)) {
          throw new Error('Argument must be an instance of TileLayer');
        }
        
        if (this._baseLayer && this._baseLayer !== newLayer) {
          this.removeLayer(this._baseLayer);
        }
        
        if (!this._layers.includes(newLayer)) {
          this.addLayer(newLayer);
        } else {
          this._baseLayer = newLayer;
          this.container.style.background = newLayer.getBackground();
          this.zoom = Math.max(newLayer.getMinZoom(), Math.min(newLayer.getMaxZoom(), this.zoom));
          this.render();
        }
        
        return this;
      }
      
      getBaseLayer() { return this._baseLayer; }
      
      addControl(control) {
        if (!(control instanceof Control)) {
          throw new Error('Argument must be an instance of Control');
        }
        
        this._controls.push(control);
        control.addTo(this);
        return this;
      }
      
      removeControl(control) {
        const index = this._controls.indexOf(control);
        if (index !== -1) {
          this._controls.splice(index, 1);
          control.remove();
        }
        return this;
      }
      
      addHandler(name, HandlerClass) {
        if (typeof name !== 'string') {
          throw new Error('Handler name must be a string');
        }
        if (typeof HandlerClass !== 'function') {
          throw new Error('HandlerClass must be a constructor function');
        }
        
        if (this._handlers[name]) return this;
        
        try {
          this._handlers[name] = new HandlerClass(this);
          this._handlers[name].enable();
        } catch (error) {
          console.error(`Failed to initialize handler ${name}:`, error);
        }
        
        return this;
      }
      
      removeHandler(name) {
        if (typeof name !== 'string') {
          throw new Error('Handler name must be a string');
        }
        
        if (!this._handlers[name]) return this;
        
        this._handlers[name].destroy();
        delete this._handlers[name];
        return this;
      }
      
      getHandler(name) { 
        if (typeof name !== 'string') {
          throw new Error('Handler name must be a string');
        }
        return this._handlers[name] || null; 
      }
      
      addOverlay(overlay) {
        if (!(overlay instanceof Overlay)) {
          throw new Error('Argument must be an instance of Overlay');
        }
        
        if (!this._overlays.includes(overlay)) {
          this._overlays.push(overlay);
          overlay._map = this;
          overlay.onAdd();
          this.render();
        }
        
        return this;
      }
      
      removeOverlay(overlay) {
        const index = this._overlays.indexOf(overlay);
        if (index !== -1) {
          this._overlays.splice(index, 1);
          overlay.onRemove();
          overlay._map = null;
          this.render();
        }
        return this;
      }
      
      setZoom(z) {
        if (typeof z !== 'number') {
          throw new Error('Zoom must be a number');
        }
        
        const minZoom = this._baseLayer ? this._baseLayer.getMinZoom() : 0;
        const maxZoom = this._baseLayer ? this._baseLayer.getMaxZoom() : 18;
        const nz = Math.max(minZoom, Math.min(maxZoom, z));
        
        if (nz === this.zoom) return;
        
        this.zoom = nz;
        this.render();
        this.showZoomOverlay();
        this.updateControlsUI();
        this.fire('zoom');
      }
      
      setBearing(rad) {
        if (typeof rad !== 'number') {
          throw new Error('Bearing must be a number (radians)');
        }
        
        const nr = normalizeAngle(rad);
        if (Math.abs(nr - this.bearing) < 1e-6) return;
        
        this.bearing = nr;
        this.render();
        this.fire('rotate');
      }
      
      showZoomOverlay() {
        if (!this.zoomOverlay) return;
        
        this.zoomOverlay.textContent = `Zoom: ${this.zoom.toFixed(2)}`;
        this.zoomOverlay.style.opacity = 1;
        
        clearTimeout(this._zTimer);
        this._zTimer = setTimeout(() => {
          if (this.zoomOverlay) {
            this.zoomOverlay.style.opacity = 0;
          }
        }, 500);
      }
      
      stopInertia() {
        if (this._inertiaRAF) {
          cancelAnimationFrame(this._inertiaRAF);
          this._inertiaRAF = null;
        }
      }
      
      stopAnimations() {
        this.stopInertia();
        
        if (this._zoomAnim?.raf) {
          cancelAnimationFrame(this._zoomAnim.raf);
          this._zoomAnim = null;
        }
        
        if (this._flyAnim?.raf) {
          cancelAnimationFrame(this._flyAnim.raf);
          this._flyAnim = null;
        }
      }
      
      resize() {
        const w = this.container.offsetWidth, h = this.container.offsetHeight;
        this.dpr = window.devicePixelRatio || 1;
        
        this.canvas.width = w * this.dpr;
        this.canvas.height = h * this.dpr;
        this.canvas.style.width = w + "px";
        this.canvas.style.height = h + "px";
        
        this.ctx.setTransform(this.dpr, 0, 0, this.dpr, 0, 0);
        this.render();
        this.fire('resize');
      }
      
      scheduleRender() {
        if (this.renderScheduled) return;
        this.renderScheduled = true;
        
        requestAnimationFrame(() => {
          this.renderScheduled = false;
          this._draw();
        });
      }
      
      render() { 
        this.scheduleRender(); 
      }
      
      _draw() {
        const backgroundColor = this._baseLayer ? this._baseLayer.getBackground() : '#000';
        const w = this.canvas.width / this.dpr, h = this.canvas.height / this.dpr;
        
        // Clear canvas with background color
        this.ctx.fillStyle = backgroundColor;
        this.ctx.fillRect(0, 0, w, h);
        
        // Render layers
        for (const layer of this._layers) {
          try {
            layer.render();
          } catch (error) {
            console.error('Error rendering layer:', error);
          }
        }
        
        // Render overlays
        for (const overlay of this._overlays) {
          try {
            overlay.render();
          } catch (error) {
            console.error('Error rendering overlay:', error);
          }
        }
        
        // Update UI elements
        let loadingCount = 0;
        if (this._baseLayer && this._baseLayer instanceof TileLayer) {
          loadingCount = this._baseLayer.loadingTiles.size;
        }
        
        if (this.loadingEl) {
          this.loadingEl.classList.toggle("visible", loadingCount > 0);
        }
        
        if (this.loadingCountEl) {
          this.loadingCountEl.textContent = loadingCount;
        }
        
        if (this.coordsEl) {
          this.coordsEl.textContent = `${this.center.lat.toFixed(6)}°, ${this.center.lon.toFixed(6)}° | Z: ${this.zoom.toFixed(2)} | Bearing: ${(this.bearing * RAD2DEG).toFixed(1)}°`;
        }
        
        this.updateControlsUI();
        this.fire('moveend');
      }
      
      updateAttribution() {
        for (const control of this._controls) {
          if (control instanceof AttributionControl && typeof control._update === 'function') {
            try {
              control._update();
            } catch (error) {
              console.error('Error updating attribution:', error);
            }
          }
        }
      }
      
      updateControlsUI() {
        for (const control of this._controls) {
          if (typeof control._update === 'function') {
            try {
              control._update();
            } catch (error) {
              console.error('Error updating control UI:', error);
            }
          }
        }
      }
      
      getCenter() { return { ...this.center }; }
      getZoom() { return this.zoom; }
      getBearing() { return this.bearing; }
      
      screenToLatLon(ax, ay, zoom = this.zoom, bearing = this.bearing, center = this.center) {
        if (typeof ax !== 'number' || typeof ay !== 'number') {
          throw new Error('Screen coordinates must be numbers');
        }
        
        const w = this.canvas.width / this.dpr;
        const h = this.canvas.height / this.dpr;
        const zInt = Math.floor(zoom);
        const ts = TILE_SIZE * Math.pow(2, zoom - zInt);
        const ct = this.projection.latLngToTile(center, zInt);
        const anchorVec = { x: ax - w / 2, y: ay - h / 2 };
        const v = rot(anchorVec.x / ts, anchorVec.y / ts, -bearing);
        const tpt = { x: ct.x + v.x, y: ct.y + v.y };
        const ll = this.projection.tileToLatLng(tpt.x, tpt.y, zInt);
        
        return { 
          lon: GISUtils.wrapLongitude(ll.lon), 
          lat: GISUtils.clampLatitude(ll.lat) 
        };
      }
      
      latLngToContainerPoint(latlng) {
        if (!latlng || typeof latlng.lat !== 'number' || typeof latlng.lon !== 'number') {
          throw new Error('latlng must be an object with numeric lat and lon properties');
        }
        
        const w = this.canvas.width / this.dpr;
        const h = this.canvas.height / this.dpr;
        const zInt = Math.floor(this.zoom);
        const ts = TILE_SIZE * Math.pow(2, this.zoom - zInt);
        const ct = this.projection.latLngToTile(this.center, zInt);
        const pt = this.projection.latLngToTile(latlng, zInt);
        const trX = (pt.x - ct.x) * ts;
        const trY = (pt.y - ct.y) * ts;
        const anchorVec = rot(trX, trY, this.bearing);
        return { x: w / 2 + anchorVec.x, y: h / 2 + anchorVec.y };
      }
      
      applyZoomRotateAbout(ax, ay, newZoom, newBearing, anchorLL = null) {
        if (typeof ax !== 'number' || typeof ay !== 'number' || typeof newZoom !== 'number' || typeof newBearing !== 'number') {
          throw new Error('Parameters must be numbers');
        }
        
        const minZoom = this._baseLayer ? this._baseLayer.getMinZoom() : 0;
        const maxZoom = this._baseLayer ? this._baseLayer.getMaxZoom() : 18;
        newZoom = Math.max(minZoom, Math.min(maxZoom, newZoom));
        
        const w = this.canvas.width / this.dpr;
        const h = this.canvas.height / this.dpr;
        const anchorVec = { x: ax - w / 2, y: ay - h / 2 };
        const currAnchorLL = anchorLL || this.screenToLatLon(ax, ay, this.zoom, this.bearing, this.center);
        const zInt = Math.floor(newZoom);
        const ts = TILE_SIZE * Math.pow(2, newZoom - zInt);
        const Ptile = this.projection.latLngToTile(currAnchorLL, zInt);
        const v = rot(anchorVec.x / ts, anchorVec.y / ts, -newBearing);
        const ctNew = { x: Ptile.x - v.x, y: Ptile.y - v.y };
        const newCenter = this.projection.tileToLatLng(ctNew.x, ctNew.y, zInt);
        
        this.center = { 
          lon: GISUtils.wrapLongitude(newCenter.lon), 
          lat: GISUtils.clampLatitude(newCenter.lat) 
        };
        this.zoom = newZoom;
        this.bearing = normalizeAngle(newBearing);
      }
      
      animateZoomRotateAbout(ax, ay, toZoom, toBearing = this.bearing, duration = WHEEL_ZOOM_DURATION, easing = EASING.easeInOutCubic) {
        if (typeof ax !== 'number' || typeof ay !== 'number' || typeof toZoom !== 'number') {
          throw new Error('Parameters must be numbers');
        }
        
        if (typeof easing !== 'function') {
          throw new Error('Easing function must be a function');
        }
        
        this.stopAnimations();
        
        const startT = performance.now();
        const sZoom = this.zoom;
        const sBear = this.bearing;
        const deltaBear = normalizeAngle(toBearing - sBear);
        const anchorLL = this.screenToLatLon(ax, ay, this.zoom, this.bearing, this.center);
        
        const step = () => {
          const t = (performance.now() - startT) / Math.max(1, duration);
          const p = t >= 1 ? 1 : easing(Math.max(0, Math.min(1, t)));
          const z = sZoom + (toZoom - sZoom) * p;
          const b = sBear + deltaBear * p;
          
          this.applyZoomRotateAbout(ax, ay, z, b, anchorLL);
          this.render();
          
          if (t < 1) {
            this._zoomAnim = { raf: requestAnimationFrame(step) };
          } else {
            this._zoomAnim = null;
            this.updateControlsUI();
            this.fire('zoomend');
          }
        };
        
        this._zoomAnim = { raf: requestAnimationFrame(step) };
        this.fire('zoomstart');
      }
      
      smoothZoomAt(ax, ay, deltaZ) {
        if (typeof ax !== 'number' || typeof ay !== 'number' || typeof deltaZ !== 'number') {
          throw new Error('Parameters must be numbers');
        }
        
        const minZoom = this._baseLayer ? this._baseLayer.getMinZoom() : 0;
        const maxZoom = this._baseLayer ? this._baseLayer.getMaxZoom() : 18;
        const target = Math.max(minZoom, Math.min(maxZoom, this.zoom + deltaZ));
        
        this.animateZoomRotateAbout(ax, ay, target, this.bearing, WHEEL_ZOOM_DURATION, EASING.easeInOutCubic);
      }
      
      flyTo({ center = this.center, zoom = this.zoom, bearing = this.bearing, duration = FLYTO_DURATION, easing = EASING.easeInOutCubic } = {}) {
        if (!center || typeof center.lat !== 'number' || typeof center.lon !== 'number') {
          throw new Error('Center must be an object with numeric lat and lon properties');
        }
        
        if (typeof zoom !== 'number' || typeof bearing !== 'number' || typeof duration !== 'number') {
          throw new Error('Zoom, bearing, and duration must be numbers');
        }
        
        if (typeof easing !== 'function') {
          throw new Error('Easing function must be a function');
        }
        
        const minZoom = this._baseLayer ? this._baseLayer.getMinZoom() : 0;
        const maxZoom = this._baseLayer ? this._baseLayer.getMaxZoom() : 18;
        const targetZoom = Math.max(minZoom, Math.min(maxZoom, zoom));
        
        this.stopAnimations();
        
        const startT = performance.now();
        const sC = { ...this.center };
        const eC = { ...center };
        const dLon = wrapDeltaLon(eC.lon - sC.lon);
        const dLat = eC.lat - sC.lat;
        const sZ = this.zoom, eZ = targetZoom;
        const sB = this.bearing, dB = normalizeAngle(bearing - sB);
        
        const step = () => {
          const t = (performance.now() - startT) / Math.max(1, duration);
          const p = t >= 1 ? 1 : easing(Math.max(0, Math.min(1, t)));
          
          this.center = { 
            lon: GISUtils.wrapLongitude(sC.lon + dLon * p), 
            lat: GISUtils.clampLatitude(sC.lat + dLat * p) 
          };
          this.zoom = sZ + (eZ - sZ) * p;
          this.bearing = normalizeAngle(sB + dB * p);
          
          this.render();
          
          if (t < 1) {
            this._flyAnim = { raf: requestAnimationFrame(step) };
          } else {
            this._flyAnim = null;
            this.updateControlsUI();
            this.fire('moveend');
          }
        };
        
        this._flyAnim = { raf: requestAnimationFrame(step) };
        this.fire('movestart');
      }
      
      destroy() {
        this.stopAnimations();
        
        // Remove all layers
        for (const layer of [...this._layers]) {
          this.removeLayer(layer);
        }
        
        // Remove all controls
        for (const control of [...this._controls]) {
          this.removeControl(control);
        }
        
        // Remove control containers
        for (const corner in this._controlCorners) {
          const container = this._controlCorners[corner];
          if (container?.parentNode) {
            container.parentNode.removeChild(container);
          }
        }
        this._controlCorners = {};
        
        // Remove all handlers
        for (const name in this._handlers) {
          this.removeHandler(name);
        }
        
        // Remove all overlays
        for (const overlay of [...this._overlays]) {
          this.removeOverlay(overlay);
        }
        
        // Destroy popup manager
        if (this._popupManager) {
          this._popupManager.destroy();
          this._popupManager = null;
        }
        
        // Disconnect resize observer
        if (this._resizeObserver) {
          this._resizeObserver.disconnect();
          this._resizeObserver = null;
        }
        
        this.fire('unload');
      }
    }
    
    let atlasInstance = null;
    
    /**
     * Helper function to create the OSM layer
     */
    function createOSMLayer() {
      const subdomains = ['a', 'b', 'c'];
      const randomSubdomain = subdomains[Math.floor(Math.random() * subdomains.length)];
      return new TileLayer(
        `https://${randomSubdomain}.tile.openstreetmap.org/{z}/{x}/{y}.png`,
        {
          minZoom: 0,
          maxZoom: 19,
          attribution: '© <a href="https://www.openstreetmap.org/copyright" target="_blank" rel="noopener noreferrer">OpenStreetMap contributors</a>',
          background: "#e6e6e6",
          supportsRetina: true,
          maxCacheSize: 500
        }
      );
    }
    
    /**
     * Initialize the Atlas map
     */
    function initializeAtlas() {
      // Hardcoded coordinates for Tarfaya, Morocco
      const TARFAYA_LAT = 27.9275;
      const TARFAYA_LON = -12.9061;
      
      try {
        // Create the map instance with specific configuration
        atlasInstance = new Atlas("map", {
          defaultCenter: { lon: TARFAYA_LON, lat: TARFAYA_LAT },
          defaultZoom: 10
        });
        
        // Set the base layer to OSM
        const osmLayer = createOSMLayer();
        atlasInstance.setBaseLayer(osmLayer);
        
        // Create and add the marker at Tarfaya
        const tarfayaMarker = new AtlasMarker(
          { lat: TARFAYA_LAT, lon: TARFAYA_LON },
          { draggable: true }
        );
        
        tarfayaMarker.bindPopup(`
          <h3 style="margin:0 0 8px 0; font-size:16px;">Hello World!</h3>
          <p style="margin:0; font-size:14px;">Lat: ${TARFAYA_LAT.toFixed(6)}<br>Lon: ${TARFAYA_LON.toFixed(6)}</p>
          <p style="margin:8px 0 0 0; font-size:12px; color:#666;">Drag me around!</p>
        `);
        
        // Update popup content when marker is dragged
        tarfayaMarker.on('dragend', (e) => {
          const { lat, lon } = e.latlng;
          tarfayaMarker._popup.setContent(`
            <h3 style="margin:0 0 8px 0; font-size:16px;">Hello World!</h3>
            <p style="margin:0; font-size:14px;">Lat: ${lat.toFixed(6)}<br>Lon: ${lon.toFixed(6)}</p>
            <p style="margin:8px 0 0 0; font-size:12px; color:#666;">Drag me around!</p>
          `);
        });
        
        tarfayaMarker.addTo(atlasInstance);
        
        // Add event listeners for map interactions
        atlasInstance.on('moveend', () => {
          console.log('Map movement ended');
        });
        
        atlasInstance.on('zoom', () => {
          console.log('Map zoomed');
        });
        
        console.log('Atlas.js initialized successfully');
      } catch (error) {
        console.error('Failed to initialize Atlas.js:', error);
      }
    }
    
    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeAtlas);
    } else {
      initializeAtlas();
    }
    
    // Handle window resize
    window.addEventListener('resize', () => {
      if (atlasInstance) {
        atlasInstance.resize();
      }
    });
    
    // Handle page unload
    window.addEventListener('beforeunload', () => {
      if (atlasInstance) {
        atlasInstance.destroy();
      }
    });
  </script>
</body>
</html>
