<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="referrer" content="origin">
  <title>Atlas.js - Lightweight JavaScript Mapping Library</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      font-family: sans-serif;
    }
    #map-container {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000; /* Black background for satellite */
      touch-action: none;
      cursor: grab;
    }
    #map-container.dragging {
      cursor: grabbing;
    }
    #map {
      width: 100%;
      height: 100%;
      display: block;
    }
    .controls {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      flex-direction: column;
      gap: 5px;
      z-index: 10;
    }
    .control-btn {
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #ccc;
      font-size: 16px;
      padding: 4px 8px;
      cursor: pointer;
      border-radius: 3px;
      user-select: none;
    }
    .control-btn:hover {
      background: rgba(240, 240, 240, 0.9);
    }
    .control-btn:active {
      background: rgba(224, 224, 224, 0.9);
      transform: scale(0.95);
      transition: transform 0.05s;
    }
    .control-btn:focus {
      outline: 2px solid #0078A8;
      outline-offset: 2px;
    }
    .control-btn:disabled {
      background: rgba(245, 245, 245, 0.9);
      color: #aaa;
      cursor: not-allowed;
      transform: none;
      border-color: #ddd;
    }
    #loading {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.9);
      padding: 4px 8px;
      border-radius: 3px;
      font-size: 12px;
      display: none;
    }
    #loading.visible {
      display: block;
    }
    #coords {
      position: absolute;
      bottom: 25px;
      left: 5px;
      background: rgba(255, 255, 255, 0.7);
      font-size: 12px;
      padding: 2px 6px;
      border-radius: 2px;
    }
    #zoom-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.8);
      font-size: 20px;
      padding: 6px 12px;
      border-radius: 4px;
      opacity: 0;
      transition: opacity 0.25s;
      pointer-events: none;
    }
    .scale-bar-container {
      position: absolute;
      bottom: 5px;
      right: 10px;
      text-align: center;
      font-size: 11px;
      color: #fff; /* White text for satellite */
      cursor: pointer;
    }
    .scale-bar {
      height: 4px;
      background: #fff; /* White bar for satellite */
      margin-bottom: 2px;
    }
    #attribution {
      position: absolute;
      bottom: 5px;
      left: 10px;
      background: rgba(0, 0, 0, 0.5); /* Dark background for satellite */
      color: #fff; /* White text for satellite */
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: sans-serif;
    }
    #attribution a {
      text-decoration: none;
      color: #4d90fe; /* Light blue link for satellite */
    }
    #fullscreen {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #ccc;
      padding: 4px 8px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 16px;
    }
    @keyframes zoom-indicator {
      0% {
        transform: scale(0.2);
        opacity: 0.8;
      }
      100% {
        transform: scale(1.2);
        opacity: 0;
      }
    }

    /* --- NEW STYLES FOR MARKERS & POPUPS --- */
    .atlas-marker {
      position: absolute;
      width: 30px;
      height: 30px;
      margin-left: -15px; /* Center horizontally */
      margin-top: -30px; /* Anchor at bottom */
      cursor: pointer;
      z-index: 100;
      transition: transform 0.2s ease-out;
      user-select: none;
    }
    .atlas-marker:hover {
      transform: scale(1.1);
    }
    .atlas-marker:active {
      transform: scale(0.95);
    }
    .atlas-marker-icon {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
    .atlas-popup {
      position: absolute;
      min-width: 150px;
      max-width: 300px;
      background: white;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      padding: 8px;
      font-size: 14px;
      z-index: 200;
      pointer-events: auto;
      transform: translate(-50%, -100%);
      margin-top: -10px; /* Space between marker and popup */
    }
    .atlas-popup::before {
      content: '';
      position: absolute;
      top: 100%;
      left: 50%;
      margin-left: -8px;
      border: 8px solid transparent;
      border-top-color: white;
    }
    .atlas-popup::after {
      content: '';
      position: absolute;
      top: calc(100% + 1px);
      left: 50%;
      margin-left: -8px;
      border: 8px solid transparent;
      border-top-color: #ccc;
    }
    .atlas-popup-close {
      position: absolute;
      top: 4px;
      right: 4px;
      background: none;
      border: none;
      font-size: 16px;
      cursor: pointer;
      padding: 0;
      width: 20px;
      height: 20px;
      line-height: 20px;
      text-align: center;
    }
    .atlas-popup-close:hover {
      background: #f0f0f0;
      border-radius: 50%;
    }
    /* --- END NEW STYLES --- */

  </style>
</head>
<body>
  <div id="map-container">
    <canvas id="map"></canvas>
    <div class="controls">
      <button id="zoom-in" class="control-btn" aria-label="Zoom in">+</button>
      <button id="zoom-out" class="control-btn" aria-label="Zoom out">‚àí</button>
      <button id="layer-toggle" class="control-btn" aria-label="Toggle layer">üåê</button>
    </div>
    <button id="fullscreen" class="control-btn" aria-label="Toggle fullscreen">‚õ∂</button>
    <div id="loading">Loading: <span id="loading-count">0</span></div>
    <div id="zoom-overlay" aria-live="polite"></div>
    <div id="coords" aria-live="polite"></div>
    <div class="scale-bar-container">
      <div class="scale-bar"></div>
      <div id="scale-text"></div>
    </div>
    <div id="attribution">
      <!-- Attribution will be updated dynamically -->
    </div>
  </div>
  <script>
    // --- Constants ---
    const EARTH_RADIUS = 6378137;
    const EARTH_CIRCUMFERENCE = 2 * Math.PI * EARTH_RADIUS;
    const MAX_LATITUDE = 85.05112878;
    const MIN_LATITUDE = -85.05112878;
    const TILE_SIZE = 256;
    const TILE_BUFFER = 3;
    const TILE_TTL = 1000 * 60 * 60 * 24; // 24 hours
    const TILE_LOAD_TIMEOUT_MS = 10000; // 10 seconds timeout for tile loading
    const SCALE_BAR_TARGET_PX = 120;
    const INERTIA_DECEL = 0.0025;
    const INERTIA_STOP_SPEED = 0.02;
    const VELOCITY_WINDOW_MS = 120;
    const DOUBLE_TAP_MAX_DELAY = 300;
    const DOUBLE_TAP_MAX_MOVE = 16;
    const TWO_FINGER_TAP_MAX_DELAY = 250;
    const TWO_FINGER_TAP_MOVE_THRESH = 10;
    const ROTATE_MOVE_THRESH_RAD = 0.08;
    const WHEEL_ZOOM_STEP = 0.25;
    const WHEEL_ZOOM_DURATION = 220;
    const TAP_ZOOM_DURATION = 280;
    const SNAP_DURATION = 300;
    const FLYTO_DURATION = 800;
    // --- Layer Configuration ---
    /**
     * Configuration for available map layers.
     * @type {Object.<string, Object>}
     */
    const LAYERS = {
      OSM: {
        name: "OpenStreetMap",
        minZoom: 0,
        maxZoom: 19,
        tileServers: ["https://a.tile.openstreetmap.org", "https://b.tile.openstreetmap.org", "https://c.tile.openstreetmap.org"],
        attribution: '¬© <a href="https://www.openstreetmap.org/copyright" target="_blank" rel="noopener noreferrer">OpenStreetMap contributors</a>',
        background: "#e6e6e6",
        supportsRetina: true, // OSM supports retina tiles
        maxCacheSize: 500 // Configurable cache size for OSM
      },
      ESRI: {
        name: "Esri Satellite",
        minZoom: 0,
        maxZoom: 19,
        tileServers: ["https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile"],
        attribution: 'Tiles ¬© <a href="https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer" target="_blank" rel="noopener noreferrer">Esri World Imagery</a>',
        background: "#000000",
        supportsRetina: false, // Esri does not support retina tiles in this setup
        maxCacheSize: 400 // Configurable cache size for ESRI
      }
    };
    // --- Configuration ---
    const CONFIG = {
      defaultLayer: "OSM",
      defaultCenter: { lon: 0, lat: 0 },
      defaultZoom: 3,
      retina: "auto",
      retinaSuffix: "@2x"
    };
    // --- Easing Functions ---
    const EASING = {
      easeInOutCubic: t => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2,
      easeOutCubic: t => 1 - Math.pow(1 - t, 3),
      linear: t => t
    };
    const RAD2DEG = 180 / Math.PI;
    const DEG2RAD = Math.PI / 180;
    // --- Utility Functions ---
    function normalizeAngle(rad) {
      return Math.atan2(Math.sin(rad), Math.cos(rad));
    }
    function shortestAngleDiff(from, to) {
      return normalizeAngle(to - from);
    }
    function wrapDeltaLon(delta) {
      delta = ((delta + 180) % 360 + 360) % 360 - 180;
      return delta;
    }
    function rot(x, y, ang) {
      const c = Math.cos(ang), s = Math.sin(ang);
      return { x: x * c - y * s, y: x * s + y * c };
    }
    // --- GIS Utility Class ---
    class GISUtils {
      static toRadians(d) { return d * Math.PI / 180; }
      static toDegrees(r) { return r * 180 / Math.PI; }
      static wrapLongitude(l) {
        while (l > 180) l -= 360;
        while (l < -180) l += 360;
        return l;
      }
      static clampLatitude(lat) {
        return Math.max(MIN_LATITUDE, Math.min(MAX_LATITUDE, lat));
      }
      static getResolution(lat, z) {
        return (EARTH_CIRCUMFERENCE * Math.cos(this.toRadians(lat))) / (Math.pow(2, z) * TILE_SIZE);
      }
      static formatDistance(m) {
        return m < 1000 ? Math.round(m) + " m" : (m / 1000).toFixed(1) + " km";
      }
      static tileToLonLat(x, y, z) {
        const scale = Math.pow(2, z);
        const lon = x / scale * 360 - 180;
        const n = Math.PI - 2 * Math.PI * y / scale;
        const lat = this.toDegrees(Math.atan(Math.sinh(n)));
        return { lon, lat };
      }
    }

    // --- NEW: Marker Class ---
    class AtlasMarker {
      /**
       * Creates a new marker.
       * @param {Object} options - Marker configuration.
       * @param {Object} options.latLng - { lat, lon } coordinates.
       * @param {string} [options.iconUrl='https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png'] - URL for the marker icon.
       * @param {string} [options.title=''] - Title/tooltip text.
       * @param {boolean} [options.draggable=false] - Whether the marker is draggable.
       */
      constructor(options = {}) {
        this.latLng = { ...options.latLng };
        this.iconUrl = options.iconUrl || 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png';
        this.title = options.title || '';
        this.draggable = options.draggable || false;
        this._element = null;
        this._popup = null;
        this._map = null;
        this._isDragging = false;
        this._dragStartOffset = { x: 0, y: 0 };
        this._eventListeners = {
          mousedown: null,
          touchstart: null,
          mousemove: null,
          touchmove: null,
          mouseup: null,
          touchend: null,
          touchcancel: null
        };
      }

      /**
       * Sets the marker's position.
       * @param {Object} latLng - { lat, lon } coordinates.
       */
      setLatLng(latLng) {
        this.latLng = { ...latLng };
        if (this._map) {
          this._updatePosition();
        }
      }

      /**
       * Gets the marker's position.
       * @returns {Object} - { lat, lon } coordinates.
       */
      getLatLng() {
        return { ...this.latLng };
      }

      /**
       * Binds a popup to the marker.
       * @param {string|HTMLElement} content - The content for the popup.
       * @param {Object} [options={}] - Popup options.
       * @returns {AtlasMarker} - Returns self for chaining.
       */
      bindPopup(content, options = {}) {
        if (this._popup) {
          this._popup.destroy();
        }
        this._popup = new AtlasPopup(content, options);
        this._popup._marker = this; // Create a back-reference
        if (this._element) {
          this._element.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent map click
            this._popup.openOn(this._map, this.latLng);
          });
        }
        return this;
      }

      /**
       * Opens the bound popup.
       * @returns {AtlasMarker} - Returns self for chaining.
       */
      openPopup() {
        if (this._popup && this._map) {
          this._popup.openOn(this._map, this.latLng);
        }
        return this;
      }

      /**
       * Closes the bound popup.
       * @returns {AtlasMarker} - Returns self for chaining.
       */
      closePopup() {
        if (this._popup) {
          this._popup.close();
        }
        return this;
      }

      /**
       * Adds the marker to a map.
       * @param {Atlas} map - The Atlas map instance.
       */
      addTo(map) {
        this._map = map;
        this._createDOMElement();
        this._updatePosition();
        if (this.draggable) {
          this._setupDragListeners();
        }
      }

      /**
       * Removes the marker from the map.
       */
      remove() {
        if (this._element && this._element.parentNode) {
          this._element.parentNode.removeChild(this._element);
        }
        this._removeDragListeners();
        this._map = null;
        this._element = null;
      }

      _createDOMElement() {
        if (this._element) return;

        const el = document.createElement('div');
        el.className = 'atlas-marker';
        el.title = this.title;

        const img = document.createElement('img');
        img.className = 'atlas-marker-icon';
        img.src = this.iconUrl;
        img.alt = this.title || 'Marker';
        img.draggable = false; // Prevent image drag

        el.appendChild(img);
        this._element = el;

        // If a popup is bound, set up the click listener
        if (this._popup) {
          el.addEventListener('click', (e) => {
            e.stopPropagation();
            this._popup.openOn(this._map, this.latLng);
          });
        }

        this._map.container.appendChild(el);
      }

      _updatePosition() {
        if (!this._map || !this._element) return;

        const w = this._map.canvas.width / this._map.dpr;
        const h = this._map.canvas.height / this._map.dpr;
        const zInt = Math.floor(this._map.zoom);
        const ts = TILE_SIZE * Math.pow(2, this._map.zoom - zInt);
        const ct = this._map.lonLatToTile(this._map.center.lon, this._map.center.lat, zInt);
        const pt = this._map.lonLatToTile(this.latLng.lon, this.latLng.lat, zInt);

        const trX = (pt.x - ct.x) * ts;
        const trY = (pt.y - ct.y) * ts;

        const anchorVec = rot(trX, trY, this._map.bearing);
        const screenX = w / 2 + anchorVec.x;
        const screenY = h / 2 + anchorVec.y;

        this._element.style.left = `${screenX}px`;
        this._element.style.top = `${screenY}px`;
      }

      _setupDragListeners() {
        const onDown = (e) => {
          e.stopPropagation(); // Prevent map panning
          this._isDragging = true;
          const clientX = e.clientX || e.touches[0].clientX;
          const clientY = e.clientY || e.touches[0].clientY;
          const rect = this._element.getBoundingClientRect();
          this._dragStartOffset.x = clientX - rect.left;
          this._dragStartOffset.y = clientY - rect.top;
          this._map.stopAnimations(); // Stop any map animations
          this._map.isDragging = false; // Temporarily disable map dragging
        };

        const onMove = (e) => {
          if (!this._isDragging) return;
          e.preventDefault();
          e.stopPropagation();
          const clientX = e.clientX || e.touches[0].clientX;
          const clientY = e.clientY || e.touches[0].clientY;
          const newX = clientX - this._dragStartOffset.x;
          const newY = clientY - this._dragStartOffset.y;
          this._element.style.left = `${newX}px`;
          this._element.style.top = `${newY}px`;
        };

        const onUp = (e) => {
          if (!this._isDragging) return;
          this._isDragging = false;
          this._map.isDragging = true; // Re-enable map dragging

          // Convert screen position back to lat/lng
          const rect = this._element.getBoundingClientRect();
          const screenX = rect.left + rect.width / 2;
          const screenY = rect.top + rect.height; // Anchor point is bottom center
          const newLatLng = this._map.screenToLatLon(screenX, screenY);
          this.setLatLng(newLatLng);

          // Update popup position if open
          if (this._popup && this._popup._isOpen) {
            this._popup._updatePosition();
          }
        };

        this._eventListeners.mousedown = (e) => onDown(e);
        this._eventListeners.touchstart = (e) => {
          if (e.touches.length === 1) onDown(e);
        };
        this._eventListeners.mousemove = onMove;
        this._eventListeners.touchmove = onMove;
        this._eventListeners.mouseup = onUp;
        this._eventListeners.touchend = onUp;
        this._eventListeners.touchcancel = onUp;

        this._element.addEventListener('mousedown', this._eventListeners.mousedown);
        this._element.addEventListener('touchstart', this._eventListeners.touchstart, { passive: false });
        window.addEventListener('mousemove', this._eventListeners.mousemove);
        window.addEventListener('touchmove', this._eventListeners.touchmove, { passive: false });
        window.addEventListener('mouseup', this._eventListeners.mouseup);
        window.addEventListener('touchend', this._eventListeners.touchend);
        window.addEventListener('touchcancel', this._eventListeners.touchcancel);
      }

      _removeDragListeners() {
        if (!this._element) return;

        if (this._eventListeners.mousedown) {
          this._element.removeEventListener('mousedown', this._eventListeners.mousedown);
        }
        if (this._eventListeners.touchstart) {
          this._element.removeEventListener('touchstart', this._eventListeners.touchstart);
        }
        window.removeEventListener('mousemove', this._eventListeners.mousemove);
        window.removeEventListener('touchmove', this._eventListeners.touchmove);
        window.removeEventListener('mouseup', this._eventListeners.mouseup);
        window.removeEventListener('touchend', this._eventListeners.touchend);
        window.removeEventListener('touchcancel', this._eventListeners.touchcancel);

        this._eventListeners = {
          mousedown: null,
          touchstart: null,
          mousemove: null,
          touchmove: null,
          mouseup: null,
          touchend: null,
          touchcancel: null
        };
      }
    }

    // --- NEW: Popup Class ---
    class AtlasPopup {
      /**
       * Creates a new popup.
       * @param {string|HTMLElement} content - The content for the popup.
       * @param {Object} [options={}] - Popup options.
       * @param {boolean} [options.closeButton=true] - Whether to show a close button.
       * @param {string} [options.className=''] - Additional CSS class for the popup.
       */
      constructor(content, options = {}) {
        this.content = content;
        this.options = {
          closeButton: options.closeButton !== undefined ? options.closeButton : true,
          className: options.className || ''
        };
        this._element = null;
        this._map = null;
        this._latLng = null;
        this._isOpen = false;
        this._eventListeners = {
          closeClick: null
        };
      }

      /**
       * Opens the popup on a map at a specific location.
       * @param {Atlas} map - The Atlas map instance.
       * @param {Object} latLng - { lat, lon } coordinates.
       */
      openOn(map, latLng) {
        this._map = map;
        this._latLng = { ...latLng };
        this._createDOMElement();
        this._updatePosition();
        this._isOpen = true;

        // Close any other open popups on this map
        if (this._map._openPopup && this._map._openPopup !== this) {
          this._map._openPopup.close();
        }
        this._map._openPopup = this;
      }

      /**
       * Closes the popup.
       */
      close() {
        if (this._element && this._element.parentNode) {
          this._element.parentNode.removeChild(this._element);
        }
        if (this._map && this._map._openPopup === this) {
          this._map._openPopup = null;
        }
        this._isOpen = false;
      }

      /**
       * Updates the popup's position based on its lat/lng.
       */
      _updatePosition() {
        if (!this._map || !this._element || !this._latLng) return;

        const w = this._map.canvas.width / this._map.dpr;
        const h = this._map.canvas.height / this._map.dpr;
        const zInt = Math.floor(this._map.zoom);
        const ts = TILE_SIZE * Math.pow(2, this._map.zoom - zInt);
        const ct = this._map.lonLatToTile(this._map.center.lon, this._map.center.lat, zInt);
        const pt = this._map.lonLatToTile(this._latLng.lon, this._latLng.lat, zInt);

        const trX = (pt.x - ct.x) * ts;
        const trY = (pt.y - ct.y) * ts;

        const anchorVec = rot(trX, trY, this._map.bearing);
        const screenX = w / 2 + anchorVec.x;
        const screenY = h / 2 + anchorVec.y;

        this._element.style.left = `${screenX}px`;
        this._element.style.top = `${screenY}px`;
      }

      _createDOMElement() {
        if (this._element) return;

        const el = document.createElement('div');
        el.className = 'atlas-popup';
        if (this.options.className) {
          el.classList.add(this.options.className);
        }

        if (this.options.closeButton) {
          const closeBtn = document.createElement('button');
          closeBtn.className = 'atlas-popup-close';
          closeBtn.innerHTML = '&times;';
          closeBtn.setAttribute('aria-label', 'Close popup');
          this._eventListeners.closeClick = () => {
            this.close();
          };
          closeBtn.addEventListener('click', this._eventListeners.closeClick);
          el.appendChild(closeBtn);
        }

        if (typeof this.content === 'string') {
          el.innerHTML = this.content;
        } else if (this.content instanceof HTMLElement) {
          el.appendChild(this.content);
        }

        this._element = el;
        this._map.container.appendChild(el);
      }

      /**
       * Destroys the popup, removing it from the DOM and cleaning up listeners.
       */
      destroy() {
        this.close();
        if (this._eventListeners.closeClick) {
          const closeBtn = this._element?.querySelector('.atlas-popup-close');
          if (closeBtn) {
            closeBtn.removeEventListener('click', this._eventListeners.closeClick);
          }
        }
        this._eventListeners = {
          closeClick: null
        };
      }
    }

    // --- Main Atlas Class ---
    class Atlas {
      /**
       * Creates a new Atlas map instance.
       * @param {string} id - The ID of the canvas element.
       * @param {Object} [options={}] - Optional configuration overrides.
       */
      constructor(id, options = {}) {
        Object.assign(CONFIG, options);
        this.canvas = document.getElementById(id);
        this.ctx = this.canvas.getContext("2d");
        this.container = document.getElementById("map-container");
        this.tileCache = new Map();
        this.loadingTiles = new Set();
        this.loadingControllers = new Map();
        this.currentLayer = CONFIG.defaultLayer;
        this.layerConfig = LAYERS[this.currentLayer];
        this.center = {
          lon: GISUtils.wrapLongitude(CONFIG.defaultCenter.lon),
          lat: GISUtils.clampLatitude(CONFIG.defaultCenter.lat)
        };
        this.zoom = CONFIG.defaultZoom;
        this.bearing = 0;
        this.isDragging = false;
        this.dragStart = null;
        this.renderScheduled = false;
        this.zoomOverlay = document.getElementById("zoom-overlay");
        this.loadingEl = document.getElementById("loading");
        this.loadingCountEl = document.getElementById("loading-count");
        this.coordsEl = document.getElementById("coords");
        this.scaleBarEl = document.querySelector(".scale-bar");
        this.scaleTextEl = document.getElementById("scale-text");
        this.attributionEl = document.getElementById("attribution");
        this._retinaAvailable = true;
        this._inertiaRAF = null;
        this._moveSamples = [];
        this.isPinching = false;
        this.pinchStartDist = 0;
        this.pinchStartAngle = 0;
        this.pinchStartZoom = this.zoom;
        this.pinchStartBearing = this.bearing;
        this.pinchStartTime = 0;
        this.pinchLastCenter = null;
        this._pinchMoved = false;
        this._pinchAnchorLL = null;
        // Removed this._pinchAnchorVec as it seemed unused
        this._lastTapTime = 0;
        this._lastTapPos = { x: 0, y: 0 };
        this._singleTouchStart = null;
        this._singleTouchMoved = false;
        this._zoomAnim = null;
        this._flyAnim = null;
        this._zoomIndicator = null;
        this._eventListeners = {
            resize: null,
            mousedown: null,
            mousemove: null,
            mouseup: null,
            wheel: null,
            dblclick: null,
            keydown: null,
            touchstart: null,
            touchmove: null,
            touchend: null,
            touchcancel: null,
            fullscreenClick: null,
            layerToggleClick: null
        };
        // --- NEW: Marker & Popup Management ---
        this._markers = [];
        this._openPopup = null;
        // --- END NEW ---

        console.warn(
          `%c[Atlas] You are using map tiles.
%cPlease comply with the respective tile usage policies.
%c- OpenStreetMap: https://operations.osmfoundation.org/policies/tiles/
%c- Esri: https://www.esri.com/en-us/legal/terms/full-master-agreement`,
          "font-weight:bold;color:#e74c3c;",
          "color:#3498db;",
          "color:#2ecc71;",
          "color:#f39c12;"
        );
        this.resize();
        this.setupEvents();
        this.initControls();
        this.updateAttribution();
        this.render();
        this.updateControlsUI();
      }
      resize() {
        const w = this.container.offsetWidth, h = this.container.offsetHeight;
        this.dpr = window.devicePixelRatio || 1;
        this.canvas.width = w * this.dpr;
        this.canvas.height = h * this.dpr;
        this.canvas.style.width = w + "px";
        this.canvas.style.height = h + "px";
        this.ctx.setTransform(this.dpr, 0, 0, this.dpr, 0, 0);
        this.render();
      }
      getCurrentLayerConfig() {
        return this.layerConfig;
      }
      switchLayer(layerName) {
        if (LAYERS[layerName] && layerName !== this.currentLayer) {
          this.abortAllLoadingTiles();
          this.currentLayer = layerName;
          this.layerConfig = LAYERS[this.currentLayer];
          this.container.style.background = this.layerConfig.background;
          this.updateAttribution();
          this.tileCache.clear();
          this.loadingTiles.clear();
          this.zoom = Math.max(this.layerConfig.minZoom, Math.min(this.layerConfig.maxZoom, this.zoom));
          this.render();
          this.updateControlsUI();
        }
      }
      abortAllLoadingTiles() {
        for (const [key, controller] of this.loadingControllers.entries()) {
          controller.abort();
          this.loadingTiles.delete(key);
          this.loadingControllers.delete(key);
        }
      }
      lonLatToTile(lon, lat, z) {
        lat = GISUtils.clampLatitude(lat);
        lon = GISUtils.wrapLongitude(lon);
        const scale = Math.pow(2, z);
        const x = (lon + 180) / 360 * scale;
        const y = (1 - Math.log(Math.tan(GISUtils.toRadians(lat)) + 1 / Math.cos(GISUtils.toRadians(lat))) / Math.PI) / 2 * scale;
        return { x, y };
      }
      shouldRequestRetina() {
        const mode = CONFIG.retina;
        const want = (mode === true) || (mode === "auto" && (window.devicePixelRatio || 1) > 1.5);
        return want && this._retinaAvailable;
      }
      /**
       * Gets the URL for a specific tile.
       * @param {number} x - Tile X coordinate.
       * @param {number} y - Tile Y coordinate.
       * @param {number} z - Tile Z coordinate (zoom level).
       * @returns {string} The URL for the tile.
       */
      getTileUrl(x, y, z) {
        const layerConfig = this.getCurrentLayerConfig();
        const scale = Math.pow(2, z);
        // Normalize tile coordinates (common logic)
        const intX = Math.floor((x % scale) + scale) % scale;
        const intY = Math.max(0, Math.min(scale - 1, Math.floor(y)));
        // Randomly select a tile server for load balancing
        const serverIndex = Math.floor(Math.random() * layerConfig.tileServers.length);
        let baseUrl = layerConfig.tileServers[serverIndex];
        let url;
        if (this.currentLayer === "ESRI") {
          // Esri URL format: {baseUrl}/{z}/{y}/{x}
          url = `${baseUrl}/${z}/${intY}/${intX}`;
        } else {
          // OSM URL format: {baseUrl}/{z}/{x}/{y}.png
          url = `${baseUrl}/${z}/${intX}/${intY}.png`;
        }
        // Add retina suffix based on layer configuration
        if (layerConfig.supportsRetina && this.shouldRequestRetina()) {
            url += CONFIG.retinaSuffix;
        }
        return url;
      }
      /**
       * Loads a tile image.
       * @param {string} key - The cache key for the tile.
       * @param {string} url - The URL of the tile image.
       * @returns {Promise<Object>} A promise resolving to the tile object.
       */
      async loadTile(key, url) {
        if (this.tileCache.has(key)) return this.tileCache.get(key);
        const controller = new AbortController();
        const signal = controller.signal;
        this.loadingControllers.set(key, controller);
        const img = new Image();
        img.crossOrigin = "anonymous";
        const tile = { img, loaded: false, loadedAt: Date.now(), lastUsed: Date.now(), controller };
        this.tileCache.set(key, tile);
        this.loadingTiles.add(key);
        const start = performance.now();
        // Promise to handle load/error events
        const loadPromise = new Promise((resolve, reject) => {
            img.onload = () => {
                const loadTime = performance.now() - start;
                console.log(`Tile ${key} loaded in ${loadTime.toFixed(2)}ms`);
                tile.loaded = true;
                tile.loadedAt = Date.now();
                this.loadingTiles.delete(key);
                this.loadingControllers.delete(key);
                this.scheduleRender();
                resolve(tile);
            };
            img.onerror = (e) => {
                if (signal.aborted) return;
                console.warn(`Failed to load tile: ${url}`, e);
                // Handle retina fallback only for layers that support it
                if (this.getCurrentLayerConfig().supportsRetina && url.includes(CONFIG.retinaSuffix)) {
                    this._retinaAvailable = false;
                    const nonRetinaUrl = url.replace(CONFIG.retinaSuffix, "");
                    img.src = nonRetinaUrl; // Retry with non-retina URL
                    return; // Don't reject yet, wait for the retry
                }
                this.loadingTiles.delete(key);
                this.loadingControllers.delete(key);
                this.loadingEl.textContent = "Failed to load some tiles";
                this.loadingEl.classList.add("visible");
                setTimeout(() => {
                    if (!this.loadingTiles.size) this.loadingEl.classList.remove("visible");
                }, 2000);
                reject(e);
            };
            img.src = url;
        });
        // Set timeout for the loading process
        const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => {
                // If still loading, consider it failed
                if (this.loadingTiles.has(key)) {
                    controller.abort();
                    console.warn(`Tile load timeout for: ${url}`);
                    this.loadingTiles.delete(key);
                    this.loadingControllers.delete(key);
                    // Optionally remove from cache if it was added
                    if (this.tileCache.has(key)) {
                        this.tileCache.delete(key);
                    }
                    reject(new Error(`Timeout loading tile: ${url}`));
                }
            }, TILE_LOAD_TIMEOUT_MS);
        });
        // Race the load promise against the timeout
        try {
            await Promise.race([loadPromise, timeoutPromise]);
        } catch (error) {
            if (!signal.aborted) {
                // Error already handled in onerror or timeout, but we can log if needed
                console.error("Tile loading failed or timed out:", error.message);
            }
        }
        return tile;
      }
      /**
       * Reloads a tile, bypassing the cache.
       * Uses requestIdleCallback for scheduling.
       * @param {string} key - The cache key for the tile.
       * @param {string} url - The URL of the tile image.
       */
      reloadTile(key, url) {
        const existing = this.tileCache.get(key);
        if (!existing) return;
        const token = key + "#r";
        if (this.loadingTiles.has(token)) return;
        const doReload = () => {
            const controller = new AbortController();
            const img = new Image();
            img.crossOrigin = "anonymous";
            this.loadingTiles.add(token);
            img.onload = () => {
                existing.img = img;
                existing.loaded = true;
                existing.loadedAt = Date.now();
                this.loadingTiles.delete(token);
                this.scheduleRender();
            };
            img.onerror = () => {
                this.loadingTiles.delete(token);
            };
            // Add cache-busting parameter
            img.src = url + (url.includes("?") ? "&" : "?") + "v=" + Date.now();
        };
        // Schedule reload during idle time
        if ('requestIdleCallback' in window) {
            requestIdleCallback(doReload);
        } else {
            setTimeout(doReload, 100); // Fallback
        }
      }
      evict() {
        const layerConfig = this.getCurrentLayerConfig();
        // Use the configured maxCacheSize from the layer
        if (this.tileCache.size <= (layerConfig.maxCacheSize || 0)) return;
        if ('requestIdleCallback' in window) {
          requestIdleCallback(() => this._performEviction());
        } else {
          setTimeout(() => this._performEviction(), 100);
        }
      }
      _performEviction() {
        const layerConfig = this.getCurrentLayerConfig();
        // Use the configured maxCacheSize from the layer, fallback to a default if somehow still missing
        const maxCacheSize = layerConfig.maxCacheSize || 800;
        if (this.tileCache.size <= maxCacheSize) return;
        const entries = Array.from(this.tileCache.entries());
        entries.sort((a, b) => a[1].lastUsed - b[1].lastUsed);
        const removeCount = this.tileCache.size - maxCacheSize;
        for (let i = 0; i < removeCount; i++) {
          this.tileCache.delete(entries[i][0]);
        }
      }
      scheduleRender() {
        if (this.renderScheduled) return;
        this.renderScheduled = true;
        requestAnimationFrame(() => {
          this.renderScheduled = false;
          this._draw();
        });
      }
      render() {
        this.scheduleRender();
      }
      preloadAdjacentZoomTiles() {
        const layerConfig = this.getCurrentLayerConfig();
        const zInt = Math.floor(this.zoom);
        const nextZoom = Math.min(layerConfig.maxZoom, zInt + 1);
        const prevZoom = Math.max(layerConfig.minZoom, zInt - 1);
        if (Math.abs(this.zoom - zInt) > 0.3) return;
        const ct = this.lonLatToTile(this.center.lon, this.center.lat, zInt);
        const ts = TILE_SIZE;
        const w = this.canvas.width / this.dpr;
        const h = this.canvas.height / this.dpr;
        const viewportTiles = Math.ceil(Math.max(w, h) / ts) + TILE_BUFFER;
        for (let dz of [prevZoom, nextZoom]) {
          if (dz === zInt) continue;
          const scaleDiff = Math.pow(2, Math.abs(dz - zInt));
          const startX = Math.floor(ct.x * (dz > zInt ? scaleDiff : 1 / scaleDiff) - viewportTiles / 2);
          const startY = Math.floor(ct.y * (dz > zInt ? scaleDiff : 1 / scaleDiff) - viewportTiles / 2);
          for (let dx = 0; dx < viewportTiles; dx++) {
            for (let dy = 0; dy < viewportTiles; dy++) {
              const X = startX + dx, Y = startY + dy;
              const key = `${this.currentLayer}_${dz}/${X}/${Y}`;
              if (!this.tileCache.has(key) && !this.loadingTiles.has(key)) {
                const url = this.getTileUrl(X, Y, dz);
                this.loadTile(key, url);
              }
            }
          }
        }
      }
      _snapCanvasToPixelGrid() {
        const currentTransform = this.ctx.getTransform();
        const physicalTranslateX = currentTransform.e * this.dpr;
        const physicalTranslateY = currentTransform.f * this.dpr;
        const snapX = - (physicalTranslateX % 1) / this.dpr;
        const snapY = - (physicalTranslateY % 1) / this.dpr;
        this.ctx.translate(snapX, snapY);
      }
      _draw() {
        const layerConfig = this.getCurrentLayerConfig();
        const w = this.canvas.width / this.dpr, h = this.canvas.height / this.dpr;
        this.ctx.fillStyle = layerConfig.background;
        this.ctx.fillRect(0, 0, w, h);
        const zInt = Math.floor(this.zoom);
        const scaleFactor = Math.pow(2, this.zoom - zInt);
        const ts = TILE_SIZE;
        const ct = this.lonLatToTile(this.center.lon, this.center.lat, zInt);
        const absCos = Math.abs(Math.cos(this.bearing)), absSin = Math.abs(Math.sin(this.bearing));
        const needW = w * absCos + h * absSin;
        const needH = w * absSin + h * absCos;
        const cols = Math.ceil(needW / (ts * scaleFactor)) + TILE_BUFFER;
        const rows = Math.ceil(needH / (ts * scaleFactor)) + TILE_BUFFER;
        const startX = Math.floor(ct.x - cols / 2);
        const startY = Math.floor(ct.y - rows / 2);
        // Collect tiles with distance to center for prioritization
        const tiles = [];
        for (let dx = 0; dx < cols; dx++) {
          for (let dy = 0; dy < rows; dy++) {
            const X = startX + dx, Y = startY + dy;
            const dist = Math.hypot(dx - cols / 2, dy - rows / 2); // Distance to center
            tiles.push({ X, Y, dist });
          }
        }
        // Sort tiles by distance to center (prioritize central tiles)
        tiles.sort((a, b) => a.dist - b.dist);
        this.ctx.save();
        this.ctx.translate(w / 2, h / 2);
        this.ctx.rotate(this.bearing);
        this.ctx.scale(scaleFactor, scaleFactor);
        this.ctx.imageSmoothingEnabled = false;
        for (const { X, Y } of tiles) {
          const key = `${this.currentLayer}_${zInt}/${X}/${Y}`;
          const url = this.getTileUrl(X, Y, zInt);
          const trX = (X - ct.x) * ts;
          const trY = (Y - ct.y) * ts;
          let tile = this.tileCache.get(key);
          if (!tile) {
            this.loadTile(key, url);
          } else if (tile.loaded) {
            this.ctx.drawImage(tile.img, trX, trY, ts, ts);
            tile.lastUsed = Date.now();
            if (tile.loadedAt && (Date.now() - tile.loadedAt > TILE_TTL)) {
                // Reload using requestIdleCallback
                this.reloadTile(key, url);
            }
          }
        }
        this.ctx.restore();
        this._snapCanvasToPixelGrid();
        this.evict();
        this.preloadAdjacentZoomTiles();
        this.loadingEl.classList.toggle("visible", this.loadingTiles.size > 0);
        this.loadingCountEl.textContent = this.loadingTiles.size;
        this.coordsEl.textContent =
          `${this.center.lat.toFixed(6)}¬∞, ${this.center.lon.toFixed(6)}¬∞ | Z: ${this.zoom.toFixed(2)} | Bearing: ${(this.bearing * RAD2DEG).toFixed(1)}¬∞ | Layer: ${this.currentLayer}`;
        this.updateScaleBar();
        this.updateControlsUI();
        // --- NEW: Render Markers ---
        this._renderMarkers();
        // --- END NEW ---
      }

      // --- NEW: Marker Rendering Method ---
      _renderMarkers() {
        for (const marker of this._markers) {
          marker._updatePosition();
        }
      }
      // --- END NEW ---

      updateScaleBar() {
        if (!this.scaleBarEl || !this.scaleTextEl) return;
        const mPerPx = GISUtils.getResolution(this.center.lat, this.zoom);
        const targetMeters = mPerPx * SCALE_BAR_TARGET_PX;
        const pow = Math.pow(10, Math.floor(Math.log10(targetMeters)));
        const base = targetMeters / pow;
        const niceBase = base >= 5 ? 5 : base >= 2 ? 2 : 1;
        const niceMeters = niceBase * pow;
        const widthPx = Math.max(20, Math.min(300, niceMeters / mPerPx));
        this.scaleBarEl.style.width = `${widthPx}px`;
        if (!this.scaleTextEl.dataset.unit) this.scaleTextEl.dataset.unit = "metric";
        let displayText;
        if (this.scaleTextEl.dataset.unit === "metric") {
          displayText = GISUtils.formatDistance(niceMeters);
        } else {
          const feet = niceMeters * 3.28084;
          displayText = feet < 5280 ? Math.round(feet) + " ft" : (feet / 5280).toFixed(1) + " mi";
        }
        this.scaleTextEl.textContent = displayText;
        if (!this.scaleTextEl._hasClickListener) {
          const clickHandler = () => {
            this.scaleTextEl.dataset.unit = this.scaleTextEl.dataset.unit === "metric" ? "imperial" : "metric";
            this.updateScaleBar();
          };
          this.scaleTextEl.addEventListener("click", clickHandler);
          this.scaleTextEl._hasClickListener = true;
        }
      }
      setZoom(z) {
        const layerConfig = this.getCurrentLayerConfig();
        const nz = Math.max(layerConfig.minZoom, Math.min(layerConfig.maxZoom, z));
        if (nz === this.zoom) return;
        this.abortAllLoadingTiles();
        this.zoom = nz;
        this.render();
        this.showZoomOverlay();
        this.updateControlsUI();
      }
      setBearing(rad) {
        const nr = normalizeAngle(rad);
        if (Math.abs(nr - this.bearing) < 1e-6) return;
        this.bearing = nr;
        this.render();
      }
      showZoomOverlay() {
        const overlay = this.zoomOverlay;
        overlay.textContent = `Zoom: ${this.zoom.toFixed(2)}`;
        overlay.style.opacity = 1;
        clearTimeout(this._zTimer);
        this._zTimer = setTimeout(() => overlay.style.opacity = 0, 500);
      }
      stopInertia() {
        if (this._inertiaRAF) cancelAnimationFrame(this._inertiaRAF);
        this._inertiaRAF = null;
      }
      stopAnimations() {
        this.stopInertia();
        if (this._zoomAnim?.raf) cancelAnimationFrame(this._zoomAnim.raf);
        this._zoomAnim = null;
        if (this._flyAnim?.raf) cancelAnimationFrame(this._flyAnim.raf);
        this._flyAnim = null;
      }
      resetVelocitySamples() {
        this._moveSamples = [];
      }
      pushVelocitySample(x, y) {
        const t = performance.now();
        this._moveSamples.push({ t, x, y });
        const cutoff = t - VELOCITY_WINDOW_MS;
        while (this._moveSamples.length && this._moveSamples[0].t < cutoff) {
          this._moveSamples.shift();
        }
      }
      computeVelocity() {
        if (this._moveSamples.length < 2) return { vx: 0, vy: 0 };
        const last = this._moveSamples[this._moveSamples.length - 1];
        let i = this._moveSamples.length - 2;
        while (i > 0 && last.t - this._moveSamples[i].t < VELOCITY_WINDOW_MS * 0.5) i--;
        const ref = this._moveSamples[i];
        const dt = Math.max(1, last.t - ref.t);
        return { vx: (last.x - ref.x) / dt, vy: (last.y - ref.y) / dt };
      }
      startInertia(vx, vy) {
        const speed = Math.hypot(vx, vy);
        if (speed < INERTIA_STOP_SPEED) return;
        this.stopInertia();
        let lastT = performance.now();
        const step = () => {
          const now = performance.now();
          const dt = now - lastT;
          lastT = now;
          const dx = vx * dt, dy = vy * dt;
          const w = this.canvas.width / this.dpr;
          const h = this.canvas.height / this.dpr;
          this.center = this.screenToLatLon(w / 2 - dx, h / 2 - dy);
          const vmag = Math.hypot(vx, vy);
          const newVmag = Math.max(0, vmag - INERTIA_DECEL * dt);
          if (newVmag <= INERTIA_STOP_SPEED) {
            this.render();
            this._inertiaRAF = null;
            return;
          }
          const s = newVmag / (vmag || 1);
          vx *= s;
          vy *= s;
          this.render();
          this._inertiaRAF = requestAnimationFrame(step);
        };
        this._inertiaRAF = requestAnimationFrame(step);
      }
      screenToLatLon(ax, ay, zoom = this.zoom, bearing = this.bearing, center = this.center) {
        const w = this.canvas.width / this.dpr;
        const h = this.canvas.height / this.dpr;
        const zInt = Math.floor(zoom);
        const ts = TILE_SIZE * Math.pow(2, zoom - zInt);
        const ct = this.lonLatToTile(center.lon, center.lat, zInt);
        const anchorVec = { x: ax - w / 2, y: ay - h / 2 };
        const v = rot(anchorVec.x / ts, anchorVec.y / ts, -bearing);
        const tpt = { x: ct.x + v.x, y: ct.y + v.y };
        const ll = GISUtils.tileToLonLat(tpt.x, tpt.y, zInt);
        return {
          lon: GISUtils.wrapLongitude(ll.lon),
          lat: GISUtils.clampLatitude(ll.lat)
        };
      }
      applyZoomRotateAbout(ax, ay, newZoom, newBearing, anchorLL = null) {
        const layerConfig = this.getCurrentLayerConfig();
        newZoom = Math.max(layerConfig.minZoom, Math.min(layerConfig.maxZoom, newZoom));
        const w = this.canvas.width / this.dpr;
        const h = this.canvas.height / this.dpr;
        const anchorVec = { x: ax - w / 2, y: ay - h / 2 };
        const currAnchorLL = anchorLL || this.screenToLatLon(ax, ay, this.zoom, this.bearing, this.center);
        const zInt = Math.floor(newZoom);
        const ts = TILE_SIZE * Math.pow(2, newZoom - zInt);
        const Ptile = this.lonLatToTile(currAnchorLL.lon, currAnchorLL.lat, zInt);
        const v = rot(anchorVec.x / ts, anchorVec.y / ts, -newBearing);
        const ctNew = { x: Ptile.x - v.x, y: Ptile.y - v.y };
        const newCenter = GISUtils.tileToLonLat(ctNew.x, ctNew.y, zInt);
        this.center = {
          lon: GISUtils.wrapLongitude(newCenter.lon),
          lat: GISUtils.clampLatitude(newCenter.lat)
        };
        this.zoom = newZoom;
        this.bearing = normalizeAngle(newBearing);
      }
      showZoomIndicator(x, y) {
        if (this._zoomIndicator) {
          this.container.removeChild(this._zoomIndicator);
        }
        const indicator = document.createElement("div");
        indicator.style.position = "absolute";
        indicator.style.left = (x - 15) + "px";
        indicator.style.top = (y - 15) + "px";
        indicator.style.width = "30px";
        indicator.style.height = "30px";
        indicator.style.borderRadius = "50%";
        indicator.style.border = "2px solid #333";
        indicator.style.opacity = "0.8";
        indicator.style.pointerEvents = "none";
        indicator.style.zIndex = "100";
        indicator.style.animation = "zoom-indicator 0.6s ease-out forwards";
        this.container.appendChild(indicator);
        this._zoomIndicator = indicator;
        setTimeout(() => {
          if (this._zoomIndicator && this._zoomIndicator.parentNode) {
            this.container.removeChild(this._zoomIndicator);
            this._zoomIndicator = null;
          }
        }, 600);
      }
      animateZoomRotateAbout(ax, ay, toZoom, toBearing = this.bearing, duration = WHEEL_ZOOM_DURATION, easing = EASING.easeInOutCubic) {
        this.showZoomIndicator(ax, ay);
        this.stopAnimations();
        this.abortAllLoadingTiles();
        const startT = performance.now();
        const sZoom = this.zoom;
        const sBear = this.bearing;
        const deltaBear = shortestAngleDiff(sBear, toBearing);
        const anchorLL = this.screenToLatLon(ax, ay, this.zoom, this.bearing, this.center);
        const step = () => {
          const t = (performance.now() - startT) / Math.max(1, duration);
          const p = t >= 1 ? 1 : easing(Math.max(0, Math.min(1, t)));
          const z = sZoom + (toZoom - sZoom) * p;
          const b = sBear + deltaBear * p;
          this.applyZoomRotateAbout(ax, ay, z, b, anchorLL);
          this.render();
          if (t < 1) {
            this._zoomAnim = { raf: requestAnimationFrame(step) };
          } else {
            this._zoomAnim = null;
            this.updateControlsUI();
          }
        };
        this._zoomAnim = { raf: requestAnimationFrame(step) };
      }
      smoothZoomAt(ax, ay, deltaZ) {
        const layerConfig = this.getCurrentLayerConfig();
        const target = Math.max(layerConfig.minZoom, Math.min(layerConfig.maxZoom, this.zoom + deltaZ));
        this.animateZoomRotateAbout(ax, ay, target, this.bearing, WHEEL_ZOOM_DURATION, EASING.easeInOutCubic);
      }
      flyTo({ center = this.center, zoom = this.zoom, bearing = this.bearing, duration = FLYTO_DURATION, easing = EASING.easeInOutCubic } = {}) {
        const layerConfig = this.getCurrentLayerConfig();
        this.stopAnimations();
        this.abortAllLoadingTiles();
        const startT = performance.now();
        const sC = { ...this.center };
        const eC = { ...center };
        const dLon = wrapDeltaLon(eC.lon - sC.lon);
        const dLat = eC.lat - sC.lat;
        const sZ = this.zoom, eZ = Math.max(layerConfig.minZoom, Math.min(layerConfig.maxZoom, zoom));
        const sB = this.bearing, dB = shortestAngleDiff(sB, bearing);
        const step = () => {
          const t = (performance.now() - startT) / Math.max(1, duration);
          const p = t >= 1 ? 1 : easing(Math.max(0, Math.min(1, t)));
          this.center = {
            lon: GISUtils.wrapLongitude(sC.lon + dLon * p),
            lat: GISUtils.clampLatitude(sC.lat + dLat * p)
          };
          this.zoom = sZ + (eZ - sZ) * p;
          this.bearing = normalizeAngle(sB + dB * p);
          this.render();
          if (t < 1) {
            this._flyAnim = { raf: requestAnimationFrame(step) };
          } else {
            this._flyAnim = null;
            this.updateControlsUI();
          }
        };
        this._flyAnim = { raf: requestAnimationFrame(step) };
      }
      // --- Touch Event Handler Helpers (Suggestions 5) ---
      /**
       * Handles the start of a single touch event.
       * @param {TouchEvent} e - The touch event.
       * @private
       */
      _handleSingleTouchStart(e) {
          const t = e.touches[0];
          this.isDragging = true;
          this.container.classList.add('dragging');
          this.dragStart = { x: t.clientX, y: t.clientY, center: { ...this.center } };
          this.resetVelocitySamples();
          this.pushVelocitySample(t.clientX, t.clientY);
          this._singleTouchStart = { x: t.clientX, y: t.clientY, t: performance.now() };
          this._singleTouchMoved = false;
      }
      /**
       * Handles the start of a pinch gesture.
       * @param {TouchEvent} e - The touch event.
       * @private
       */
      _handlePinchStart(e) {
          const t1 = e.touches[0], t2 = e.touches[1];
          this.isDragging = false; // Stop any ongoing drag
          this.isPinching = true;
          this.pinchStartDist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
          this.pinchStartAngle = Math.atan2(t2.clientY - t1.clientY, t2.clientX - t1.clientX);
          this.pinchStartZoom = this.zoom;
          this.pinchStartBearing = this.bearing;
          this.pinchStartTime = performance.now();
          this.pinchLastCenter = { x: (t1.clientX + t2.clientX) / 2, y: (t1.clientY + t2.clientY) / 2 };
          this._pinchAnchorLL = this.screenToLatLon(this.pinchLastCenter.x, this.pinchLastCenter.y, this.zoom, this.bearing, this.center);
          // this._pinchAnchorVec = null; // Removed as unused
          this.resetVelocitySamples();
          this.pushVelocitySample(this.pinchLastCenter.x, this.pinchLastCenter.y);
          this._pinchMoved = false;
      }
      /**
       * Handles movement during a single touch drag.
       * @param {TouchEvent} e - The touch event.
       * @private
       */
      _handleSingleTouchMove(e) {
          const t = e.touches[0];
          if (this._singleTouchStart) {
            const md = Math.hypot(t.clientX - this._singleTouchStart.x, t.clientY - this._singleTouchStart.y);
            if (md > DOUBLE_TAP_MAX_MOVE) this._singleTouchMoved = true;
          }
          const dx = t.clientX - this.dragStart.x;
          const dy = t.clientY - this.dragStart.y;
          const w = this.canvas.width / this.dpr;
          const h = this.canvas.height / this.dpr;
          this.center = this.screenToLatLon(w / 2 - dx, h / 2 - dy, this.zoom, this.bearing, this.dragStart.center);
          this.pushVelocitySample(t.clientX, t.clientY);
          this.render();
      }
      /**
       * Handles movement during a pinch gesture.
       * @param {TouchEvent} e - The touch event.
       * @private
       */
      _handlePinchMove(e) {
          const t1 = e.touches[0], t2 = e.touches[1];
          const dist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
          const angle = Math.atan2(t2.clientY - t1.clientY, t2.clientX - t1.clientX);
          const center = { x: (t1.clientX + t2.clientX) / 2, y: (t1.clientY + t2.clientY) / 2 };
          const targetZoom = this.pinchStartZoom + Math.log2(dist / Math.max(1, this.pinchStartDist));
          const deltaAngle = normalizeAngle(angle - this.pinchStartAngle);
          const targetBearing = normalizeAngle(this.pinchStartBearing + deltaAngle);
          if (Math.abs(Math.log(dist / Math.max(1, this.pinchStartDist))) > Math.log(1 + TWO_FINGER_TAP_MOVE_THRESH / Math.max(1, this.pinchStartDist)) ||
            Math.abs(deltaAngle) > ROTATE_MOVE_THRESH_RAD) {
            this._pinchMoved = true;
          }
          this.applyZoomRotateAbout(center.x, center.y, targetZoom, targetBearing, this._pinchAnchorLL);
          this.pinchLastCenter = center;
          this.pushVelocitySample(center.x, center.y);
          this.render();
      }
      /**
       * Handles the end of a single touch (including tap logic).
       * @param {TouchEvent} e - The touch event.
       * @private
       */
      _handleTouchEndSingle(e) {
          const now = performance.now();
          const s = this._singleTouchStart;
          if (s && !this._singleTouchMoved) {
            const dt = now - s.t;
            const distFromLast = Math.hypot(s.x - this._lastTapPos.x, s.y - this._lastTapPos.y);
            if (now - this._lastTapTime <= DOUBLE_TAP_MAX_DELAY && distFromLast <= DOUBLE_TAP_MAX_MOVE) {
              this.animateZoomRotateAbout(s.x, s.y, this.zoom + 1, this.bearing, TAP_ZOOM_DURATION);
              this._lastTapTime = 0; // Reset double tap
            } else {
              this._lastTapTime = now;
              this._lastTapPos = { x: s.x, y: s.y };
            }
          }
          this.isDragging = false;
          this.container.classList.remove('dragging');
          const { vx, vy } = this.computeVelocity();
          this.startInertia(vx, vy);
      }
      /**
       * Handles the end of a pinch gesture (including two-finger tap).
       * @param {TouchEvent} e - The touch event.
       * @private
       */
      _handleTouchEndPinch(e) {
          const dt = performance.now() - this.pinchStartTime;
          if (dt <= TWO_FINGER_TAP_MAX_DELAY && !this._pinchMoved) {
            const ax = this.pinchLastCenter ? this.pinchLastCenter.x : (this.canvas.width / this.dpr) / 2;
            const ay = this.pinchLastCenter ? this.pinchLastCenter.y : (this.canvas.height / this.dpr) / 2;
            this.animateZoomRotateAbout(ax, ay, this.zoom - 1, this.bearing, TAP_ZOOM_DURATION);
          }
          this.isPinching = false;
      }
      // --- End Touch Event Handler Helpers ---
      setupEvents() {
        this._eventListeners.resize = () => this.resize();
        window.addEventListener("resize", this._eventListeners.resize);
        this._eventListeners.mousedown = (e) => {
          this.stopAnimations();
          this.isDragging = true;
          this.container.classList.add('dragging');
          this.dragStart = { x: e.clientX, y: e.clientY, center: { ...this.center } };
          this.resetVelocitySamples();
          this.pushVelocitySample(e.clientX, e.clientY);
        };
        this.canvas.addEventListener("mousedown", this._eventListeners.mousedown);
        this._eventListeners.mousemove = (e) => {
          if (!this.isDragging) return;
          const dx = e.clientX - this.dragStart.x;
          const dy = e.clientY - this.dragStart.y;
          const w = this.canvas.width / this.dpr;
          const h = this.canvas.height / this.dpr;
          this.center = this.screenToLatLon(w / 2 - dx, h / 2 - dy, this.zoom, this.bearing, this.dragStart.center);
          this.pushVelocitySample(e.clientX, e.clientY);
          this.render();
        };
        window.addEventListener("mousemove", this._eventListeners.mousemove);
        this._eventListeners.mouseup = () => {
          if (!this.isDragging) return;
          this.isDragging = false;
          this.container.classList.remove('dragging');
          const { vx, vy } = this.computeVelocity();
          this.startInertia(vx, vy);
        };
        window.addEventListener("mouseup", this._eventListeners.mouseup);
        this._eventListeners.wheel = (e) => {
          e.preventDefault();
          const dz = (e.deltaY < 0 ? WHEEL_ZOOM_STEP : -WHEEL_ZOOM_STEP);
          this.smoothZoomAt(e.clientX, e.clientY, dz);
        };
        this.canvas.addEventListener("wheel", this._eventListeners.wheel, { passive: false });
        this._eventListeners.dblclick = (e) => {
          e.preventDefault();
          this.animateZoomRotateAbout(e.clientX, e.clientY, this.zoom + 1, this.bearing, TAP_ZOOM_DURATION);
        };
        this.canvas.addEventListener("dblclick", this._eventListeners.dblclick);
        const zoomInHandler = () => {
          this.stopAnimations();
          this.setZoom(this.zoom + 1);
        };
        const zoomOutHandler = () => {
          this.stopAnimations();
          this.setZoom(this.zoom - 1);
        };
        document.getElementById("zoom-in").addEventListener("click", zoomInHandler);
        document.getElementById("zoom-out").addEventListener("click", zoomOutHandler);
        this._eventListeners.layerToggleClick = () => {
          const nextLayer = this.currentLayer === "OSM" ? "ESRI" : "OSM";
          this.switchLayer(nextLayer);
        };
        document.getElementById("layer-toggle").addEventListener("click", this._eventListeners.layerToggleClick);
        this._eventListeners.keydown = (e) => {
          if (e.key === "+" || e.key === "=") {
            this.stopAnimations();
            this.setZoom(this.zoom + 1);
          } else if (e.key === "-") {
            this.stopAnimations();
            this.setZoom(this.zoom - 1);
          } else if (e.key === "ArrowUp") {
            this.stopAnimations();
            this.center.lat = GISUtils.clampLatitude(this.center.lat + 1);
            this.render();
          } else if (e.key === "ArrowDown") {
            this.stopAnimations();
            this.center.lat = GISUtils.clampLatitude(this.center.lat - 1);
            this.render();
          } else if (e.key === "ArrowLeft") {
            this.stopAnimations();
            this.center.lon = GISUtils.wrapLongitude(this.center.lon - 1);
            this.render();
          } else if (e.key === "ArrowRight") {
            this.stopAnimations();
            this.center.lon = GISUtils.wrapLongitude(this.center.lon + 1);
            this.render();
          } else if (e.key.toLowerCase() === "n") {
            const w = this.canvas.width / this.dpr, h = this.canvas.height / this.dpr;
            this.animateZoomRotateAbout(w / 2, h / 2, this.zoom, 0, SNAP_DURATION);
          } else if (e.key === "r") {
            this.setBearing(this.bearing + DEG2RAD * 15);
          } else if (e.key === "l") {
            this.setBearing(this.bearing - DEG2RAD * 15);
          } else if (e.key === "s") {
            const nextLayer = this.currentLayer === "OSM" ? "ESRI" : "OSM";
            this.switchLayer(nextLayer);
          }
        };
        window.addEventListener("keydown", this._eventListeners.keydown);
        // --- Updated Touch Event Listeners using Helpers ---
        const onTouchStart = (e) => {
          if (!e.touches.length) return;
          e.preventDefault();
          this.stopAnimations();
          if (e.touches.length === 1) {
              this._handleSingleTouchStart(e); // Use helper
          } else if (e.touches.length === 2) {
              this._handlePinchStart(e); // Use helper
          }
        };
        const onTouchMove = (e) => {
          if (!e.touches.length) return;
          e.preventDefault();
          if (this.isPinching && e.touches.length >= 2) {
              this._handlePinchMove(e); // Use helper
          } else if (this.isDragging && e.touches.length === 1) {
              this._handleSingleTouchMove(e); // Use helper
          }
        };
        const onTouchEnd = (e) => {
          if (this.isPinching) {
              this._handleTouchEndPinch(e); // Use helper
          }
          // Check if we are ending a single touch drag
          // (touchend might fire for one finger while another is still down, but we handle that in start)
          if (this.isDragging) {
              this._handleTouchEndSingle(e); // Use helper
          }
        };
        // --- End Updated Touch Event Listeners ---
        this._eventListeners.touchstart = onTouchStart;
        this._eventListeners.touchmove = onTouchMove;
        this._eventListeners.touchend = onTouchEnd;
        this._eventListeners.touchcancel = onTouchEnd; // Use same handler for cancel
        this.canvas.addEventListener("touchstart", this._eventListeners.touchstart, { passive: false });
        this.canvas.addEventListener("touchmove", this._eventListeners.touchmove, { passive: false });
        this.canvas.addEventListener("touchend", this._eventListeners.touchend, { passive: false });
        this.canvas.addEventListener("touchcancel", this._eventListeners.touchcancel, { passive: false });
        this._eventListeners.fullscreenClick = () => {
          if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch(err => {
                console.warn(`Error attempting to enable fullscreen: ${err.message}`);
            });
          } else {
            document.exitFullscreen().catch(err => {
                console.warn(`Error attempting to exit fullscreen: ${err.message}`);
            });
          }
        };
        document.getElementById("fullscreen").addEventListener("click", this._eventListeners.fullscreenClick);
      }
      initControls() {
        const stack = this.container.querySelector(".controls");
        if (!stack) return;
        const existingCompass = stack.querySelector("#compass");
        const existingResetZoom = stack.querySelector("#reset-zoom");
        if (existingCompass) {
          stack.removeChild(existingCompass);
        }
        if (existingResetZoom) {
          stack.removeChild(existingResetZoom);
        }
        const compass = document.createElement("button");
        compass.id = "compass";
        compass.className = "control-btn";
        compass.title = "Reset North";
        compass.setAttribute("aria-label", "Reset North");
        compass.textContent = "N";
        compass.style.display = "none";
        compass.onclick = () => {
          const w = this.canvas.width / this.dpr, h = this.canvas.height / this.dpr;
          this.animateZoomRotateAbout(w / 2, h / 2, this.zoom, 0, SNAP_DURATION);
        };
        compass.onmouseenter = () => { compass.style.background = "rgba(240, 240, 240, 0.9)"; };
        compass.onmouseleave = () => { compass.style.background = "rgba(255, 255, 255, 0.9)"; };
        compass.onmousedown = () => { compass.style.transform = "scale(0.95) rotate(" + (-this.bearing * RAD2DEG) + "deg)"; };
        compass.onmouseup = () => { compass.style.transform = "rotate(" + (-this.bearing * RAD2DEG) + "deg)"; };
        stack.appendChild(compass);
        this._compassBtn = compass;
        const resetZoom = document.createElement("button");
        resetZoom.id = "reset-zoom";
        resetZoom.className = "control-btn";
        resetZoom.title = "Reset Zoom";
        resetZoom.setAttribute("aria-label", "Reset Zoom");
        resetZoom.textContent = "‚§¢";
        resetZoom.onclick = () => {
          const w = this.canvas.width / this.dpr, h = this.canvas.height / this.dpr;
          this.animateZoomRotateAbout(w / 2, h / 2, CONFIG.defaultZoom, this.bearing, SNAP_DURATION);
        };
        resetZoom.onmouseenter = () => { resetZoom.style.background = "rgba(240, 240, 240, 0.9)"; };
        resetZoom.onmouseleave = () => { resetZoom.style.background = "rgba(255, 255, 255, 0.9)"; };
        resetZoom.onmousedown = () => { resetZoom.style.transform = "scale(0.95)"; };
        resetZoom.onmouseup = () => { resetZoom.style.transform = "scale(1)"; };
        stack.appendChild(resetZoom);
        this._resetZoomBtn = resetZoom;
      }
      updateControlsUI() {
        const zoomInBtn = document.getElementById("zoom-in");
        const zoomOutBtn = document.getElementById("zoom-out");
        const layerConfig = this.getCurrentLayerConfig();
        if (zoomInBtn) {
          zoomInBtn.disabled = this.zoom >= layerConfig.maxZoom;
        }
        if (zoomOutBtn) {
          zoomOutBtn.disabled = this.zoom <= layerConfig.minZoom;
        }
        if (this._compassBtn) {
          const visible = Math.abs(this.bearing) > 0.001;
          this._compassBtn.style.display = visible ? "block" : "none";
          this._compassBtn.style.transition = "transform 0.3s ease-out";
          this._compassBtn.style.transform = `rotate(${-this.bearing * RAD2DEG}deg)`;
        }
      }
      updateAttribution() {
        if (this.attributionEl) {
          this.attributionEl.innerHTML = this.layerConfig.attribution;
        }
      }
      destroy() {
          this.stopAnimations();
          this.stopInertia();
          this.abortAllLoadingTiles();
          if (this._eventListeners.resize) window.removeEventListener("resize", this._eventListeners.resize);
          if (this._eventListeners.mousedown) this.canvas.removeEventListener("mousedown", this._eventListeners.mousedown);
          if (this._eventListeners.mousemove) window.removeEventListener("mousemove", this._eventListeners.mousemove);
          if (this._eventListeners.mouseup) window.removeEventListener("mouseup", this._eventListeners.mouseup);
          if (this._eventListeners.wheel) this.canvas.removeEventListener("wheel", this._eventListeners.wheel);
          if (this._eventListeners.dblclick) this.canvas.removeEventListener("dblclick", this._eventListeners.dblclick);
          if (this._eventListeners.keydown) window.removeEventListener("keydown", this._eventListeners.keydown);
          if (this._eventListeners.touchstart) this.canvas.removeEventListener("touchstart", this._eventListeners.touchstart);
          if (this._eventListeners.touchmove) this.canvas.removeEventListener("touchmove", this._eventListeners.touchmove);
          if (this._eventListeners.touchend) this.canvas.removeEventListener("touchend", this._eventListeners.touchend);
          if (this._eventListeners.touchcancel) this.canvas.removeEventListener("touchcancel", this._eventListeners.touchcancel);
          if (this._eventListeners.fullscreenClick) document.getElementById("fullscreen").removeEventListener("click", this._eventListeners.fullscreenClick);
          if (this._eventListeners.layerToggleClick) document.getElementById("layer-toggle").removeEventListener("click", this._eventListeners.layerToggleClick);
          this.tileCache.clear();
          this.loadingTiles.clear();
          this.loadingControllers.clear();
          // --- NEW: Clean up markers and popups ---
          for (const marker of this._markers) {
            marker.remove();
          }
          if (this._openPopup) {
            this._openPopup.close();
          }
          // --- END NEW ---
          console.log("Atlas instance destroyed.");
      }

      // --- NEW: Public API for Markers ---
      /**
       * Adds a marker to the map.
       * @param {AtlasMarker} marker - The marker instance to add.
       * @returns {Atlas} - Returns self for chaining.
       */
      addMarker(marker) {
        if (!(marker instanceof AtlasMarker)) {
          throw new Error('Argument must be an instance of AtlasMarker');
        }
        this._markers.push(marker);
        marker.addTo(this);
        return this;
      }

      /**
       * Removes a marker from the map.
       * @param {AtlasMarker} marker - The marker instance to remove.
       * @returns {Atlas} - Returns self for chaining.
       */
      removeMarker(marker) {
        const index = this._markers.indexOf(marker);
        if (index !== -1) {
          this._markers.splice(index, 1);
          marker.remove();
        }
        return this;
      }

      /**
       * Removes all markers from the map.
       * @returns {Atlas} - Returns self for chaining.
       */
      clearMarkers() {
        for (const marker of [...this._markers]) { // Create a copy to avoid mutation during iteration
          this.removeMarker(marker);
        }
        return this;
      }
      // --- END NEW ---
    }
    let atlasInstance = null;
    /**
     * Initializes the Atlas map instance, attempting geolocation first.
     */
    function initializeAtlas() {
        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(pos => {
            atlasInstance = new Atlas("map");
            const lat = pos.coords.latitude;
            const lon = pos.coords.longitude;
            atlasInstance.flyTo({ center: { lat, lon }, zoom: 10 });

            // --- DEMO: Add a marker after initialization ---
            const marker = new AtlasMarker({
              latLng: { lat, lon },
              title: "Your Location",
              draggable: true
            }).bindPopup(`
              <strong>Your Location</strong><br>
              Latitude: ${lat.toFixed(6)}<br>
              Longitude: ${lon.toFixed(6)}<br>
              <em>Drag me around!</em>
            `);

            atlasInstance.addMarker(marker);
            // --- END DEMO ---

          }, (error) => {
            // --- Suggestion 6: Improved Geolocation Error Handling ---
            console.warn("Geolocation failed:", error.message);
            // Provide user feedback
            alert("Could not determine your location. Loading map with default view.");
            atlasInstance = new Atlas("map");
            // --- END Suggestion 6 ---
          }, { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 });
        } else {
          console.warn("Geolocation is not supported by this browser.");
          alert("Geolocation is not supported by your browser. Loading map with default view.");
          atlasInstance = new Atlas("map");
        }
    }
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeAtlas);
    } else {
        initializeAtlas();
    }
  </script>
</body>
</html>
