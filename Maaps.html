<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="referrer" content="origin">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Atlas.js - Lightweight JavaScript Mapping Library</title>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; width: 100%; overflow: hidden; font-family: sans-serif; }
    #map-container { position: relative; width: 100%; height: 100%; overflow: hidden; background: #000; cursor: grab; }
    #map-container.dragging { cursor: grabbing; }
    #map-container.selecting { cursor: crosshair; }
    #map { width: 100%; height: 100%; display: block; }
    .atlas-control-container {
      position: absolute;
      z-index: 1000;
      pointer-events: none;
    }
    .atlas-control-container > * { pointer-events: auto; }
    .atlas-control-top-left { top: 10px; left: 10px; }
    .atlas-control-top-right { top: 10px; right: 10px; }
    .atlas-control-bottom-left { bottom: 10px; left: 10px; }
    .atlas-control-bottom-right { bottom: 10px; right: 10px; }
    .atlas-control-vertical { display: flex; flex-direction: column; gap: 5px; }
    .atlas-control-horizontal { display: flex; flex-direction: row; gap: 5px; }
    .control-btn {
        background-color: #fff;
        border: none;
        width: 30px;
        height: 30px;
        font-size: 1.2rem;
        cursor: pointer;
        box-shadow: 0 1px 4px rgba(0,0,0,0.3);
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    .control-btn:hover {
        background-color: #f4f4f4;
    }
    .control-btn:active {
        background-color: #e8e8e8;
        transform: scale(0.98);
    }
    .atlas-zoom-control {
        display: flex;
        flex-direction: column;
        border-radius: 4px;
        overflow: hidden;
        box-shadow: 0 1px 4px rgba(0,0,0,0.3);
    }
    .atlas-zoom-control .control-btn {
        box-shadow: none;
        border-radius: 0;
    }
    .atlas-zoom-control .control-btn:first-child {
        border-bottom: 1px solid #ddd;
    }
    .control-btn svg {
        width: 18px;
        height: 18px;
        stroke: #333;
    }
    .control-btn:focus { outline: 2px solid #0078A8; outline-offset: 2px; }
    .control-btn:disabled { background: rgba(245,245,245,0.9); color: #aaa; cursor: not-allowed; }
    #loading {
      position: absolute; top: 10px; right: 10px;
      background: rgba(255,255,255,0.9); padding: 4px 8px; border-radius: 4px;
      font-size: 12px; display: none; box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    #loading.visible { display: block; }
    #attribution {
      position: absolute;
      bottom: 5px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: #fff;
      font-size: clamp(10px, 1.2vw, 12px);
      padding: 6px 8px;
      border-radius: 3px;
      white-space: nowrap;
      overflow-x: auto;
      scrollbar-width: thin;
      scrollbar-color: rgba(255, 255, 255, 0.3) rgba(0, 0, 0, 0.7);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
      z-index: 1000;
    }
    #attribution::-webkit-scrollbar {
      height: 6px;
    }
    #attribution::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.7);
      border-radius: 3px;
    }
    #attribution::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.3);
      border-radius: 3px;
    }
    #attribution a {
      color: #4d90fe;
      text-decoration: none;
      font-weight: bold;
      margin-right: 8px;
      transition: opacity 0.2s ease;
    }
    #attribution a:hover {
      text-decoration: underline;
      opacity: 0.9;
    }

    /* >>>> ADDED: Search Control Styles <<<< */
    .atlas-search-input:focus {
      border-color: #0078A8;
      box-shadow: 0 0 0 2px rgba(0, 120, 168, 0.2);
    }

    .atlas-search-result-item:hover,
    .atlas-search-result-item.active {
      background-color: #f0f0f0;
    }

    .atlas-search-result-item:last-child {
      border-bottom: none;
    }

    @keyframes zoom-indicator {
      0% { transform: scale(0.2); opacity: 0.8; }
      100% { transform: scale(1.2); opacity: 0; }
    }

    /* >>>> ADDED: Marker and Popup Styles <<<< */
    .atlas-marker-pane, .atlas-popup-pane {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 600;
    }

    .atlas-marker-icon {
      position: absolute;
      pointer-events: auto;
      transition: transform 0.1s ease-out, opacity 0.1s ease-out;
    }

    .atlas-marker-icon:hover {
      transform: scale(1.1);
    }

    .atlas-marker-shadow {
      position: absolute;
      pointer-events: none;
      filter: blur(1.5px);
      opacity: 0.4;
    }

    .atlas-popup {
        position: absolute;
        text-align: center;
        pointer-events: auto;
        z-index: 700; /* Above markers */
    }

    .atlas-popup-content-wrapper {
        padding: 1px;
        text-align: left;
        border-radius: 12px;
        background-color: rgba(255, 255, 255, 0.9);
        box-shadow: 0 3px 14px rgba(0,0,0,0.4);
        backdrop-filter: blur(5px);
    }

    .atlas-popup-content {
        padding: 10px 20px;
        margin: 0;
        line-height: 1.4;
    }

    .atlas-popup-tip-container {
        width: 40px;
        height: 20px;
        position: absolute;
        left: 50%;
        margin-left: -20px;
        overflow: hidden;
        pointer-events: none;
    }

    .atlas-popup-tip {
        width: 17px;
        height: 17px;
        padding: 1px;
        margin: -10px auto 0;
        transform: rotate(45deg);
        background-color: rgba(255, 255, 255, 0.9);
        box-shadow: 0 3px 14px rgba(0,0,0,0.4);
    }

    .atlas-popup-close-button {
        position: absolute;
        top: 0;
        right: 0;
        padding: 4px 4px 0 0;
        border: none;
        text-align: center;
        width: 18px;
        height: 14px;
        font: 16px/14px Tahoma, Verdana, sans-serif;
        color: #757575;
        text-decoration: none;
        font-weight: bold;
        background: transparent;
        cursor: pointer;
    }

    .atlas-scale-control {
        background: rgba(255, 255, 255, 0.7);
        border: 2px solid #777;
        border-top: none;
        padding: 2px 5px;
        font-size: 11px;
        color: #333;
        white-space: nowrap;
        backdrop-filter: blur(2px);
    }

    .atlas-location-marker {
        pointer-events: none;
    }

    .atlas-location-marker .dot {
        background: #2A93EE;
        width: 16px;
        height: 16px;
        border: 2px solid #FFFFFF;
        border-radius: 50%;
        box-shadow: 0 0 5px rgba(0,0,0,0.5);
    }

    .atlas-location-marker .accuracy-circle {
        width: 32px; /* Initial size, will be updated by JS */
        height: 32px;
        background: rgba(42, 147, 238, 0.2);
        border: 1px solid rgba(42, 147, 238, 0.5);
        border-radius: 50%;
        animation: atlas-pulse 2s infinite;
    }

    @keyframes atlas-pulse {
      0% { transform: scale(1); opacity: 0.5; }
      50% { transform: scale(1.2); opacity: 0.2; }
      100% { transform: scale(1); opacity: 0.5; }
    }

    .atlas-search-popup-content .title {
        font-weight: bold;
        font-size: 14px;
        margin-bottom: 4px;
    }
    .atlas-search-popup-content .details {
        font-size: 12px;
        color: #555;
        margin-bottom: 6px;
    }
    .atlas-search-popup-content hr {
        border: 0;
        border-top: 1px solid #eee;
        margin: 6px 0;
    }
    .atlas-search-popup-content .coords {
        font-size: 11px;
        color: #888;
    }
    .atlas-layers-control {
        background: rgba(255,255,255,0.9);
        border-radius: 5px;
        box-shadow: 0 1px 5px rgba(0,0,0,0.4);
        transition: all 0.2s;
    }
    .atlas-layers-control-toggle {
        width: 36px;
        height: 36px;
        background-image: url('data:image/svg+xml;charset=utf-8,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"%3E%3Cpath d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/%3E%3C/svg%3E');
        background-size: 24px 24px;
        background-position: center;
        background-repeat: no-repeat;
        border: 1px solid #ccc;
        border-radius: 4px;
        cursor: pointer;
    }
    .atlas-layers-list {
        padding: 6px 10px;
        line-height: 1.5;
    }
    .atlas-layers-list label {
        display: flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
    }
    .atlas-layers-separator {
        height: 1px;
        background-color: #ddd;
        margin: 6px 0;
    }
    .atlas-edit-handle {
        background: #fff;
        border: 2px solid #3388ff;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        position: absolute;
        cursor: move;
        pointer-events: auto;
        z-index: 800;
    }
    .atlas-tooltip-pane {
        pointer-events: none;
        z-index: 850;
    }
    .atlas-tooltip {
        position: absolute;
        padding: 6px 8px;
        background-color: rgba(255, 255, 255, 0.9);
        border: 1px solid #ccc;
        border-radius: 3px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.4);
        white-space: nowrap;
        font-size: 12px;
        color: #333;
    }
  </style>
</head>
<body>
  <div id="map-container">
    <canvas id="map"></canvas>
    <div class="atlas-marker-pane"></div>
    <div class="atlas-popup-pane"></div>
    <div id="loading">Loading: <span id="loading-count">0</span></div>
    <div id="attribution"></div>
  </div>
  <script>
    const EARTH_RADIUS = 6378137;
    const EARTH_CIRCUMFERENCE = 2 * Math.PI * EARTH_RADIUS;
    const MAX_LATITUDE = 85.05112878;
    const MIN_LATITUDE = -85.05112878;
    const TILE_SIZE = 256;
    const TILE_BUFFER = 3;
    const TILE_TTL = 86400000;
    const TILE_LOAD_TIMEOUT_MS = 8000;
    const INERTIA_DECEL = 0.0025;
    const INERTIA_STOP_SPEED = 0.02;
    const VELOCITY_WINDOW_MS = 120;
    const DOUBLE_TAP_MAX_DELAY = 300;
    const DOUBLE_TAP_MAX_MOVE = 16;
    const TWO_FINGER_TAP_MAX_DELAY = 250;
    const TWO_FINGER_TAP_MOVE_THRESH = 10;
    const ROTATE_MOVE_THRESH_RAD = 0.08;
    const WHEEL_ZOOM_STEP = 0.25;
    const WHEEL_ZOOM_DURATION = 220;
    const TAP_ZOOM_DURATION = 280;
    const SNAP_DURATION = 300;
    const FLYTO_DURATION = 800;
    const LAYERS = {
      OSM: {
        name: "OpenStreetMap",
        minZoom: 0,
        maxZoom: 19,
        tileServers: ["https://a.tile.openstreetmap.org", "https://b.tile.openstreetmap.org", "https://c.tile.openstreetmap.org"],
        attribution: '© <a href="https://www.openstreetmap.org/copyright" target="_blank" rel="noopener noreferrer">OpenStreetMap contributors</a>',
        background: "#e6e6e6",
        supportsRetina: true,
        maxCacheSize: 800
      },
      ESRI: {
        name: "Esri Satellite",
        minZoom: 0,
        maxZoom: 19,
        tileServers: ["https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile"],
        attribution: 'Tiles © <a href="https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer" target="_blank" rel="noopener noreferrer">Esri World Imagery</a>',
        background: "#000000",
        supportsRetina: false,
        maxCacheSize: 600
      },
      ESRI_TOPO: {
        name: "Esri Topographic",
        minZoom: 0,
        maxZoom: 19,
        tileServers: ["https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile"],
        attribution: 'Tiles © <a href="https://services.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer" target="_blank" rel="noopener noreferrer">Esri World Topographic Map</a>',
        background: "#f5f5f0",
        supportsRetina: false,
        maxCacheSize: 600
      }
    };
    const CONFIG = {
      defaultLayer: "OSM",
      defaultCenter: { lon: 0, lat: 0 },
      defaultZoom: 3,
      retina: "auto",
      retinaSuffix: "@2x"
    };
    const EASING = {
      easeInOutCubic: t => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2,
      easeOutCubic: t => 1 - Math.pow(1 - t, 3),
      linear: t => t
    };
    const RAD2DEG = 180 / Math.PI;
    const DEG2RAD = Math.PI / 180;
    function normalizeAngle(rad) { return Math.atan2(Math.sin(rad), Math.cos(rad)); }
    function shortestAngleDiff(from, to) { return normalizeAngle(to - from); }
    function wrapDeltaLon(delta) { delta = ((delta + 180) % 360 + 360) % 360 - 180; return delta; }
    function rot(x, y, ang) { const c = Math.cos(ang), s = Math.sin(ang); return { x: x * c - y * s, y: x * s + y * c }; }
    class Projection {
      project(latlng) { throw new Error('project() must be implemented'); }
      unproject(point) { throw new Error('unproject() must be implemented'); }
    }
    class WebMercatorProjection extends Projection {
      project(latlng) {
        const d = EARTH_RADIUS;
        const lat = Math.max(MIN_LATITUDE, Math.min(MAX_LATITUDE, latlng.lat));
        const sin = Math.sin(lat * DEG2RAD);
        return {
          x: d * latlng.lon * DEG2RAD,
          y: d * Math.log((1 + sin) / (1 - sin)) / 2
        };
      }
      unproject(point) {
        const d = EARTH_RADIUS;
        return {
          lon: (point.x / d) * RAD2DEG,
          lat: (2 * Math.atan(Math.exp(point.y / d)) - Math.PI / 2) * RAD2DEG
        };
      }
      latLngToTile(latlng, zoom) {
        const scale = Math.pow(2, zoom);
        const p = this.project(latlng);
        return {
          x: (p.x + Math.PI * EARTH_RADIUS) / (2 * Math.PI * EARTH_RADIUS) * scale,
          y: (Math.PI * EARTH_RADIUS - p.y) / (2 * Math.PI * EARTH_RADIUS) * scale
        };
      }
      tileToLatLng(x, y, zoom) {
        const scale = Math.pow(2, zoom);
        const p = {
          x: x / scale * 2 * Math.PI * EARTH_RADIUS - Math.PI * EARTH_RADIUS,
          y: Math.PI * EARTH_RADIUS - y / scale * 2 * Math.PI * EARTH_RADIUS
        };
        return this.unproject(p);
      }
    }
    const DEFAULT_PROJECTION = new WebMercatorProjection();
    class GISUtils {
      static wrapLongitude(l) { while (l > 180) l -= 360; while (l < -180) l += 360; return l; }
      static clampLatitude(lat) { return Math.max(MIN_LATITUDE, Math.min(MAX_LATITUDE, lat)); }
      static getResolution(lat, z) { return (EARTH_CIRCUMFERENCE * Math.cos(lat * DEG2RAD)) / (Math.pow(2, z) * TILE_SIZE); }
      static formatDistance(m) { return m < 1000 ? Math.round(m) + " m" : (m / 1000).toFixed(1) + " km"; }
      static tileToLonLat(x, y, z) { return DEFAULT_PROJECTION.tileToLatLng(x, y, z); }
      static haversineDistance(coords1, coords2) {
        const R = EARTH_RADIUS;
        const φ1 = coords1.lat * DEG2RAD;
        const φ2 = coords2.lat * DEG2RAD;
        const Δφ = (coords2.lat - coords1.lat) * DEG2RAD;
        const Δλ = (coords2.lon - coords1.lon) * DEG2RAD;

        const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
                  Math.cos(φ1) * Math.cos(φ2) *
                  Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

        return R * c; // in metres
      }
    }

    const Evented = {
        on(type, fn, context) {
            this._events = this._events || {};
            this._events[type] = this._events[type] || [];
            this._events[type].push({ fn, context: context || this });
            return this;
        },
        off(type, fn, context) {
            if (!this._events || !this._events[type]) return this;
            this._events[type] = this._events[type].filter(listener =>
                listener.fn !== fn || (context && listener.context !== context)
            );
            return this;
        },
        fire(type, data = {}) {
            if (!this._events || !this._events[type]) return;
            data.type = type;
            data.target = this;
            [...this._events[type]].forEach(listener => {
                listener.fn.call(listener.context, data);
            });
        }
    };

    class Layer {
      constructor(options = {}) { this.options = options; this._map = null; }
      addTo(map) { if (this._map) this._map.removeLayer(this); this._map = map; map.addLayer(this); return this; }
      remove() { if (this._map) { this._map.removeLayer(this); this._map = null; } return this; }
      onAdd() {}
      onRemove() {}
      render() {}
    }
    Object.assign(Layer.prototype, Evented);
    class TileLayer extends Layer {
      constructor(urlTemplate, options = {}) {
        super(options);
        this.urlTemplate = urlTemplate;
        this.options = { minZoom: options.minZoom || 0, maxZoom: options.maxZoom || 18, attribution: options.attribution || '', background: options.background || '#ffffff', supportsRetina: options.supportsRetina || false, maxCacheSize: options.maxCacheSize || 800, ...options };
        this.tileCache = new Map();
        this.loadingTiles = new Set();
        this._retinaAvailable = true;
        this._lastRenderedCenter = null;
        this._lastRenderedZoom = null;
        this._lastRenderedBearing = null;
        this._initWorker();
      }

      _initWorker() {
        const workerCode = `
            const controllers = new Map();

            self.onmessage = async (e) => {
              const { url, key, command, isReload } = e.data;

              if (command === 'abort') {
                const controller = controllers.get(key);
                if (controller) {
                  controller.abort();
                  controllers.delete(key);
                }
                return;
              }

              const controller = new AbortController();
              controllers.set(key, controller);

              try {
                const response = await fetch(url, { signal: controller.signal });
                if (!response.ok) {
                  throw new Error(\`HTTP error! status: \${response.status}\`);
                }
                const blob = await response.blob();
                const imageBitmap = await createImageBitmap(blob);
                self.postMessage({ key, imageBitmap, isReload }, [imageBitmap]);
              } catch (error) {
                if (error.name !== 'AbortError') {
                  self.postMessage({ key, error: error.message, isReload });
                }
              } finally {
                controllers.delete(key);
              }
            };
        `;
        const blob = new Blob([workerCode], { type: 'application/javascript' });
        this._worker = new Worker(URA.createObjectURL(blob));
        this._worker.onmessage = (e) => {
          const { key, imageBitmap, error, isReload } = e.data;

          if (error) {
            console.warn(`[Atlas] Failed to load tile from worker: ${key}`, error);
            this.loadingTiles.delete(key);
            if (this.tileCache.has(key)) this.tileCache.delete(key);
            this.fire('tileerror', { tile: key, error: new Error(error) });
            return;
          }

          const tile = isReload ? this.tileCache.get(key) : { loaded: false, lastUsed: Date.now() };
          if (!tile) return; // Could have been evicted

          tile.img = imageBitmap;
          tile.loaded = true;
          tile.loadedAt = Date.now();

          if (!isReload) {
              this.tileCache.set(key, tile);
          }

          this.loadingTiles.delete(key);
          if (this._map) this._map.scheduleRender();
          this.fire('tileload', { tile: key });
        };
      }

      _getTileUrl(x, y, z) {
        const scale = Math.pow(2, z);
        let wrappedX = ((x % scale) + scale) % scale;
        const intX = Math.floor(wrappedX);
        const intY = Math.max(0, Math.min(scale - 1, Math.floor(y)));
        let url = this.urlTemplate.replace('{z}', z).replace('{x}', intX).replace('{y}', intY);
        if (this.options.supportsRetina && this._shouldRequestRetina()) url += CONFIG.retinaSuffix;
        return url;
      }
      _shouldRequestRetina() {
        const mode = CONFIG.retina;
        return (mode === true) || (mode === "auto" && (window.devicePixelRatio || 1) > 1.5);
      }
      _loadTile(key, url) {
        if (this.tileCache.has(key) || this.loadingTiles.has(key)) return;

        this.loadingTiles.add(key);
        this._worker.postMessage({
            key,
            url,
            isReload: false
        });
      }
      _reloadTile(key, url) {
        if (!this.tileCache.has(key) || this.loadingTiles.has(key)) return;

        this.loadingTiles.add(key);
        this._worker.postMessage({
            key,
            url: url + (url.includes("?") ? "&" : "?") + "v=" + Date.now(),
            isReload: true
        });
      }
      _evict() {
        if (this.tileCache.size <= this.options.maxCacheSize) return;
        if ('requestIdleCallback' in window) requestIdleCallback(() => this._performEviction(), { timeout: 2000 });
        else setTimeout(() => this._performEviction(), 100);
      }
      _performEviction() {
        if (this.tileCache.size <= this.options.maxCacheSize) return;
        const entries = Array.from(this.tileCache.entries()).sort((a, b) => a[1].lastUsed - b[1].lastUsed);
        const removeCount = this.tileCache.size - this.options.maxCacheSize;
        for (let i = 0; i < removeCount; i++) this.tileCache.delete(entries[i][0]);
      }
      _preloadAdjacentZoomTiles() {
        if (!this._map) return;
        const zInt = Math.floor(this._map.zoom);
        const nextZoom = Math.min(this.options.maxZoom, zInt + 1);
        const prevZoom = Math.max(this.options.minZoom, zInt - 1);
        if (Math.abs(this._map.zoom - zInt) > 0.3) return;
        const wrappedCenterLon = GISUtils.wrapLongitude(this._map.center.lon);
        const ct = this._map.projection.latLngToTile({ lat: this._map.center.lat, lon: wrappedCenterLon }, zInt);
        const ts = TILE_SIZE;
        const w = this._map.canvas.width / this._map.dpr;
        const h = this._map.canvas.height / this._map.dpr;
        const viewportTiles = Math.ceil(Math.max(w, h) / ts) + TILE_BUFFER;
        for (let dz of [prevZoom, nextZoom]) {
          if (dz === zInt) continue;
          const scaleDiff = Math.pow(2, Math.abs(dz - zInt));
          const startX = Math.floor(ct.x * (dz > zInt ? scaleDiff : 1 / scaleDiff) - viewportTiles / 2);
          const startY = Math.floor(ct.y * (dz > zInt ? scaleDiff : 1 / scaleDiff) - viewportTiles / 2);
          for (let dx = 0; dx < viewportTiles; dx++) {
            for (let dy = 0; dy < viewportTiles; dy++) {
              const X = startX + dx, Y = startY + dy;
              const key = `${dz}/${X}/${Y}`;
              if (!this.tileCache.has(key) && !this.loadingTiles.has(key)) {
                const url = this._getTileUrl(X, Y, dz);
                this._loadTile(key, url);
              }
            }
          }
        }
      }
      render() {
        if (!this._map) return false;
        let needsReRender = false;
        const w = this._map.canvas.width / this._map.dpr;
        const h = this._map.canvas.height / this._map.dpr;
        const zInt = Math.floor(this._map.zoom);
        const scaleFactor = Math.pow(2, this._map.zoom - zInt);
        const ts = TILE_SIZE;
        const wrappedCenterLon = GISUtils.wrapLongitude(this._map.center.lon);
        const ct = this._map.projection.latLngToTile({ lat: this._map.center.lat, lon: wrappedCenterLon }, zInt);
        const absCos = Math.abs(Math.cos(this._map.bearing)), absSin = Math.abs(Math.sin(this._map.bearing));
        const needW = w * absCos + h * absSin;
        const cols = Math.ceil(needW / (ts * scaleFactor)) + TILE_BUFFER;
        const topLeft = this._map.screenToLatLon(0, 0);
        const topRight = this._map.screenToLatLon(w, 0);
        const bottomLeft = this._map.screenToLatLon(0, h);
        const bottomRight = this._map.screenToLatLon(w, h);
        const maxLat = Math.max(topLeft.lat, topRight.lat, bottomLeft.lat, bottomRight.lat);
        const minLat = Math.min(topLeft.lat, topRight.lat, bottomLeft.lat, bottomRight.lat);
        const topTile = this._map.projection.latLngToTile({lon: 0, lat: maxLat}, zInt);
        const bottomTile = this._map.projection.latLngToTile({lon: 0, lat: minLat}, zInt);
        const tileSpanY = Math.abs(topTile.y - bottomTile.y);
        const rows = Math.ceil(tileSpanY) + TILE_BUFFER;
        const startX = Math.floor(ct.x - cols / 2);
        const startY = Math.floor(ct.y - rows / 2);
        if (!this._renderTilesArray) this._renderTilesArray = [];
        else this._renderTilesArray.length = 0;
        const centerX = cols / 2;
        const centerY = rows / 2;
        for (let dx = 0; dx < cols; dx++) {
          for (let dy = 0; dy < rows; dy++) {
            const X = startX + dx, Y = startY + dy;
            const distSq = (dx - centerX) * (dx - centerX) + (dy - centerY) * (dy - centerY);
            this._renderTilesArray.push({ X, Y, distSq });
          }
        }
        this._renderTilesArray.sort((a, b) => a.distSq - b.distSq);
        const ctx = this._map.ctx;
        ctx.save();
        ctx.translate(w / 2, h / 2);
        ctx.rotate(this._map.bearing);
        ctx.scale(scaleFactor, scaleFactor);
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'low';

        for (const { X, Y } of this._renderTilesArray) {
            const key = `${zInt}/${X}/${Y}`;
            const tile = this.tileCache.get(key);

            if (!tile || !tile.loaded) {
                this._loadTile(key, this._getTileUrl(X, Y, zInt));
                let foundFallback = false;
                for (let i = 1; i <= 3; i++) {
                    const parentZ = zInt - i;
                    if (parentZ < this.options.minZoom) break;
                    const scale = Math.pow(2, i);
                    const parentX = Math.floor(X / scale);
                    const parentY = Math.floor(Y / scale);
                    const parentKey = `${parentZ}/${parentX}/${parentY}`;
                    const parentTile = this.tileCache.get(parentKey);
                    if (parentTile && parentTile.loaded) {
                        const clipX = (X % scale) * (TILE_SIZE / scale);
                        const clipY = (Y % scale) * (TILE_SIZE / scale);
                        const clipSize = TILE_SIZE / scale;
                        ctx.drawImage(parentTile.img, clipX, clipY, clipSize, clipSize, (X - ct.x) * ts, (Y - ct.y) * ts, ts, ts);
                        foundFallback = true;
                        break;
                    }
                }
            }
        }

        for (const { X, Y } of this._renderTilesArray) {
          const key = `${zInt}/${X}/${Y}`;
          const tile = this.tileCache.get(key);
          if (tile && tile.loaded) {
            const FADE_DURATION = 200;
            const timeSinceLoad = Date.now() - tile.loadedAt;
            let opacity = timeSinceLoad < FADE_DURATION ? timeSinceLoad / FADE_DURATION : 1;
            if (opacity < 1) {
                needsReRender = true;
                ctx.globalAlpha = opacity;
                ctx.drawImage(tile.img, (X - ct.x) * ts, (Y - ct.y) * ts, ts, ts);
                ctx.globalAlpha = 1;
            } else {
                ctx.drawImage(tile.img, (X - ct.x) * ts, (Y - ct.y) * ts, ts, ts);
            }
            tile.lastUsed = Date.now();
            if (tile.loadedAt && (Date.now() - tile.loadedAt > TILE_TTL)) {
              this._reloadTile(key, this._getTileUrl(X, Y, zInt));
            }
          }
        }
        ctx.restore();
        this._evict();
        this._preloadAdjacentZoomTiles();
        this._lastRenderedCenter = { ...this._map.center };
        this._lastRenderedZoom = this._map.zoom;
        this._lastRenderedBearing = this._map.bearing;
        return needsReRender;
      }
      onAdd() { this.fire('add'); }
      onRemove() {
        for (const key of this.loadingTiles) {
            this._worker.postMessage({ command: 'abort', key });
        }
        this.loadingTiles.clear();
        this._worker.terminate();
        this.tileCache.clear();
        this.fire('remove');
      }
      getAttribution() { return this.options.attribution; }
      getBackground() { return this.options.background; }
      getMinZoom() { return this.options.minZoom; }
      getMaxZoom() { return this.options.maxZoom; }
    }
    class GeoJSONLayer extends Layer {
      constructor(geojson, options = {}) {
        super(options);
        this._geojson = this._normalizeGeoJSON(geojson);
        this._features = [];
        this._featureCache = new Map();
        this._hitCache = new Map();
        this._lastRenderZoom = null;
        this._lastRenderBearing = null;
        this._lastRenderCenter = null;
        this.options.style = options.style || { color: '#3388ff', weight: 3, opacity: 1, fillColor: '#3388ff', fillOpacity: 0.2 };
        this.options.interactive = options.interactive !== undefined ? options.interactive : true;
        this.options.draggable = options.draggable !== undefined ? options.draggable : false;
        this._draggingFeature = null;
        this._dragStartPoint = null;
        this._originalCoords = null;
        this._onMouseMove = this._onMouseMove.bind(this);
        this._onMouseOut = this._onMouseOut.bind(this);
        this._onClick = this._onClick.bind(this);
        this._onMouseDown = this._onMouseDown.bind(this);
        this._onMouseMoveDrag = this._onMouseMoveDrag.bind(this);
        this._onMouseUp = this._onMouseUp.bind(this);
        this._editing = false;
        this._editHandles = [];
      }
      _normalizeGeoJSON(input) {
        if (Array.isArray(input)) return { type: 'FeatureCollection', features: input.map(f => f.type === 'Feature' ? f : { type: 'Feature', geometry: f, properties: {} }) };
        if (input.type === 'FeatureCollection') return input;
        if (input.type === 'Feature') return { type: 'FeatureCollection', features: [input] };
        return { type: 'FeatureCollection', features: [{ type: 'Feature', geometry: input, properties: {} }] };
      }
      _latLngToScreenPoint(coord) {
        if (!this._map) return { x: 0, y: 0 };
        const [lon, lat] = coord;
        const w = this._map.canvas.width / this._map.dpr;
        const h = this._map.canvas.height / this._map.dpr;
        const zInt = Math.floor(this._map.zoom);
        const ts = TILE_SIZE * Math.pow(2, this._map.zoom - zInt);
        const ct = this._map.projection.latLngToTile(this._map.center, zInt);
        const pt = this._map.projection.latLngToTile({ lat, lon }, zInt);
        const trX = (pt.x - ct.x) * ts;
        const trY = (pt.y - ct.y) * ts;
        const anchorVec = rot(trX, trY, this._map.bearing);
        return { x: w / 2 + anchorVec.x, y: h / 2 + anchorVec.y };
      }
      _getFeatureStyle(feature) { return typeof this.options.style === 'function' ? this.options.style(feature) : this.options.style; }
      _processFeature(feature) {
        const cacheKey = JSON.stringify(feature);
        if (this._featureCache.has(cacheKey)) return this._featureCache.get(cacheKey);
        const geometry = feature.geometry;
        const processed = { type: geometry.type, coordinates: null, properties: feature.properties };
        switch (geometry.type) {
          case 'Point': processed.coordinates = this._latLngToScreenPoint(geometry.coordinates); break;
          case 'MultiPoint': processed.coordinates = geometry.coordinates.map(coord => this._latLngToScreenPoint(coord)); break;
          case 'LineString': processed.coordinates = geometry.coordinates.map(coord => this._latLngToScreenPoint(coord)); break;
          case 'MultiLineString': processed.coordinates = geometry.coordinates.map(ring => ring.map(coord => this._latLngToScreenPoint(coord))); break;
          case 'Polygon': processed.coordinates = geometry.coordinates.map(ring => ring.map(coord => this._latLngToScreenPoint(coord))); break;
          case 'MultiPolygon': processed.coordinates = geometry.coordinates.map(polygon => polygon.map(ring => ring.map(coord => this._latLngToScreenPoint(coord)))); break;
          default: console.warn('[Atlas] Unsupported geometry type:', geometry.type); return null;
        }
        this._featureCache.set(cacheKey, processed);
        return processed;
      }
      _renderPoint(ctx, feature, style) {
        const { x, y } = feature.coordinates;
        ctx.beginPath(); ctx.arc(x, y, style.radius || 5, 0, 2 * Math.PI);
        ctx.fillStyle = style.fillColor || style.color || '#3388ff'; ctx.fill();
        if (style.stroke !== false) { ctx.strokeStyle = style.color || '#3388ff'; ctx.lineWidth = style.weight || 2; ctx.globalAlpha = style.opacity || 1; ctx.stroke(); }
        ctx.globalAlpha = 1;
      }
      _renderLineString(ctx, feature, style) {
        const coords = feature.coordinates;
        if (coords.length < 2) return;
        ctx.beginPath();
        ctx.moveTo(coords[0].x, coords[0].y);
        for (let i = 1; i < coords.length; i++) {
            ctx.lineTo(coords[i].x, coords[i].y);
        }

        if (style.dashArray) {
            ctx.setLineDash(style.dashArray);
        }

        ctx.strokeStyle = style.color || '#3388ff';
        ctx.lineWidth = style.weight || 3;
        ctx.globalAlpha = style.opacity || 1;
        ctx.stroke();

        // Reset dash style for other layers
        if (style.dashArray) {
            ctx.setLineDash([]);
        }
        ctx.globalAlpha = 1;
      }
      _renderPolygon(ctx, feature, style) {
        const rings = feature.coordinates;
        if (rings.length === 0) return;
        ctx.beginPath();
        for (const ring of rings) {
          if (ring.length < 3) continue;
          ctx.moveTo(ring[0].x, ring[0].y);
          for (let i = 1; i < ring.length; i++) ctx.lineTo(ring[i].x, ring[i].y);
          ctx.closePath();
        }
        if (style.fill !== false) { ctx.fillStyle = style.fillColor || style.color || '#3388ff'; ctx.globalAlpha = style.fillOpacity || 0.2; ctx.fill(); ctx.globalAlpha = 1; }
        if (style.stroke !== false) { ctx.strokeStyle = style.color || '#3388ff'; ctx.lineWidth = style.weight || 3; ctx.globalAlpha = style.opacity || 1; ctx.stroke(); ctx.globalAlpha = 1; }
      }
      _pointInPolygon(x, y, ring) {
        let inside = false;
        for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
          const xi = ring[i].x, yi = ring[i].y;
          const xj = ring[j].x, yj = ring[j].y;
          const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
          if (intersect) inside = !inside;
        }
        return inside;
      }
      _hitDetect(x, y) {
        const viewKey = `${this._map.zoom.toFixed(6)}_${this._map.bearing}_${this._map.center.lon}_${this._map.center.lat}`;
        if (!this._hitCache.has(viewKey)) {
          const hitMap = new Map();
          for (const feature of this._features) {
            const processed = this._processFeature(feature);
            if (!processed) continue;
            switch (processed.type) {
              case 'Point':
                const dist = Math.hypot(x - processed.coordinates.x, y - processed.coordinates.y);
                if (dist <= (this._getFeatureStyle(feature).radius || 5) + 5) hitMap.set(`${x}_${y}`, feature);
                break;
              case 'Polygon':
                for (const ring of processed.coordinates) {
                  if (this._pointInPolygon(x, y, ring)) { hitMap.set(`${x}_${y}`, feature); break; }
                }
                break;
            }
          }
          this._hitCache.set(viewKey, hitMap);
        }
        return this._hitCache.get(viewKey).get(`${x}_${y}`) || null;
      }
      _onMouseMove(e) {
        if (this._draggingFeature) return;
        const rect = this._map.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const feature = this._hitDetect(x, y);

        if (feature !== this._hoveredFeature) {
            if (this._hoveredFeature) {
                this.fire('mouseout', { originalEvent: e, feature: this._hoveredFeature });
            }
            if (feature) {
                this.fire('mouseover', { originalEvent: e, feature: feature });
            }
        }

        this._hoveredFeature = feature;

        if (feature) {
            this._map.canvas.style.cursor = 'pointer';
            this.fire('mousemove', { originalEvent: e, feature });
        } else {
            this._map.canvas.style.cursor = 'grab';
        }
      }
      _onMouseOut(e) {
        this._map.canvas.style.cursor = 'grab';
        this.fire('mouseout', { originalEvent: e });
      }
      _onClick(e) {
        const rect = this._map.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const feature = this._hitDetect(x, y);
        if (feature) this.fire('click', { originalEvent: e, feature });
      }
      _onMouseDown(e) {
        if (!this.options.draggable || e.button !== 0) return; // Left mouse button only
        const rect = this._map.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        // Check if we clicked on a point feature
        const feature = this._hitDetect(x, y);
        if (feature && feature.geometry.type === 'Point') {
          e.preventDefault();
          this._startDrag(feature, x, y);
        }
      }
      _startDrag(feature, clientX, clientY) {
        this._draggingFeature = feature;
        this._dragStartPoint = { x: clientX, y: clientY };
        this._originalCoords = [...feature.geometry.coordinates]; // [lon, lat]
        // Change cursor to indicate dragging
        this._map.canvas.style.cursor = 'grabbing';
        this._map.container.classList.add('dragging');
        // Add mousemove listener for the drag
        document.addEventListener('mousemove', this._onMouseMoveDrag);
        document.addEventListener('mouseup', this._onMouseUp);
      }
      _onMouseMoveDrag(e) {
        if (!this._draggingFeature) return;
        e.preventDefault();
        const rect = this._map.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        // Calculate the new LatLng for the point
        const newLatLng = this._map.screenToLatLon(x, y);
        // Update the feature's geometry
        this._draggingFeature.geometry.coordinates = [newLatLng.lon, newLatLng.lat];
        // Clear caches so the point is re-rendered at the new position
        this._featureCache.clear();
        this._hitCache.clear();
        // Re-render the map
        if (this._map) this._map.render();
        // Fire a drag event
        this.fire('drag', {
          originalEvent: e,
          feature: this._draggingFeature,
          latlng: newLatLng
        });
      }
      _onMouseUp(e) {
        if (!this._draggingFeature) return;
        const rect = this._map.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        // Calculate final position
        const finalLatLng = this._map.screenToLatLon(x, y);
        // Update feature one last time
        this._draggingFeature.geometry.coordinates = [finalLatLng.lon, finalLatLng.lat];
        this._featureCache.clear();
        this._hitCache.clear();
        // Reset state
        this._draggingFeature = null;
        this._dragStartPoint = null;
        this._originalCoords = null;
        // Reset cursor
        this._map.canvas.style.cursor = 'grab';
        this._map.container.classList.remove('dragging');
        // Remove the temporary mousemove listener
        document.removeEventListener('mousemove', this._onMouseMoveDrag);
        document.removeEventListener('mouseup', this._onMouseUp);
        // Fire dragend event
        this.fire('dragend', {
          originalEvent: e,
          feature: this._draggingFeature,
          latlng: finalLatLng
        });
        // Re-render
        if (this._map) this._map.render();
      }

      enableEdit() {
        if (this._editing || !this._map) { return this; }
        this._editing = true;
        this._createEditHandles();
        this._map.on('move', this._updateEditHandles, this);
        this.fire('edit:enabled');
        return this;
      }

      disableEdit() {
        if (!this._editing) { return this; }
        this._editing = false;
        this._removeEditHandles();
        this._map.off('move', this._updateEditHandles, this);
        this.fire('edit:disabled');
        return this;
      }

      isEditing() {
        return this._editing;
      }

      _createEditHandles() {
        this._removeEditHandles();
        const pane = this._map.getPane('markerPane');
        this._features.forEach(feature => {
            if (feature.geometry.type !== 'Polygon' && feature.geometry.type !== 'LineString') return;

            const processRing = (ring, ringIndex) => {
                ring.forEach((coord, coordIndex) => {
                    const handle = this._createHandle(feature, ringIndex, coordIndex);
                    pane.appendChild(handle);
                    this._editHandles.push(handle);
                });
            };

            if (feature.geometry.type === 'Polygon') {
                feature.geometry.coordinates.forEach(processRing);
            } else { // LineString
                processRing(feature.geometry.coordinates, null);
            }
        });
        this._updateEditHandles();
      }

      _removeEditHandles() {
        this._editHandles.forEach(handle => handle.parentNode.removeChild(handle));
        this._editHandles = [];
      }

      _updateEditHandles() {
        if (!this._editing) return;
        let handleIndex = 0;
        this._features.forEach(feature => {
            if (feature.geometry.type !== 'Polygon' && feature.geometry.type !== 'LineString') return;

            const processRing = (ring) => {
                ring.forEach(coord => {
                    if (this._editHandles[handleIndex]) {
                        const pos = this._map.latLngToContainerPoint({ lat: coord[1], lon: coord[0] });
                        this._editHandles[handleIndex].style.transform = `translate(${pos.x - 6}px, ${pos.y - 6}px)`;
                    }
                    handleIndex++;
                });
            };

            if (feature.geometry.type === 'Polygon') {
                feature.geometry.coordinates.forEach(processRing);
            } else {
                processRing(feature.geometry.coordinates);
            }
        });
      }

      _createHandle(feature, ringIndex, coordIndex) {
        const handle = document.createElement('div');
        handle.className = 'atlas-edit-handle';

        handle.onmousedown = (e) => {
            e.stopPropagation();
            e.preventDefault();
            this._map.getHandler('dragPan').disable();

            const onMouseMove = (moveEvent) => {
                const newLatLng = this._map.screenToLatLon(moveEvent.clientX, moveEvent.clientY);
                const newCoord = [newLatLng.lon, newLatLng.lat];

                if (feature.geometry.type === 'Polygon') {
                    feature.geometry.coordinates[ringIndex][coordIndex] = newCoord;
                } else { // LineString
                    feature.geometry.coordinates[coordIndex] = newCoord;
                }

                this._featureCache.clear();
                this._map.render();
                this._updateEditHandles();
                this.fire('edit', { feature });
            };

            const onMouseUp = () => {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                this._map.getHandler('dragPan').enable();
                this.fire('edit:vertex:dragend', { feature });
            };

            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            this.fire('edit:vertex:dragstart', { feature });
        };
        return handle;
      }

      onAdd() {
        this._features = this._geojson.features || [];
        if (this.options.interactive) {
          this._map.canvas.addEventListener('mousemove', this._onMouseMove);
          this._map.canvas.addEventListener('mouseout', this._onMouseOut);
          this._map.canvas.addEventListener('click', this._onClick);
          if (this.options.draggable) {
            this._map.canvas.addEventListener('mousedown', this._onMouseDown);
          }
        }
        if (this._editing) {
            this.enableEdit();
        }
        this.fire('add');
      }

      onRemove() {
        if (this.options.interactive) {
          this._map.canvas.removeEventListener('mousemove', this._onMouseMove);
          this._map.canvas.removeEventListener('mouseout', this._onMouseOut);
          this._map.canvas.removeEventListener('click', this._onClick);
          if (this.options.draggable) {
            this._map.canvas.removeEventListener('mousedown', this._onMouseDown);
            document.removeEventListener('mousemove', this._onMouseMoveDrag);
            document.removeEventListener('mouseup', this._onMouseUp);
          }
        }
        if (this._editing) {
            this.disableEdit();
        }
        this._featureCache.clear();
        this._hitCache.clear();
        this.fire('remove');
      }
      render() {
        if (!this._map) return;
        const ctx = this._map.ctx;
        const needsRebuild = (
          this._lastRenderZoom !== this._map.zoom ||
          this._lastRenderBearing !== this._map.bearing ||
          this._lastRenderCenter?.lon !== this._map.center.lon ||
          this._lastRenderCenter?.lat !== this._map.center.lat
        );
        if (needsRebuild) {
          this._featureCache.clear();
          this._hitCache.clear();
          this._lastRenderZoom = this._map.zoom;
          this._lastRenderBearing = this._map.bearing;
          this._lastRenderCenter = { ...this._map.center };
        }
        for (const feature of this._features) {
          const processed = this._processFeature(feature);
          if (!processed) continue;
          const style = this._getFeatureStyle(feature);
          switch (processed.type) {
            case 'Point': this._renderPoint(ctx, processed, style); break;
            case 'LineString': this._renderLineString(ctx, processed, style); break;
            case 'Polygon': this._renderPolygon(ctx, processed, style); break;
          }
        }
      }
      setData(geojson) {
        this._geojson = this._normalizeGeoJSON(geojson);
        this._features = this._geojson.features || [];
        this._featureCache.clear();
        this._hitCache.clear();
        if (this._map) this._map.render();
        return this;
      }
      getData() { return this._geojson; }
    }

    /* >>>> ADDED: Icon and Marker Classes <<<< */
    class Icon {
        constructor(options = {}) {
            this.options = {
                iconUrl: options.iconUrl || '',
                shadowUrl: options.shadowUrl || '',
                iconSize: options.iconSize || [25, 41],
                iconAnchor: options.iconAnchor || [12, 41],
                shadowSize: options.shadowSize || [41, 41],
                shadowAnchor: options.shadowAnchor || [12, 41]
            };
        }

        createIcon() {
            const img = document.createElement('img');
            img.src = this.options.iconUrl;
            img.className = 'atlas-marker-icon';
            this._setIconStyles(img, this.options.iconSize);
            return img;
        }

        createShadow() {
            if (!this.options.shadowUrl) return null;
            const shadow = document.createElement('img');
            shadow.src = this.options.shadowUrl;
            shadow.className = 'atlas-marker-shadow';
            this._setIconStyles(shadow, this.options.shadowSize);
            return shadow;
        }

        _setIconStyles(el, size) {
            el.style.width = `${size[0]}px`;
            el.style.height = `${size[1]}px`;
        }
    }

    class LocationMarker extends Layer {
        constructor(latlng, accuracy, options = {}) {
            super(options);
            this._latlng = latlng;
            this._accuracy = accuracy;
        }

        onAdd() {
            this._container = document.createElement('div');
            this._container.className = 'atlas-location-marker';

            this._dot = document.createElement('div');
            this._dot.className = 'dot';

            this._accuracyCircle = document.createElement('div');
            this._accuracyCircle.className = 'accuracy-circle';

            this._container.appendChild(this._accuracyCircle);
            this._container.appendChild(this._dot);

            this._map.getPane('markerPane').appendChild(this._container);
            this._updatePosition();
            this._map.on('move', this._updatePosition, this);
        }

        onRemove() {
            if (this._container && this._container.parentNode) {
                this._container.parentNode.removeChild(this._container);
            }
            this._map.off('move', this._updatePosition, this);
        }

        _updatePosition() {
            if (!this._map) return;
            const pos = this._map.latLngToContainerPoint(this._latlng);
            this._container.style.transform = `translate(${pos.x}px, ${pos.y}px)`;

            const radius = this._accuracy / GISUtils.getResolution(this._latlng.lat, this._map.getZoom());
            this._accuracyCircle.style.width = `${radius * 2}px`;
            this._accuracyCircle.style.height = `${radius * 2}px`;
            this._accuracyCircle.style.marginLeft = `${-radius}px`;
            this._accuracyCircle.style.marginTop = `${-radius}px`;

            this._dot.style.marginLeft = '-8px';
            this._dot.style.marginTop = '-8px';
        }

        setLatLng(latlng) {
            this._latlng = latlng;
            this._updatePosition();
            return this;
        }

        setAccuracy(accuracy) {
            this._accuracy = accuracy;
            this._updatePosition();
            return this;
        }
    }

    class DefaultIcon extends Icon {
        constructor(options = {}) {
            super(options);
            this.options.iconUrl = "data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 28 41'%3E%3Cpath fill='%233388FF' stroke='%23FFFFFF' stroke-width='1.5' d='M14,0 C6.27,0 0,6.27 0,14 C0,24.5 14,41 14,41 C14,41 28,24.5 28,14 C28,6.27 21.73,0 14,0 Z'/%3E%3Ccircle fill='%23FFFFFF' cx='14' cy='14' r='6'/%3E%3C/svg%3E";
            this.options.shadowUrl = "data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 41 41'%3E%3Cellipse cx='20.5' cy='20.5' rx='15' ry='7.5' fill='%23000000'/%3E%3C/svg%3E";
            this.options.iconSize = [28, 41];
            this.options.iconAnchor = [14, 41];
            this.options.shadowSize = [41, 41];
            this.options.shadowAnchor = [14, 41];
        }
    }

    class Marker extends Layer {
        constructor(latlng, options = {}) {
            super(options);
            this._latlng = { ...latlng };
            this.options.icon = options.icon || new DefaultIcon();
            this.options.interactive = options.interactive !== false;
            this.options.draggable = options.draggable || false;
            this._element = null;
            this._shadow = null;
        }

        onAdd() {
            this._initIcon();
            if (this.options.interactive) {
                this._addEventListeners();
            }
            this._map.getPane('markerPane').appendChild(this._element);
            this._updatePosition();
            this.fire('add');
        }

        onRemove() {
            if (this._element && this._element.parentNode) {
                this._element.parentNode.removeChild(this._element);
            }
            if (this._shadow && this._shadow.parentNode) {
                this._shadow.parentNode.removeChild(this._shadow);
            }
            this._removeEventListeners();
            this.fire('remove');
        }

        _initIcon() {
            this._element = this.options.icon.createIcon();
            this._shadow = this.options.icon.createShadow();
            if (this._shadow) {
                this._map.getPane('markerPane').appendChild(this._shadow);
            }
        }

        _addEventListeners() {
            this._element.addEventListener('click', (e) => this.fire('click', { originalEvent: e }));
            if (this.options.draggable) {
                this._element.addEventListener('mousedown', this._onDragStart.bind(this));
            } else {
                this._element.addEventListener('mousedown', (e) => this.fire('mousedown', { originalEvent: e }));
            }
        }

        _removeEventListeners() {
            this._element.removeEventListener('mousedown', this._onDragStart.bind(this));
        }

        _onDragStart(e) {
            if (e.button !== 0) return;
            e.preventDefault();
            this._map.getHandler('dragPan').disable();
            this._isDragging = true;
            this._dragStartX = e.clientX;
            this._dragStartY = e.clientY;
            this._originalLatLng = { ...this._latlng };

            document.addEventListener('mousemove', this._onDrag = this._onDrag.bind(this));
            document.addEventListener('mouseup', this._onDragEnd = this._onDragEnd.bind(this));

            this.fire('movestart');
            this.fire('dragstart');
        }

        _onDrag(e) {
            if (!this._isDragging) return;
            e.preventDefault();

            const currentPoint = this._map.latLngToContainerPoint(this._originalLatLng);
            const newPoint = {
                x: currentPoint.x + (e.clientX - this._dragStartX),
                y: currentPoint.y + (e.clientY - this._dragStartY)
            };

            this.setLatLng(this._map.screenToLatLon(newPoint.x, newPoint.y));

            this.fire('move', { latlng: this._latlng });
            this.fire('drag', { latlng: this._latlng });
        }

        _onDragEnd(e) {
            e.preventDefault();
            this._isDragging = false;
            document.removeEventListener('mousemove', this._onDrag);
            document.removeEventListener('mouseup', this._onDragEnd);
            this._map.getHandler('dragPan').enable();

            this.fire('moveend');
            this.fire('dragend');
        }

        render() {
            this._updatePosition();
        }

        _updatePosition() {
            if (!this._map || !this._element) return;
            const pos = this._map.latLngToContainerPoint(this._latlng);
            this._setElementPos(this._element, pos, this.options.icon.options.iconAnchor);
            if (this._shadow) {
                this._setElementPos(this._shadow, pos, this.options.icon.options.shadowAnchor);
            }
        }

        _setElementPos(el, pos, anchor) {
            el.style.left = `${pos.x - anchor[0]}px`;
            el.style.top = `${pos.y - anchor[1]}px`;
        }

        getLatLng() {
            return { ...this._latlng };
        }

        setLatLng(latlng) {
            this._latlng = { ...latlng };
            this.render();
            return this;
        }
    }

    class Popup extends Layer {
        constructor(options = {}, source) {
            super(options);
            this.options.offset = options.offset || [0, -7];
            this.options.className = options.className || '';
            this._source = source;
            this._content = options.content || '';
        }

        onAdd() {
            this._initLayout();
            this._updatePosition();
            this._map.getPane('popupPane').appendChild(this._container);
            this.fire('open');
            this._map.on('move', this._updatePosition, this);
        }

        onRemove() {
            if (this._container && this._container.parentNode) {
                this._container.parentNode.removeChild(this._container);
            }
            this.fire('close');
            this._map.off('move', this._updatePosition, this);
        }

        setContent(content) {
            this._content = content;
            if (this._contentNode) {
                if (typeof content === 'string') {
                    this._contentNode.innerHTML = content;
                } else {
                    this._contentNode.innerHTML = '';
                    this._contentNode.appendChild(content);
                }
            }
            return this;
        }

        _initLayout() {
            this._container = document.createElement('div');
            this._container.className = 'atlas-popup ' + (this.options.className || '');

            const contentWrapper = document.createElement('div');
            contentWrapper.className = 'atlas-popup-content-wrapper';

            this._contentNode = document.createElement('div');
            this._contentNode.className = 'atlas-popup-content';
            this.setContent(this._content);

            const closeButton = document.createElement('a');
            closeButton.className = 'atlas-popup-close-button';
            closeButton.href = '#close';
            closeButton.innerHTML = '&#215;';
            closeButton.onclick = (e) => {
                e.preventDefault();
                this._map.closePopup(this);
            };

            const tipContainer = document.createElement('div');
            tipContainer.className = 'atlas-popup-tip-container';
            const tip = document.createElement('div');
            tip.className = 'atlas-popup-tip';

            contentWrapper.appendChild(this._contentNode);
            contentWrapper.appendChild(closeButton);
            tipContainer.appendChild(tip);
            this._container.appendChild(contentWrapper);
            this._container.appendChild(tipContainer);
        }

        _updatePosition() {
            if (!this._map) return;
            const pos = this._map.latLngToContainerPoint(this._latlng || this._source.getLatLng());
            const icon = this._source.options.icon;
            const yOffset = icon ? icon.options.iconAnchor[1] : 20;
            const xOffset = this.options.offset[0];
            const yFinalOffset = yOffset + this.options.offset[1];

            this._container.style.transform = `translate3d(${pos.x + xOffset}px, ${pos.y - yFinalOffset}px, 0)`;
        }
    }

    // Add Popup methods to Layer prototype
    Object.assign(Layer.prototype, {
        bindPopup: function(content, options) {
            this._popup = new Popup({ content, ...options }, this);
            this.on('click', () => this.togglePopup());
            return this;
        },

        openPopup: function() {
            if (this._popup && !this._map.hasLayer(this._popup)) {
                this._map.openPopup(this._popup);
            }
            return this;
        },

        closePopup: function() {
            if (this._popup) {
                this._map.closePopup(this._popup);
            }
            return this;
        },

        togglePopup: function() {
            if (this._popup) {
                if (this._map.hasLayer(this._popup)) {
                    this.closePopup();
                } else {
                    this.openPopup();
                }
            }
            return this;
        }
    });

    class Tooltip extends Layer {
        constructor(options = {}, source) {
            super(options);
            this._source = source;
            this._content = options.content || '';
        }

        onAdd() {
            this._initLayout();
            this._updatePosition();
            this._map.getPane('tooltipPane').appendChild(this._container);
            this._map.on('move', this._updatePosition, this);
        }

        onRemove() {
            if (this._container && this._container.parentNode) {
                this._container.parentNode.removeChild(this._container);
            }
            this._map.off('move', this._updatePosition, this);
        }

        setContent(content) {
            this._content = content;
            if (this._container) {
                if (typeof content === 'string') {
                    this._container.innerHTML = content;
                } else {
                    this._container.innerHTML = '';
                    this._container.appendChild(content);
                }
            }
            return this;
        }

        _initLayout() {
            this._container = document.createElement('div');
            this._container.className = 'atlas-tooltip';
            this.setContent(this._content);
        }

        _updatePosition() {
            if (!this._map) return;
            const pos = this._map.latLngToContainerPoint(this._latlng || this._source.getLatLng());
            const offset = { x: 10, y: -10 }; // Default offset
            this._container.style.transform = `translate(${pos.x + offset.x}px, ${pos.y + offset.y}px)`;
        }
    }

    Object.assign(Layer.prototype, {
        bindTooltip: function(content, options) {
            this._tooltip = new Tooltip({ content, ...options }, this);
            this.on('mouseover', () => this.openTooltip());
            this.on('mouseout', () => this.closeTooltip());
            return this;
        },
        openTooltip: function() {
            if (this._tooltip && !this._map.hasLayer(this._tooltip)) {
                this._map.openTooltip(this._tooltip);
            }
            return this;
        },
        closeTooltip: function() {
            if (this._tooltip) {
                this._map.closeTooltip(this._tooltip);
            }
            return this;
        }
    });


    class Control {
      constructor(options = {}) {
        this.options = { position: options.position || 'top-left' };
        this._map = null;
        this._container = null;
        this._events = {};
      }
      on(type, fn) { if (!this._events[type]) this._events[type] = []; this._events[type].push(fn); return this; }
      off(type, fn) { if (!this._events[type]) return this; this._events[type] = this._events[type].filter(cb => cb !== fn); return this; }
      fire(type, data = {}) { if (!this._events[type]) return; data.type = type; data.target = this; this._events[type].forEach(fn => fn(data)); }
      onAdd() { return document.createElement('div'); }
      onRemove() {}
      addTo(map) {
        this.remove();
        this._map = map;
        this._container = this.onAdd();
        this._container.controlInstance = this;
        this._addToContainer();
        return this;
      }
      remove() {
        if (!this._map) return this;
        this.onRemove();
        if (this._container && this._container.parentNode) this._container.parentNode.removeChild(this._container);
        this._map = null;
        this._container = null;
        return this;
      }
      getContainer() { return this._container; }
      _addToContainer() {
        if (!this._map || !this._container) return;
        const position = this.options.position;
        let container = this._map._controlCorners[position];
        if (!container) {
          container = document.createElement('div');
          container.className = `atlas-control-container atlas-control-${position}`;
          if (position.includes('top') || position.includes('bottom')) container.classList.add('atlas-control-vertical');
          else container.classList.add('atlas-control-horizontal');
          this._map.container.appendChild(container);
          this._map._controlCorners[position] = container;
        }
        container.appendChild(this._container);
      }
    }
    class ZoomControl extends Control {
      constructor(options = {}) {
        super(options);
        this.options = { ...this.options, zoomInTitle: options.zoomInTitle || 'Zoom in', zoomOutTitle: options.zoomOutTitle || 'Zoom out' };
      }
      onAdd() {
        const container = document.createElement('div');
        container.className = 'atlas-zoom-control';
        const zoomInBtn = document.createElement('button');
        zoomInBtn.className = 'control-btn';
        zoomInBtn.title = this.options.zoomInTitle;
        zoomInBtn.setAttribute('aria-label', this.options.zoomInTitle);
        zoomInBtn.innerHTML = '<svg viewBox="0 0 24 24"><path fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 5v14m-7-7h14"/></svg>';
        zoomInBtn.onclick = () => { if (this._map) { this._map.stopAnimations(); this._map.setZoom(this._map.getZoom() + 1); } };

        const zoomOutBtn = document.createElement('button');
        zoomOutBtn.className = 'control-btn';
        zoomOutBtn.title = this.options.zoomOutTitle;
        zoomOutBtn.setAttribute('aria-label', this.options.zoomOutTitle);
        zoomOutBtn.innerHTML = '<svg viewBox="0 0 24 24"><path fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 12h14"/></svg>';
        zoomOutBtn.onclick = () => { if (this._map) { this._map.stopAnimations(); this._map.setZoom(this._map.getZoom() - 1); } };
        container.appendChild(zoomInBtn);
        container.appendChild(zoomOutBtn);
        this._zoomInBtn = zoomInBtn;
        this._zoomOutBtn = zoomOutBtn;
        return container;
      }
      onRemove() {}
      _update() {
        if (!this._map || !this._zoomInBtn || !this._zoomOutBtn) return;
        const minZoom = this._map.getBaseLayer() ? this._map.getBaseLayer().getMinZoom() : 0;
        const maxZoom = this._map.getBaseLayer() ? this._map.getBaseLayer().getMaxZoom() : 18;
        const currentZoom = this._map.getZoom();
        this._zoomInBtn.disabled = currentZoom >= maxZoom;
        this._zoomOutBtn.disabled = currentZoom <= minZoom;
      }
    }
    class LayerControl extends Control {
        constructor(baseLayers, overlays, options = {}) {
            super({ position: 'top-right', ...options });
            this._baseLayers = baseLayers || {};
            this._overlays = overlays || {};
            this._collapsed = true;
        }

        onAdd(map) {
            this._initLayout();
            this._update();
            this._map.on('layeradd layerremove', this._onLayersChange, this);
            return this._container;
        }

        onRemove(map) {
            this._map.off('layeradd layerremove', this._onLayersChange, this);
        }

        _initLayout() {
            const className = 'atlas-layers-control';
            this._container = document.createElement('div');
            this._container.className = className;

            this._container.addEventListener('mousedown', e => e.stopPropagation());
            this._container.addEventListener('dblclick', e => e.stopPropagation());
            this._container.addEventListener('click', e => e.stopPropagation());

            this._layersLink = document.createElement('a');
            this._layersLink.className = 'atlas-layers-control-toggle control-btn';
            this._layersLink.href = '#';
            this._layersLink.title = 'Layers';
            this._layersLink.setAttribute('role', 'button');
            this._layersLink.setAttribute('aria-label', 'Toggle layers');

            this._form = document.createElement('form');
            this._form.className = 'atlas-layers-list';
            this._form.style.display = 'none';

            this._layersLink.onclick = (e) => {
                e.preventDefault();
                e.stopPropagation();
                this._toggle();
            };

            this._map.on('click', ()=>this._collapse(), this);

            this._container.appendChild(this._layersLink);
            this._container.appendChild(this._form);
        }

        _toggle() {
            this._collapsed = !this._collapsed;
            this._update();
        }

        _collapse() {
            this._collapsed = true;
            this._update();
        }

        _update() {
            if (!this._container) return;

            this._form.innerHTML = '';
            this._baseLayersList = document.createElement('div');
            this._overlaysList = document.createElement('div');
            this._baseLayersList.className = 'atlas-layers-base';
            this._overlaysList.className = 'atlas-layers-overlays';

            let hasOverlays = Object.keys(this._overlays).length > 0;
            let hasBaseLayers = Object.keys(this._baseLayers).length > 0;

            for (const name in this._baseLayers) {
                this._addLayerInput(this._baseLayers[name], name, this._baseLayersList, false);
            }

            for (const name in this._overlays) {
                this._addLayerInput(this._overlays[name], name, this._overlaysList, true);
            }

            if (hasBaseLayers) {
                this._form.appendChild(this._baseLayersList);
            }
            if (hasOverlays && hasBaseLayers) {
                const separator = document.createElement('div');
                separator.className = 'atlas-layers-separator';
                this._form.appendChild(separator);
            }
            if (hasOverlays) {
                this._form.appendChild(this._overlaysList);
            }

            if (this._collapsed) {
                this._form.style.display = 'none';
                this._container.classList.remove('atlas-layers-control-expanded');
            } else {
                this._form.style.display = 'block';
                this._container.classList.add('atlas-layers-control-expanded');
            }
        }

        _addLayerInput(layer, name, container, isOverlay) {
            const label = document.createElement('label');
            const input = document.createElement('input');
            input.type = isOverlay ? 'checkbox' : 'radio';
            input.name = isOverlay ? 'atlas-overlay-layer' : 'atlas-base-layer';
            input.checked = this._map.hasLayer(layer);

            input.addEventListener('change', () => {
                if (isOverlay) {
                    if (input.checked) {
                        this._map.addLayer(layer);
                    } else {
                        this._map.removeLayer(layer);
                    }
                } else {
                    if (input.checked) {
                        this._map.setBaseLayer(layer);
                    }
                }
            });

            const nameSpan = document.createElement('span');
            nameSpan.textContent = ` ${name}`;

            label.appendChild(input);
            label.appendChild(nameSpan);
            container.appendChild(label);
        }

        _onLayersChange() {
            this._update();
        }
    }
    class FullscreenControl extends Control {
      constructor(options = {}) {
        super(options);
        this.options = { ...this.options, title: options.title || 'Toggle fullscreen' };
      }
      onAdd() {
        const container = document.createElement('div');
        container.className = 'atlas-fullscreen-control';
        const fullscreenBtn = document.createElement('button');
        fullscreenBtn.className = 'control-btn';
        fullscreenBtn.title = this.options.title;
        fullscreenBtn.setAttribute('aria-label', this.options.title);
        fullscreenBtn.innerHTML = '<svg viewBox="0 0 24 24"><path fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>';

        const updateIcon = () => {
            if (document.fullscreenElement === this._map.container) {
                fullscreenBtn.innerHTML = '<svg viewBox="0 0 24 24"><path fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 8h3a2 2 0 0 0 2-2V3m11 5h-3a2 2 0 0 1-2-2V3m-2 18v-3a2 2 0 0 1 2-2h3M3 14v-3a2 2 0 0 1 2-2h3"/></svg>';
            } else {
                fullscreenBtn.innerHTML = '<svg viewBox="0 0 24 24"><path fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>';
            }
        };

        fullscreenBtn.onclick = () => {
          if (!document.fullscreenElement) {
            this._map.container.requestFullscreen().catch(err => console.warn(`[Atlas] Error enabling fullscreen: ${err.message}`));
          } else {
            document.exitFullscreen().catch(err => console.warn(`[Atlas] Error exiting fullscreen: ${err.message}`));
          }
        };

        document.addEventListener('fullscreenchange', updateIcon);

        container.appendChild(fullscreenBtn);
        this._fullscreenBtn = fullscreenBtn;
        return container;
      }
      onRemove() {}
    }
    class AttributionControl extends Control {
      constructor(options = {}) {
        super(options);
        this.options = { ...this.options, prefix: options.prefix || '' };
      }
      onAdd() {
        const container = document.createElement('div');
        container.className = 'atlas-attribution-control';
        container.id = 'attribution';
        container.innerHTML = '';
        this._container = container;
        return container;
      }
      onRemove() {}
      _update() {
        if (!this._map || !this._container) return;
        const attributions = [];
        const baseLayer = this._map.getBaseLayer();
        if (baseLayer && baseLayer instanceof TileLayer) {
          const baseAttr = baseLayer.getAttribution();
          if (baseAttr) attributions.push(baseAttr);
        }
        for (const layer of this._map._layers) {
          if (layer instanceof TileLayer && layer !== baseLayer) {
            const attr = layer.getAttribution();
            if (attr && !attributions.includes(attr)) {
              attributions.push(attr);
            }
          }
        }
        attributions.push('<a href="https://github.com/your-org/atlasjs" target="_blank" rel="noopener noreferrer">Atlas.js</a>');
        this._container.innerHTML = attributions.join(' | ');
      }
    }
    class CompassControl extends Control {
      constructor(options = {}) {
        super(options);
        this.options = { ...this.options, title: options.title || 'Reset North' };
      }
      onAdd() {
        const container = document.createElement('div');
        container.className = 'atlas-compass-control';
        const compassBtn = document.createElement('button');
        compassBtn.id = 'compass';
        compassBtn.className = 'control-btn';
        compassBtn.title = this.options.title;
        compassBtn.setAttribute('aria-label', this.options.title);
        compassBtn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M12 2L6 22l6-5 6 5-6-20z" fill="#666"/><path d="M12 2L6 22l6-5" fill="#f44336"/></svg>';
        compassBtn.style.display = 'none';
        compassBtn.style.padding = '6px'; // Adjust padding for the SVG
        compassBtn.onclick = () => {
          if (this._map) {
            const w = this._map.canvas.width / this._map.dpr;
            const h = this._map.canvas.height / this._map.dpr;
            this._map.animateZoomRotateAbout(w / 2, h / 2, this._map.getZoom(), 0, SNAP_DURATION);
          }
        };
        compassBtn.onmouseenter = () => { compassBtn.style.background = "rgba(240, 240, 240, 0.95)"; };
        compassBtn.onmouseleave = () => { compassBtn.style.background = "rgba(255, 255, 255, 0.9)"; };
        compassBtn.onmousedown = () => { compassBtn.style.transform = "scale(0.98) rotate(" + (-this._map.getBearing() * RAD2DEG) + "deg)"; };
        compassBtn.onmouseup = () => { compassBtn.style.transform = "rotate(" + (-this._map.getBearing() * RAD2DEG) + "deg)"; };
        container.appendChild(compassBtn);
        this._compassBtn = compassBtn;
        return container;
      }
      onRemove() {}
      _update() {
        if (!this._compassBtn || !this._map) return;
        const visible = Math.abs(this._map.getBearing()) > 0.001;
        this._compassBtn.style.display = visible ? "block" : "none";
        this._compassBtn.style.transform = `rotate(${-this._map.getBearing() * RAD2DEG}deg)`;
      }
    }

    class ScaleControl extends Control {
        constructor(options = {}) {
            super({ position: 'bottom-left', ...options });
            this.options.maxWidth = options.maxWidth || 100; // in pixels
        }

        onAdd() {
            const container = document.createElement('div');
            container.className = 'atlas-scale-control';
            this._container = container;
            this._map.on('move', this._update, this);
            this._update();
            return container;
        }

        onRemove() {
            this._map.off('move', this._update, this);
        }

        _update() {
            const centerLat = this._map.getCenter().lat;
            const zoom = this._map.getZoom();
            const maxMeters = GISUtils.getResolution(centerLat, zoom) * this.options.maxWidth * this._map.dpr;

            const getRoundNum = (num) => {
                const pow10 = Math.pow(10, (Math.floor(num) + '').length - 1);
                let d = pow10 / 10;
                num = Math.ceil(num / d) * d;
                return num;
            };

            const meters = getRoundNum(maxMeters);
            const label = meters < 1000 ? `${meters} m` : `${meters / 1000} km`;
            const scaleWidth = (meters / maxMeters) * this.options.maxWidth;

            this._container.style.width = `${scaleWidth}px`;
            this._container.innerHTML = label;
        }
    }

    class GeolocationControl extends Control {
        constructor(options = {}) {
            super({ position: 'top-right', ...options });
            this.options.title = options.title || 'Show my location';
            this._locationMarker = null;
        }

        onAdd() {
            const container = document.createElement('div');
            container.className = 'atlas-geolocation-control';
            const button = document.createElement('button');
            button.className = 'control-btn';
            button.title = this.options.title;
            button.setAttribute('aria-label', this.options.title);
            button.innerHTML = '⌖'; // Target symbol
            button.onclick = () => this._locate();
            container.appendChild(button);
            this._button = button;
            return container;
        }

        _locate() {
            if (!navigator.geolocation) {
                this._handleError({ code: -1, message: 'Geolocation is not supported by your browser.' });
                return;
            }

            this._button.disabled = true;
            this._button.innerHTML = '...';

            navigator.geolocation.getCurrentPosition(
                (position) => this._onLocationFound(position),
                (error) => this._onLocationError(error),
                {
                    enableHighAccuracy: true,
                    timeout: 8000,
                    maximumAge: 0
                }
            );
        }

        _onLocationFound(position) {
            const latlng = { lat: position.coords.latitude, lon: position.coords.longitude };
            const accuracy = position.coords.accuracy;

            if (this._locationMarker) {
                this._locationMarker.setLatLng(latlng).setAccuracy(accuracy);
            } else {
                this._locationMarker = new LocationMarker(latlng, accuracy).addTo(this._map);
            }

            this._map.flyTo({
                center: latlng,
                zoom: 17
            });
            this._resetButton();
        }

        _onLocationError(error) {
            let message = '';
            switch(error.code) {
                case error.PERMISSION_DENIED:
                    message = 'Geolocation request denied. Please enable location services for this site.';
                    break;
                case error.POSITION_UNAVAILABLE:
                    message = 'Location information is unavailable.';
                    break;
                case error.TIMEOUT:
                    message = 'The request to get user location timed out.';
                    break;
                default:
                    message = 'An unknown error occurred.';
                    break;
            }
            if (window.location.protocol === 'http:') {
                message += '\n\nNote: Geolocation may require a secure (HTTPS) connection.';
            }
            alert(message);
            this._resetButton();
        }

        _resetButton() {
            this._button.disabled = false;
            this._button.innerHTML = '⌖';
        }
    }

    class HomeControl extends Control {
        constructor(options = {}) {
            super({ position: 'top-right', ...options });
            this.options.title = options.title || 'Reset view';
        }

        onAdd() {
            const container = document.createElement('div');
            container.className = 'atlas-home-control';
            const button = document.createElement('button');
            button.className = 'control-btn';
            button.title = this.options.title;
            button.setAttribute('aria-label', this.options.title);
            button.innerHTML = '&#8962;'; // Home icon
            button.onclick = () => {
                this._map.flyTo({
                    center: CONFIG.defaultCenter,
                    zoom: CONFIG.defaultZoom,
                    bearing: 0
                });
            };
            container.appendChild(button);
            return container;
        }
    }


    /* >>>> ADDED: SearchControl Class <<<< */
    class SearchControl extends Control {
      constructor(options = {}) {
        super(options);
        // Set default options
        this.options = {
          position: options.position || 'top-left',
          placeholder: options.placeholder || 'Search for a place...',
          noResultsMessage: options.noResultsMessage || 'No results found.',
          messageHideDelay: options.messageHideDelay || 3000, // ms
          providerUrl: options.providerUrl || 'https://nominatim.openstreetmap.org/search',
          providerOptions: {
            format: 'json',
            limit: 5,
            ...options.providerOptions
          }
        };
        this._input = null;
        this._resultsContainer = null;
        this._messageContainer = null;
        this._activeResultIndex = -1; // For keyboard navigation
        this._currentResults = [];
        this._debounceTimer = null;
        this._resultMarker = null;
        this._onInputChangeBound = this._onInputChange.bind(this);
        this._onInputKeyDownBound = this._onInputKeyDown.bind(this);
        this._onDocumentClickBound = this._onDocumentClick.bind(this);
      }

      onAdd() {
        // Create the main container for the search control
        const container = document.createElement('div');
        container.className = 'atlas-search-control';

        // Create the form element
        const form = document.createElement('form');
        form.className = 'atlas-search-form';
        form.style.display = 'flex';
        form.style.position = 'relative';
        form.setAttribute('role', 'search');

        // Create the input element
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'atlas-search-input';
        input.placeholder = this.options.placeholder;
        input.setAttribute('aria-label', this.options.placeholder);
        input.style.padding = '6px 8px';
        input.style.fontSize = '14px';
        input.style.border = '1px solid #ccc';
        input.style.borderRadius = '4px 0 0 4px';
        input.style.outline = 'none';
        input.style.width = '200px';
        input.style.backgroundColor = 'rgba(255,255,255,0.9)';

        // Create the submit button (magnifying glass)
        const submitButton = document.createElement('button');
        submitButton.type = 'submit';
        submitButton.className = 'atlas-search-submit';
        submitButton.setAttribute('aria-label', 'Search');
        submitButton.innerHTML = '🔍'; // Magnifying glass icon
        submitButton.style.padding = '6px 8px';
        submitButton.style.border = '1px solid #ccc';
        submitButton.style.borderLeft = 'none';
        submitButton.style.borderRadius = '0 4px 4px 0';
        submitButton.style.background = 'rgba(255,255,255,0.9)';
        submitButton.style.cursor = 'pointer';
        submitButton.style.fontSize = '14px';

        // Style the button on hover
        submitButton.onmouseenter = () => {
          submitButton.style.background = 'rgba(240,240,240,0.95)';
        };
        submitButton.onmouseleave = () => {
          submitButton.style.background = 'rgba(255,255,255,0.9)';
        };

        // Assemble the form
        form.appendChild(input);
        form.appendChild(submitButton);

        // Create a container for search results (dropdown)
        const resultsContainer = document.createElement('div');
        resultsContainer.className = 'atlas-search-results';
        resultsContainer.style.position = 'absolute';
        resultsContainer.style.top = '100%';
        resultsContainer.style.left = '0';
        resultsContainer.style.right = '0';
        resultsContainer.style.zIndex = '1001'; // Above other controls
        resultsContainer.style.backgroundColor = 'rgba(255,255,255,0.95)';
        resultsContainer.style.border = '1px solid #ccc';
        resultsContainer.style.borderTop = 'none';
        resultsContainer.style.borderRadius = '0 0 4px 4px';
        resultsContainer.style.maxHeight = '200px';
        resultsContainer.style.overflowY = 'auto';
        resultsContainer.style.boxShadow = '0 2px 5px rgba(0,0,0,0.15)';
        resultsContainer.style.display = 'none'; // Hidden by default

        // Create a container for status/error messages
        const messageContainer = document.createElement('div');
        messageContainer.className = 'atlas-search-message';
        messageContainer.style.position = 'absolute';
        messageContainer.style.top = '100%';
        messageContainer.style.left = '0';
        messageContainer.style.right = '0';
        messageContainer.style.zIndex = '1001';
        messageContainer.style.backgroundColor = 'rgba(255,255,255,0.95)';
        messageContainer.style.border = '1px solid #ccc';
        messageContainer.style.borderTop = 'none';
        messageContainer.style.borderRadius = '0 0 4px 4px';
        messageContainer.style.padding = '6px 8px';
        messageContainer.style.fontSize = '12px';
        messageContainer.style.color = '#666';
        messageContainer.style.textAlign = 'center';
        messageContainer.style.display = 'none';

        // Append all elements to the main container
        container.appendChild(form);
        container.appendChild(resultsContainer);
        container.appendChild(messageContainer);

        // Assign to instance properties for later use
        this._container = container;
        this._input = input;
        this._resultsContainer = resultsContainer;
        this._messageContainer = messageContainer;

        // Add event listeners
        form.addEventListener('submit', (e) => {
          e.preventDefault();
          this._performSearch(this._input.value.trim());
        });

        this._input.addEventListener('input', this._onInputChangeBound);
        this._input.addEventListener('keydown', this._onInputKeyDownBound);

        // Close results if user clicks outside the control
        document.addEventListener('click', this._onDocumentClickBound);

        return container;
      }

      onRemove() {
        // Clean up event listeners
        if (this._input) {
          this._input.removeEventListener('input', this._onInputChangeBound);
          this._input.removeEventListener('keydown', this._onInputKeyDownBound);
        }
        document.removeEventListener('click', this._onDocumentClickBound);

        // Clear any pending debounced requests
        if (this._debounceTimer) {
          clearTimeout(this._debounceTimer);
          this._debounceTimer = null;
        }

        // Hide containers
        if (this._resultsContainer) this._resultsContainer.style.display = 'none';
        if (this._messageContainer) this._messageContainer.style.display = 'none';
      }

      _onDocumentClick(event) {
        // If the click is outside the search control, hide the results
        if (!this._container.contains(event.target)) {
          this._hideResults();
          this._hideMessage();
        }
      }

      _onInputChange(event) {
        const query = event.target.value.trim();
        if (query.length === 0) {
          this._hideResults();
          this._hideMessage();
          return;
        }

        // Debounce the search to avoid flooding the API
        if (this._debounceTimer) {
          clearTimeout(this._debounceTimer);
        }

        this._debounceTimer = setTimeout(() => {
          this._performSearch(query);
        }, 300); // Wait 300ms after user stops typing
      }

      _onInputKeyDown(event) {
        const key = event.key;

        if (key === 'ArrowDown') {
          event.preventDefault();
          this._activeResultIndex = Math.min(this._activeResultIndex + 1, this._currentResults.length - 1);
          this._updateResultHighlight();
        } else if (key === 'ArrowUp') {
          event.preventDefault();
          this._activeResultIndex = Math.max(this._activeResultIndex - 1, -1);
          this._updateResultHighlight();
        } else if (key === 'Enter' && this._activeResultIndex >= 0) {
          event.preventDefault();
          this._selectResult(this._currentResults[this._activeResultIndex]);
        } else if (key === 'Escape') {
          this._input.blur();
          this._hideResults();
          this._hideMessage();
        }
      }

      _updateResultHighlight() {
        // Remove 'active' class from all results
        const resultItems = this._resultsContainer.querySelectorAll('.atlas-search-result-item');
        resultItems.forEach(item => item.classList.remove('active'));

        // Add 'active' class to the currently selected result
        if (this._activeResultIndex >= 0 && resultItems[this._activeResultIndex]) {
          resultItems[this._activeResultIndex].classList.add('active');
        }
      }

      _performSearch(query) {
        if (!query) return;

        // Show a loading indicator in the results container
        this._showMessage('Searching...');

        const params = {
          q: query,
          ...this.options.providerOptions
        };

        const queryString = new URLSearchParams(params).toString();
        const url = `${this.options.providerUrl}?${queryString}`;

        fetch(url, {
          headers: {
            'User-Agent': 'Atlas.js Search Control / https://github.com/your-org/atlasjs'
          }
        })
        .then(response => {
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          return response.json();
        })
        .then(data => {
          this._hideMessage();
          this._displayResults(data);
        })
        .catch(error => {
          console.error('[Atlas Search] Error fetching results:', error);
          this._showMessage('Search failed. Please try again.');
        });
      }

      _displayResults(results) {
        this._currentResults = results;
        this._activeResultIndex = -1;

        if (results.length === 0) {
          this._showMessage(this.options.noResultsMessage);
          this._hideResults();
          return;
        }

        // Clear previous results
        this._resultsContainer.innerHTML = '';

        // Populate the results container
        results.forEach((result, index) => {
          const item = document.createElement('div');
          item.className = 'atlas-search-result-item';
          item.style.padding = '8px 10px';
          item.style.cursor = 'pointer';
          item.style.borderBottom = '1px solid #eee';
          item.style.fontSize = '13px';

          // On hover, highlight the item
          item.onmouseenter = () => {
            this._activeResultIndex = index;
            this._updateResultHighlight();
          };

          // On click, select the result
          item.onclick = () => {
            this._selectResult(result);
          };

          // Format the display name
          let displayName = result.display_name;
          if (!displayName && result.name) {
            displayName = result.name;
          }
          if (!displayName) {
            displayName = `${result.lat}, ${result.lon}`;
          }

          item.textContent = displayName;
          this._resultsContainer.appendChild(item);
        });

        // Remove the last border-bottom
        const lastItem = this._resultsContainer.lastElementChild;
        if (lastItem) {
          lastItem.style.borderBottom = 'none';
        }

        // Show the results container
        this._resultsContainer.style.display = 'block';
      }

      _selectResult(result) {
        if (!result || !this._map) return;

        // Extract latitude and longitude
        const lat = parseFloat(result.lat);
        const lon = parseFloat(result.lon);

        if (isNaN(lat) || isNaN(lon)) {
          console.warn('[Atlas Search] Invalid coordinates in result:', result);
          return;
        }

        const latlng = { lat, lon };

        // Remove previous search marker
        if (this._resultMarker) {
            this._map.removeLayer(this._resultMarker);
        }

        // Add a new marker with a popup
        const displayNameParts = (result.display_name || 'Selected Location').split(',');
        const title = displayNameParts[0];
        const details = displayNameParts.slice(1).join(',').trim();

        const popupContent = `
            <div class="atlas-search-popup-content">
                <div class="title">${title}</div>
                ${details ? `<div class="details">${details}</div>` : ''}
                <hr>
                <div class="coords">Lat: ${lat.toFixed(5)}, Lon: ${lon.toFixed(5)}</div>
            </div>
        `;

        this._resultMarker = new Marker(latlng)
            .bindPopup(popupContent)
            .addTo(this._map)
            .openPopup();

        // Animate the map to the selected location
        this._map.flyTo({
          center: latlng,
          zoom: 14,
          duration: 800,
          easing: EASING.easeInOutCubic
        });

        // Clear the input and hide the results
        this._input.value = '';
        this._hideResults();
        this._hideMessage();

        // Fire a custom event so users can hook into the selection
        this.fire('search:select', {
          result: result,
          latlng: latlng
        });
      }

      _showMessage(text) {
        this._hideResults(); // Only show one type of popup at a time
        this._messageContainer.textContent = text;
        this._messageContainer.style.display = 'block';

        // Automatically hide the message after a delay
        setTimeout(() => {
          this._hideMessage();
        }, this.options.messageHideDelay);
      }

      _hideMessage() {
        this._messageContainer.style.display = 'none';
      }

      _hideResults() {
        this._resultsContainer.style.display = 'none';
        this._activeResultIndex = -1;
      }
    }
    /* >>>> END OF ADDED CLASS <<<< */
    class Handler {
      constructor(map) { this._map = map; this._enabled = false; this._eventListeners = {}; }
      enable() { if (this._enabled) return this; this._enabled = true; this._addEvents(); return this; }
      disable() { if (!this._enabled) return this; this._enabled = false; this._removeEvents(); return this; }
      toggle() { return this._enabled ? this.disable() : this.enable(); }
      isEnabled() { return this._enabled; }
      _addEvents() {}
      _removeEvents() {}
      destroy() { this.disable(); this._eventListeners = {}; }
    }
    class DragPanHandler extends Handler {
      constructor(map) {
        super(map);
        this._isDragging = false;
        this._dragStart = null;
        this._moveSamples = [];
      }
      _addEvents() {
        this._map.canvas.addEventListener('mousedown', this._onMouseDown = this._onMouseDown.bind(this));
        this._map.canvas.addEventListener('touchstart', this._onTouchStart = this._onTouchStart.bind(this), { passive: false });
      }
      _removeEvents() {
        this._map.canvas.removeEventListener('mousedown', this._onMouseDown);
        this._map.canvas.removeEventListener('touchstart', this._onTouchStart);
        this._removeMoveEvents();
      }
      _removeMoveEvents() {
        document.removeEventListener('mousemove', this._onMouseMove);
        document.removeEventListener('mouseup', this._onMouseUp);
        document.removeEventListener('touchmove', this._onTouchMove, { passive: false });
        document.removeEventListener('touchend', this._onTouchEnd);
        document.removeEventListener('touchcancel', this._onTouchEnd);
      }
      _onMouseDown(e) {
        if (e.button !== 0) return;
        this._startDrag(e.clientX, e.clientY);
        document.addEventListener('mousemove', this._onMouseMove = this._onMouseMove.bind(this));
        document.addEventListener('mouseup', this._onMouseUp = this._onMouseUp.bind(this));
      }
      _onMouseMove(e) {
        if (!this._isDragging) return;
        e.preventDefault();
        const dx = e.clientX - this._dragStart.x;
        const dy = e.clientY - this._dragStart.y;
        const w = this._map.canvas.width / this._map.dpr;
        const h = this._map.canvas.height / this._map.dpr;
        this._map.center = this._map.screenToLatLon(w / 2 - dx, h / 2 - dy, this._map.zoom, this._map.bearing, this._dragStart.center);
        this._pushVelocitySample(e.clientX, e.clientY);
        this._map.render();
      }
      _onMouseUp() { this._endDrag(); }
      _onTouchStart(e) {
        if (e.touches.length !== 1) return;
        e.preventDefault();
        this._startDrag(e.touches[0].clientX, e.touches[0].clientY);
        document.addEventListener('touchmove', this._onTouchMove = this._onTouchMove.bind(this), { passive: false });
        document.addEventListener('touchend', this._onTouchEnd = this._onTouchEnd.bind(this));
        document.addEventListener('touchcancel', this._onTouchEnd);
      }
      _onTouchMove(e) {
        if (!this._isDragging || e.touches.length !== 1) return;
        e.preventDefault();
        const dx = e.touches[0].clientX - this._dragStart.x;
        const dy = e.touches[0].clientY - this._dragStart.y;
        const w = this._map.canvas.width / this._map.dpr;
        const h = this._map.canvas.height / this._map.dpr;
        this._map.center = this._map.screenToLatLon(w / 2 - dx, h / 2 - dy, this._map.zoom, this._map.bearing, this._dragStart.center);
        this._pushVelocitySample(e.touches[0].clientX, e.touches[0].clientY);
        this._map.render();
      }
      _onTouchEnd() { this._endDrag(); }
      _startDrag(clientX, clientY) {
        this._isDragging = true;
        this._map.stopAnimations();
        this._map.isDragging = true;
        this._map.container.classList.add('dragging');
        this._dragStart = { x: clientX, y: clientY, center: { ...this._map.center } };
        this._moveSamples = [];
        this._pushVelocitySample(clientX, clientY);
      }
      _endDrag() {
        if (!this._isDragging) return;
        this._isDragging = false;
        this._map.isDragging = false;
        this._map.container.classList.remove('dragging');
        const { vx, vy } = this._computeVelocity();
        this._startInertia(vx, vy);
        this._removeMoveEvents();
      }
      _pushVelocitySample(x, y) {
        const t = performance.now();
        this._moveSamples.push({ t, x, y });
        const cutoff = t - VELOCITY_WINDOW_MS;
        while (this._moveSamples.length && this._moveSamples[0].t < cutoff) this._moveSamples.shift();
      }
      _computeVelocity() {
        if (this._moveSamples.length < 2) return { vx: 0, vy: 0 };
        const last = this._moveSamples[this._moveSamples.length - 1];
        let i = this._moveSamples.length - 2;
        while (i > 0 && last.t - this._moveSamples[i].t < VELOCITY_WINDOW_MS * 0.5) i--;
        const ref = this._moveSamples[i];
        const dt = Math.max(1, last.t - ref.t);
        return { vx: (last.x - ref.x) / dt, vy: (last.y - ref.y) / dt };
      }
      _startInertia(vx, vy) {
        const speed = Math.hypot(vx, vy);
        if (speed < INERTIA_STOP_SPEED) return;

        let lastT = performance.now();
        const step = () => {
            const now = performance.now();
            const dt = now - lastT;
            lastT = now;

            const dx = vx * dt, dy = vy * dt;
            const w = this._map.canvas.width / this._map.dpr;
            const h = this._map.canvas.height / this._map.dpr;

            const newCenter = this._map.screenToLatLon(w / 2 - dx, h / 2 - dy);

            // Bounce effect at poles
            if (newCenter.lat >= MAX_LATITUDE || newCenter.lat <= MIN_LATITUDE) {
                vy *= -0.5; // Reverse and dampen vertical velocity
            }

            this._map.center = newCenter;

            const vmag = Math.hypot(vx, vy);
            const newVmag = Math.max(0, vmag - INERTIA_DECEL * dt);

            if (newVmag <= INERTIA_STOP_SPEED) {
                this._map.render();
                this._map._inertiaRAF = null;
                this._map.fire('moveend');
                return;
            }

            const s = newVmag / (vmag || 1);
            vx *= s;
            vy *= s;

            this._map.render();
            this._map._inertiaRAF = requestAnimationFrame(step);
        };
        this._map._inertiaRAF = requestAnimationFrame(step);
      }
    }
    class ScrollZoomHandler extends Handler {
      constructor(map) { super(map); }
      _addEvents() { this._map.canvas.addEventListener('wheel', this._onWheel = this._onWheel.bind(this), { passive: false }); }
      _removeEvents() { this._map.canvas.removeEventListener('wheel', this._onWheel); }
      _onWheel(e) {
        e.preventDefault();
        const dz = (e.deltaY < 0 ? WHEEL_ZOOM_STEP : -WHEEL_ZOOM_STEP);
        this._map.smoothZoomAt(e.clientX, e.clientY, dz);
      }
    }
    class DoubleClickZoomHandler extends Handler {
      constructor(map) {
        super(map);
        this._lastClickTime = 0;
        this._lastClickPos = { x: 0, y: 0 };
      }
      _addEvents() { this._map.canvas.addEventListener('dblclick', this._onDoubleClick = this._onDoubleClick.bind(this)); }
      _removeEvents() { this._map.canvas.removeEventListener('dblclick', this._onDoubleClick); }
      _onDoubleClick(e) {
        e.preventDefault();
        this._map.animateZoomRotateAbout(e.clientX, e.clientY, this._map.getZoom() + 1, this._map.getBearing(), TAP_ZOOM_DURATION);
      }
    }
    class TouchZoomRotateHandler extends Handler {
      constructor(map) {
        super(map);
        this._isPinching = false;
        this._pinchStartDist = 0;
        this._pinchStartAngle = 0;
        this._pinchStartZoom = map.getZoom();
        this._pinchStartBearing = map.getBearing();
        this._pinchStartTime = 0;
        this._pinchLastCenter = null;
        this._pinchMoved = false;
        this._pinchAnchorLL = null;
        // --- NEW: Double-Tap State ---
        this._lastTapTime = 0;
        this._lastTapPos = { x: 0, y: 0 };
        this._singleTapTimeout = null;
      }
      _addEvents() { this._map.canvas.addEventListener('touchstart', this._onTouchStart = this._onTouchStart.bind(this), { passive: false }); }
      _removeEvents() {
        this._map.canvas.removeEventListener('touchstart', this._onTouchStart);
        this._removeMoveEvents();
        // --- NEW: Clear double-tap timeout ---
        if (this._singleTapTimeout) {
          clearTimeout(this._singleTapTimeout);
          this._singleTapTimeout = null;
        }
      }
      _removeMoveEvents() {
        document.removeEventListener('touchmove', this._onTouchMove, { passive: false });
        document.removeEventListener('touchend', this._onTouchEnd);
        document.removeEventListener('touchcancel', this._onTouchEnd);
      }
      _onTouchStart(e) {
        if (e.touches.length === 1) {
          // --- NEW: Handle Single Tap for Double-Tap Detection ---
          const now = Date.now();
          const clientX = e.touches[0].clientX;
          const clientY = e.touches[0].clientY;
          // Clear any existing single-tap timeout
          if (this._singleTapTimeout) {
            clearTimeout(this._singleTapTimeout);
            this._singleTapTimeout = null;
          }
          // Check if this is a double-tap
          if (
            now - this._lastTapTime < DOUBLE_TAP_MAX_DELAY &&
            Math.hypot(clientX - this._lastTapPos.x, clientY - this._lastTapPos.y) < DOUBLE_TAP_MAX_MOVE
          ) {
            // It's a double-tap! Prevent default and zoom in.
            e.preventDefault();
            this._map.animateZoomRotateAbout(clientX, clientY, this._map.getZoom() + 1, this._map.getBearing(), TAP_ZOOM_DURATION);
            // Reset double-tap state
            this._lastTapTime = 0;
            this._lastTapPos = { x: 0, y: 0 };
            return; // Important: return to avoid starting a pinch
          } else {
            // It's a potential first tap of a double-tap. Record it.
            this._lastTapTime = now;
            this._lastTapPos = { x: clientX, y: clientY };
            // Set a timeout to clear the tap state if the second tap doesn't come soon
            this._singleTapTimeout = setTimeout(() => {
              this._lastTapTime = 0;
              this._lastTapPos = { x: 0, y: 0 };
              this._singleTapTimeout = null;
            }, DOUBLE_TAP_MAX_DELAY);
          }
        }
        // Existing pinch logic: only proceed if 2+ touches
        if (e.touches.length < 2) return;
        e.preventDefault();
        this._startPinch(e);
        document.addEventListener('touchmove', this._onTouchMove = this._onTouchMove.bind(this), { passive: false });
        document.addEventListener('touchend', this._onTouchEnd = this._onTouchEnd.bind(this));
        document.addEventListener('touchcancel', this._onTouchEnd);
      }
      _startPinch(e) {
        this._map.stopAnimations();
        this._isPinching = true;
        const t1 = e.touches[0], t2 = e.touches[1];
        this._pinchStartDist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
        this._pinchStartAngle = Math.atan2(t2.clientY - t1.clientY, t2.clientX - t1.clientX);
        this._pinchStartZoom = this._map.getZoom();
        this._pinchStartBearing = this._map.getBearing();
        this._pinchStartTime = performance.now();
        this._pinchLastCenter = { x: (t1.clientX + t2.clientX) / 2, y: (t1.clientY + t2.clientY) / 2 };
        this._pinchAnchorLL = this._map.screenToLatLon(this._pinchLastCenter.x, this._pinchLastCenter.y, this._map.getZoom(), this._map.getBearing(), this._map.getCenter());
        this._pinchMoved = false;
      }
      _onTouchMove(e) {
        if (!this._isPinching || e.touches.length < 2) return;
        e.preventDefault();
        const t1 = e.touches[0], t2 = e.touches[1];
        const dist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
        const angle = Math.atan2(t2.clientY - t1.clientY, t2.clientX - t1.clientX);
        const center = { x: (t1.clientX + t2.clientX) / 2, y: (t1.clientY + t2.clientY) / 2 };
        const targetZoom = this._pinchStartZoom + Math.log2(dist / Math.max(1, this._pinchStartDist));
        const deltaAngle = normalizeAngle(angle - this._pinchStartAngle);
        const targetBearing = normalizeAngle(this._pinchStartBearing + deltaAngle);
        if (Math.abs(Math.log(dist / Math.max(1, this._pinchStartDist))) > Math.log(1 + TWO_FINGER_TAP_MOVE_THRESH / Math.max(1, this._pinchStartDist)) ||
          Math.abs(deltaAngle) > ROTATE_MOVE_THRESH_RAD) {
          this._pinchMoved = true;
        }
        this._map.applyZoomRotateAbout(center.x, center.y, targetZoom, targetBearing, this._pinchAnchorLL);
        this._pinchLastCenter = center;
        this._map.render();
      }
      _onTouchEnd(e) {
        if (!this._isPinching) return;
        const dt = performance.now() - this._pinchStartTime;
        if (dt <= TWO_FINGER_TAP_MAX_DELAY && !this._pinchMoved) {
          const ax = this._pinchLastCenter ? this._pinchLastCenter.x : (this._map.canvas.width / this._map.dpr) / 2;
          const ay = this._pinchLastCenter ? this._pinchLastCenter.y : (this._map.canvas.height / this._map.dpr) / 2;
          this._map.animateZoomRotateAbout(ax, ay, this._map.getZoom() - 1, this._map.getBearing(), TAP_ZOOM_DURATION);
        }
        this._isPinching = false;
        this._removeMoveEvents();
      }
    }
    class KeyboardPanHandler extends Handler {
      constructor(map) { super(map); }
      _addEvents() { window.addEventListener('keydown', this._onKeyDown = this._onKeyDown.bind(this)); }
      _removeEvents() { window.removeEventListener('keydown', this._onKeyDown); }
      _onKeyDown(e) {
        let dx = 0, dy = 0;
        const step = 1;
        if (e.key === "ArrowUp") dy = step;
        else if (e.key === "ArrowDown") dy = -step;
        else if (e.key === "ArrowLeft") dx = -step;
        else if (e.key === "ArrowRight") dx = step;
        else if (e.key.toLowerCase() === "n") {
          const w = this._map.canvas.width / this._map.dpr, h = this._map.canvas.height / this._map.dpr;
          this._map.animateZoomRotateAbout(w / 2, h / 2, this._map.getZoom(), 0, SNAP_DURATION);
          return;
        } else if (e.key === "r") { this._map.setBearing(this._map.getBearing() + DEG2RAD * 15); return; }
        else if (e.key === "l") { this._map.setBearing(this._map.getBearing() - DEG2RAD * 15); return; }
        else if (e.key === "s") {
          const current = this._map.getBaseLayer();
          let nextLayerKey;
          if (!current || current.urlTemplate.includes('openstreetmap')) {
            nextLayerKey = 'ESRI';
          } else if (current.urlTemplate.includes('World_Imagery')) {
            nextLayerKey = 'ESRI_TOPO';
          } else {
            nextLayerKey = 'OSM';
          }
          const layerConfig = LAYERS[nextLayerKey];
          if (layerConfig) {
            let finalUrl;
            if (nextLayerKey === "ESRI") {
              finalUrl = "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}";
            } else if (nextLayerKey === "ESRI_TOPO") {
              finalUrl = "https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}";
            } else { // OSM
              const subdomains = ['a', 'b', 'c'];
              const randomSubdomain = subdomains[Math.floor(Math.random() * subdomains.length)];
              finalUrl = `https://${randomSubdomain}.tile.openstreetmap.org/{z}/{x}/{y}.png`;
            }
            const newLayer = new TileLayer(finalUrl, {
              minZoom: layerConfig.minZoom,
              maxZoom: layerConfig.maxZoom,
              attribution: layerConfig.attribution,
              background: layerConfig.background,
              supportsRetina: layerConfig.supportsRetina,
              maxCacheSize: layerConfig.maxCacheSize
            });
            this._map.setBaseLayer(newLayer);
          }
          return;
        } else if (e.key === "+" || e.key === "=") {
          this._map.stopAnimations();
          this._map.setZoom(this._map.getZoom() + 1);
          return;
        } else if (e.key === "-") {
          this._map.stopAnimations();
          this._map.setZoom(this._map.getZoom() - 1);
          return;
        }
        if (dx !== 0 || dy !== 0) {
          this._map.stopAnimations();
          this._map.center = {
            lat: GISUtils.clampLatitude(this._map.getCenter().lat + dy),
            lon: GISUtils.wrapLongitude(this._map.getCenter().lon + dx)
          };
          this._map.render();
        }
      }
    }
    // --- NEW HANDLER ---
    class AreaZoomHandler extends Handler {
      constructor(map) {
        super(map);
        this._isSelecting = false;
        this._startPoint = null;
        this._endPoint = null;
        this._selectionRect = null;
      }
      _addEvents() {
        this._map.canvas.addEventListener('mousedown', this._onMouseDown = this._onMouseDown.bind(this));
      }
      _removeEvents() {
        this._map.canvas.removeEventListener('mousedown', this._onMouseDown);
        document.removeEventListener('mousemove', this._onMouseMove);
        document.removeEventListener('mouseup', this._onMouseUp);
      }
      _onMouseDown(e) {
        // Only activate if Shift key is pressed
        if (!e.shiftKey) return;
        e.preventDefault();
        this._startDrag(e.clientX, e.clientY);
        document.addEventListener('mousemove', this._onMouseMove = this._onMouseMove.bind(this));
        document.addEventListener('mouseup', this._onMouseUp = this._onMouseUp.bind(this));
      }
      _onMouseMove(e) {
        if (!this._isSelecting) return;
        e.preventDefault();
        this._updateSelection(e.clientX, e.clientY);
      }
      _onMouseUp(e) {
        if (!this._isSelecting) return;
        this._endDrag(e.clientX, e.clientY);
        document.removeEventListener('mousemove', this._onMouseMove);
        document.removeEventListener('mouseup', this._onMouseUp);
      }
      _startDrag(x, y) {
        this._isSelecting = true;
        this._startPoint = { x, y };
        this._map.canvas.style.cursor = 'crosshair';
        this._map.container.classList.add('selecting'); // Add CSS for visual feedback
        this._map.stopAnimations(); // Cancel any ongoing animations
      }
      _updateSelection(x, y) {
        this._endPoint = { x, y };
        this._drawSelection();
      }
      _endDrag(x, y) {
        this._isSelecting = false;
        this._map.canvas.style.cursor = 'grab';
        const rect = this._getSelectionRect();
        if (rect.width > 10 && rect.height > 10) { // Minimum size threshold
          this._zoomToSelection(rect);
        }
        this._clearSelection();
        this._map.container.classList.remove('selecting');
      }
      _getSelectionRect() {
        if (!this._startPoint || !this._endPoint) return { x: 0, y: 0, width: 0, height: 0 };
        const x1 = this._startPoint.x, y1 = this._startPoint.y;
        const x2 = this._endPoint.x, y2 = this._endPoint.y;
        return {
          x: Math.min(x1, x2),
          y: Math.min(y1, y2),
          width: Math.abs(x2 - x1),
          height: Math.abs(y2 - y1)
        };
      }
      _drawSelection() {
        this._clearSelection();
        const rect = this._getSelectionRect();
        if (rect.width <= 0 || rect.height <= 0) return;
        // Create a semi-transparent overlay div
        this._selectionRect = document.createElement('div');
        this._selectionRect.style.position = 'absolute';
        this._selectionRect.style.left = rect.x + 'px';
        this._selectionRect.style.top = rect.y + 'px';
        this._selectionRect.style.width = rect.width + 'px';
        this._selectionRect.style.height = rect.height + 'px';
        this._selectionRect.style.border = '2px dashed #3388ff';
        this._selectionRect.style.background = 'rgba(51, 136, 255, 0.1)';
        this._selectionRect.style.pointerEvents = 'none';
        this._selectionRect.style.zIndex = '999';
        this._map.container.appendChild(this._selectionRect);
      }
      _clearSelection() {
        if (this._selectionRect && this._selectionRect.parentNode) {
          this._selectionRect.parentNode.removeChild(this._selectionRect);
        }
        this._selectionRect = null;
        this._startPoint = null;
        this._endPoint = null;
      }
      _zoomToSelection(rect) {
        const w = this._map.canvas.width / this._map.dpr;
        const h = this._map.canvas.height / this._map.dpr;
        // Get LatLng for the corners of the selection
        const sw = this._map.screenToLatLon(rect.x, rect.y + rect.height);
        const ne = this._map.screenToLatLon(rect.x + rect.width, rect.y);
        // Calculate the center of the selection
        const centerLon = (sw.lon + ne.lon) / 2;
        const centerLat = (sw.lat + ne.lat) / 2;
        // Calculate the zoom level needed to fit the selection
        // We fit the larger dimension (width or height)
        const latSpan = Math.abs(ne.lat - sw.lat);
        const lonSpan = Math.abs(GISUtils.wrapLongitude(ne.lon - sw.lon));
        // Simple formula to calculate zoom level based on span
        // This is an approximation and can be refined
        const zoomLat = Math.log2(EARTH_CIRCUMFERENCE * 0.9 / (latSpan * 111000)); // 111km per degree
        const zoomLon = Math.log2(EARTH_CIRCUMFERENCE * Math.cos(centerLat * DEG2RAD) / (lonSpan * 111000));
        const targetZoom = Math.min(zoomLat, zoomLon) - 0.5; // Subtract a bit for padding
        // Animate to the new view
        this._map.flyTo({
          center: { lat: centerLat, lon: centerLon },
          zoom: targetZoom,
          duration: 800,
          easing: EASING.easeInOutCubic
        });
      }
    }
    class Atlas {
      constructor(id, options = {}) {
        Object.assign(CONFIG, options);
        this.canvas = document.getElementById(id);
        this.ctx = this.canvas.getContext("2d");
        this.container = document.getElementById("map-container");
        this.center = { lon: GISUtils.wrapLongitude(CONFIG.defaultCenter.lon), lat: GISUtils.clampLatitude(CONFIG.defaultCenter.lat) };
        this.zoom = CONFIG.defaultZoom;
        this.bearing = 0;
        this.renderScheduled = false;
        this.loadingEl = document.getElementById("loading");
        this.loadingCountEl = document.getElementById("loading-count");
        this._inertiaRAF = null;
        this._layers = [];
        this._baseLayer = null;
        this._controls = [];
        this._controlCorners = {};
        this._handlers = {};
        this._panes = {};
        this._popup = null;
        this._tooltip = null;
        this.projection = DEFAULT_PROJECTION;
        this.addHandler('dragPan', DragPanHandler);
        this.addHandler('scrollZoom', ScrollZoomHandler);
        this.addHandler('doubleClickZoom', DoubleClickZoomHandler);
        this.addHandler('touchZoomRotate', TouchZoomRotateHandler);
        this.addHandler('keyboardPan', KeyboardPanHandler);
        // --- ADD NEW HANDLER ---
        this.addHandler('areaZoom', AreaZoomHandler);
        console.warn(
          `%c[Atlas] You are using map tiles.
%cPlease comply with the respective tile usage policies.
%c- OpenStreetMap: https://operations.osmfoundation.org/policies/tiles/
%c- Esri: https://www.esri.com/en-us/legal/terms/full-master-agreement`,
          "font-weight:bold;color:#e74c3c;",
          "color:#3498db;",
          "color:#2ecc71;",
          "color:#f39c12;"
        );
        this.resize();
        // >>>> MOVED: All UI controls to the right side <<<<
        this.addControl(new ZoomControl({ position: 'top-right' }));
        this.addControl(new FullscreenControl({ position: 'top-right' }));
        this.addControl(new AttributionControl({ position: 'bottom-left' }));
        this.addControl(new CompassControl({ position: 'top-right' }));
        // >>>> MOVED: Search control to the left side <<<<
        this.addControl(new SearchControl({ position: 'top-left' }));
        this.addControl(new GeolocationControl({ position: 'top-right' }));
        this.addControl(new HomeControl({ position: 'top-right' }));
        this.addControl(new ScaleControl());
        this.updateAttribution();
        this.on('click', this._closeCurrentPopup, this);
        this.render();
        this.fire('load');
      }
      addLayer(layer) {
        if (!(layer instanceof Layer)) throw new Error('Argument must be an instance of Layer');
        if (!this._layers.includes(layer)) {
          this._layers.push(layer);
          layer._map = this;
          layer.onAdd();
          this.render();
          if (!this._baseLayer || (layer instanceof TileLayer && !this._baseLayer)) {
            this._baseLayer = layer;
            this.container.style.background = layer.getBackground();
          }
        }
        return this;
      }
      removeLayer(layer) {
        const index = this._layers.indexOf(layer);
        if (index !== -1) {
          this._layers.splice(index, 1);
          layer.onRemove();
          layer._map = null;
          if (this._baseLayer === layer) {
            this._baseLayer = this._layers.find(l => l instanceof TileLayer) || null;
            if (this._baseLayer) this.container.style.background = this._baseLayer.getBackground();
          }
          this.render();
        }
        return this;
      }
      setBaseLayer(newLayer) {
        if (!(newLayer instanceof TileLayer)) throw new Error('Argument must be an instance of TileLayer');
        if (this._baseLayer && this._baseLayer !== newLayer) this.removeLayer(this._baseLayer);
        if (!this._layers.includes(newLayer)) this.addLayer(newLayer);
        else {
          this._baseLayer = newLayer;
          this.container.style.background = newLayer.getBackground();
          this.zoom = Math.max(newLayer.getMinZoom(), Math.min(newLayer.getMaxZoom(), this.zoom));
          this.render();
        }
        return this;
      }
      getBaseLayer() { return this._baseLayer; }
      addControl(control) {
        if (!(control instanceof Control)) throw new Error('Argument must be an instance of Control');
        this._controls.push(control);
        control.addTo(this);
        return this;
      }
      removeControl(control) {
        const index = this._controls.indexOf(control);
        if (index !== -1) {
          this._controls.splice(index, 1);
          control.remove();
        }
        return this;
      }
      getControls() { return [...this._controls]; }
      addHandler(name, HandlerClass) {
        if (this._handlers[name]) { console.warn(`Handler '${name}' already exists.`); return this; }
        this._handlers[name] = new HandlerClass(this);
        this._handlers[name].enable();
        return this;
      }
      removeHandler(name) {
        if (!this._handlers[name]) return this;
        this._handlers[name].destroy();
        delete this._handlers[name];
        return this;
      }
      getHandler(name) { return this._handlers[name] || null; }
      enableHandler(name) { const handler = this.getHandler(name); if (handler) handler.enable(); return this; }
      disableHandler(name) { const handler = this.getHandler(name); if (handler) handler.disable(); return this; }
      getHandlers() { return { ...this._handlers }; }

      hasLayer(layer) {
          return this._layers.includes(layer);
      }

      openPopup(popup) {
          this._closeCurrentPopup();
          this._popup = popup;
          return this.addLayer(popup);
      }

      closePopup(popup) {
          if (!popup || this._popup === popup) {
              this._closeCurrentPopup();
          }
          return this;
      }

      _closeCurrentPopup() {
          if (this._popup) {
              this.removeLayer(this._popup);
              this._popup = null;
          }
      }

      openTooltip(tooltip) {
          this.closeTooltip();
          this._tooltip = tooltip;
          return this.addLayer(tooltip);
      }

      closeTooltip(tooltip) {
          if (!tooltip || this._tooltip === tooltip) {
              if (this._tooltip) {
                this.removeLayer(this._tooltip);
                this._tooltip = null;
              }
          }
          return this;
      }

      getPane(name) {
          if (!this._panes[name]) {
              this._panes[name] = this._createPane(`atlas-${name}-pane`, this.container);
          }
          return this._panes[name];
      }

      _createPane(className, container) {
          const pane = document.createElement('div');
          pane.className = className;
          container.appendChild(pane);
          return pane;
      }

      setZoom(z) {
        const minZoom = this._baseLayer ? this._baseLayer.getMinZoom() : 0;
        const maxZoom = this._baseLayer ? this._baseLayer.getMaxZoom() : 18;
        const nz = Math.max(minZoom, Math.min(maxZoom, z));
        if (nz === this.zoom) return;
        this.zoom = nz;
        this.render();
        this.showZoomOverlay();
        this.updateControlsUI();
        this.fire('zoom');
      }
      setBearing(rad) {
        const nr = normalizeAngle(rad);
        if (Math.abs(nr - this.bearing) < 1e-6) return;
        this.bearing = nr;
        this.render();
        this.fire('rotate');
      }
      showZoomOverlay() {}
      stopInertia() { if (this._inertiaRAF) cancelAnimationFrame(this._inertiaRAF); this._inertiaRAF = null; }
      stopAnimations() {
        this.stopInertia();
        if (this._zoomAnim?.raf) cancelAnimationFrame(this._zoomAnim.raf);
        this._zoomAnim = null;
        if (this._flyAnim?.raf) cancelAnimationFrame(this._flyAnim.raf);
        this._flyAnim = null;
      }
      resize() {
        const w = this.container.offsetWidth, h = this.container.offsetHeight;
        this.dpr = window.devicePixelRatio || 1;
        this.canvas.width = w * this.dpr;
        this.canvas.height = h * this.dpr;
        this.canvas.style.width = w + "px";
        this.canvas.style.height = h + "px";
        this.ctx.setTransform(this.dpr, 0, 0, this.dpr, 0, 0);
        this.render();
        this.fire('resize');
      }
      scheduleRender() {
        if (this.renderScheduled) return;
        this.renderScheduled = true;
        requestAnimationFrame(() => {
          this.renderScheduled = false;
          this._draw();
        });
      }
      render() { this.scheduleRender(); }
      _snapCanvasToPixelGrid() {
        const currentTransform = this.ctx.getTransform();
        const physicalTranslateX = currentTransform.e * this.dpr;
        const physicalTranslateY = currentTransform.f * this.dpr;
        const snapX = - (physicalTranslateX % 1) / this.dpr;
        const snapY = - (physicalTranslateY % 1) / this.dpr;
        this.ctx.translate(snapX, snapY);
      }
      _draw() {
        const backgroundColor = this._baseLayer ? this._baseLayer.getBackground() : '#000';
        const w = this.canvas.width / this.dpr, h = this.canvas.height / this.dpr;
        this.ctx.fillStyle = backgroundColor;
        this.ctx.fillRect(0, 0, w, h);

        let needsReRender = false;
        for (const layer of this._layers) {
            if (layer.render()) {
                needsReRender = true;
            }
        }

        this._snapCanvasToPixelGrid();
        let loadingCount = 0;
        if (this._baseLayer && this._baseLayer instanceof TileLayer) loadingCount = this._baseLayer.loadingTiles.size;
        this.loadingEl.classList.toggle("visible", loadingCount > 0);
        this.loadingCountEl.textContent = loadingCount;
        this.updateControlsUI();

        if (needsReRender) {
            this.render();
        }
      }
      updateAttribution() {
        for (const control of this._controls) {
          if (control instanceof AttributionControl && typeof control._update === 'function') control._update();
        }
      }
      updateControlsUI() {
        for (const control of this._controls) {
          if (typeof control._update === 'function') control._update();
        }
      }
      getCenter() { return { ...this.center }; }
      getZoom() { return this.zoom; }
      getBearing() { return this.bearing; }
      screenToLatLon(ax, ay, zoom = this.zoom, bearing = this.bearing, center = this.center) {
        const w = this.canvas.width / this.dpr;
        const h = this.canvas.height / this.dpr;
        const zInt = Math.floor(zoom);
        const ts = TILE_SIZE * Math.pow(2, zoom - zInt);
        const ct = this.projection.latLngToTile(center, zInt);
        const anchorVec = { x: ax - w / 2, y: ay - h / 2 };
        const v = rot(anchorVec.x / ts, anchorVec.y / ts, -bearing);
        const tpt = { x: ct.x + v.x, y: ct.y + v.y };
        const ll = this.projection.tileToLatLng(tpt.x, tpt.y, zInt);
        return { lon: GISUtils.wrapLongitude(ll.lon), lat: GISUtils.clampLatitude(ll.lat) };
      }
      lonLatToTile(lon, lat, z) { return this.projection.latLngToTile({ lat, lon }, z); }
      latLngToContainerPoint(latlng) {
        const w = this.canvas.width / this.dpr;
        const h = this.canvas.height / this.dpr;
        const zInt = Math.floor(this.zoom);
        const ts = TILE_SIZE * Math.pow(2, this.zoom - zInt);
        const ct = this.projection.latLngToTile(this.center, zInt);
        const pt = this.projection.latLngToTile(latlng, zInt);
        const trX = (pt.x - ct.x) * ts;
        const trY = (pt.y - ct.y) * ts;
        const anchorVec = rot(trX, trY, this.bearing);
        return { x: w / 2 + anchorVec.x, y: h / 2 + anchorVec.y };
      }
      applyZoomRotateAbout(ax, ay, newZoom, newBearing, anchorLL = null) {
        const minZoom = this._baseLayer ? this._baseLayer.getMinZoom() : 0;
        const maxZoom = this._baseLayer ? this._baseLayer.getMaxZoom() : 18;
        newZoom = Math.max(minZoom, Math.min(maxZoom, newZoom));
        const w = this.canvas.width / this.dpr;
        const h = this.canvas.height / this.dpr;
        const anchorVec = { x: ax - w / 2, y: ay - h / 2 };
        const currAnchorLL = anchorLL || this.screenToLatLon(ax, ay, this.zoom, this.bearing, this.center);
        const zInt = Math.floor(newZoom);
        const ts = TILE_SIZE * Math.pow(2, newZoom - zInt);
        const Ptile = this.projection.latLngToTile(currAnchorLL, zInt);
        const v = rot(anchorVec.x / ts, anchorVec.y / ts, -newBearing);
        const ctNew = { x: Ptile.x - v.x, y: Ptile.y - v.y };
        const newCenter = this.projection.tileToLatLng(ctNew.x, ctNew.y, zInt);
        this.center = { lon: GISUtils.wrapLongitude(newCenter.lon), lat: GISUtils.clampLatitude(newCenter.lat) };
        this.zoom = newZoom;
        this.bearing = normalizeAngle(newBearing);
      }
      showZoomIndicator(x, y) {
        if (this._zoomIndicator) this.container.removeChild(this._zoomIndicator);
        const indicator = document.createElement("div");
        indicator.style.position = "absolute";
        indicator.style.left = (x - 15) + "px";
        indicator.style.top = (y - 15) + "px";
        indicator.style.width = "30px";
        indicator.style.height = "30px";
        indicator.style.borderRadius = "50%";
        indicator.style.border = "2px solid #333";
        indicator.style.opacity = "0.8";
        indicator.style.pointerEvents = "none";
        indicator.style.zIndex = "100";
        indicator.style.animation = "zoom-indicator 0.6s ease-out forwards";
        this.container.appendChild(indicator);
        this._zoomIndicator = indicator;
        setTimeout(() => {
          if (this._zoomIndicator && this._zoomIndicator.parentNode) {
            this.container.removeChild(this._zoomIndicator);
            this._zoomIndicator = null;
          }
        }, 600);
      }
      animateZoomRotateAbout(ax, ay, toZoom, toBearing = this.bearing, duration = WHEEL_ZOOM_DURATION, easing = EASING.easeInOutCubic) {
        this.showZoomIndicator(ax, ay);
        this.stopAnimations();
        this.fire('movestart');
        this.fire('zoomstart');
        const startT = performance.now();
        const sZoom = this.zoom;
        const sBear = this.bearing;
        const deltaBear = shortestAngleDiff(sBear, toBearing);
        const anchorLL = this.screenToLatLon(ax, ay, this.zoom, this.bearing, this.center);
        const step = () => {
          const t = (performance.now() - startT) / Math.max(1, duration);
          const p = t >= 1 ? 1 : easing(Math.max(0, Math.min(1, t)));
          const z = sZoom + (toZoom - sZoom) * p;
          const b = sBear + deltaBear * p;
          this.applyZoomRotateAbout(ax, ay, z, b, anchorLL);
          this.render();
          if (t < 1) {
            this._zoomAnim = { raf: requestAnimationFrame(step) };
          } else {
            this._zoomAnim = null;
            this.updateControlsUI();
            this.fire('zoomend');
            this.fire('moveend');
          }
        };
        this._zoomAnim = { raf: requestAnimationFrame(step) };
      }
      smoothZoomAt(ax, ay, deltaZ) {
        const minZoom = this._baseLayer ? this._baseLayer.getMinZoom() : 0;
        const maxZoom = this._baseLayer ? this._baseLayer.getMaxZoom() : 18;
        const target = Math.max(minZoom, Math.min(maxZoom, this.zoom + deltaZ));
        this.animateZoomRotateAbout(ax, ay, target, this.bearing, WHEEL_ZOOM_DURATION, EASING.easeInOutCubic);
      }
      flyTo({ center = this.center, zoom = this.zoom, bearing = this.bearing, duration = FLYTO_DURATION, easing = EASING.easeInOutCubic } = {}) {
        const start = { center: this.getCenter(), zoom: this.getZoom(), bearing: this.getBearing() };
        const end = { center, zoom, bearing };

        const dist = GISUtils.haversineDistance(start.center, end.center);
        const longDistance = dist > EARTH_CIRCUMFERENCE / 4;

        duration = longDistance ? duration * 1.5 : duration;

        this.stopAnimations();
        const startT = performance.now();

        const step = () => {
            const t = Math.min(1, (performance.now() - startT) / duration);
            const p = easing(t);

            if (longDistance) {
                // Fly high for long distances
                const peakZoom = Math.max(0, start.zoom - 2.5, end.zoom - 2.5);
                const zoomProgress = -4 * (p - 0.5) * (p - 0.5) + 1; // Parabolic path for zoom
                this.zoom = start.zoom + (peakZoom - start.zoom) * zoomProgress + (end.zoom - peakZoom) * p;
            } else {
                this.zoom = start.zoom + (end.zoom - start.zoom) * p;
            }

            const dLon = wrapDeltaLon(end.center.lon - start.center.lon);
            this.center = {
                lon: GISUtils.wrapLongitude(start.center.lon + dLon * p),
                lat: GISUtils.clampLatitude(start.center.lat + (end.center.lat - start.center.lat) * p)
            };

            const dBearing = shortestAngleDiff(start.bearing, end.bearing);
            this.bearing = normalizeAngle(start.bearing + dBearing * p);

            this.render();

            if (t < 1) {
                this._flyAnim = { raf: requestAnimationFrame(step) };
            } else {
                this._flyAnim = null;
                this.updateControlsUI();
                this.fire('moveend');
            }
        };

        this._flyAnim = { raf: requestAnimationFrame(step) };
        this.fire('movestart');
      }
      destroy() {
        this.stopAnimations();
        for (const layer of [...this._layers]) this.removeLayer(layer);
        for (const control of [...this._controls]) this.removeControl(control);
        for (const corner in this._controlCorners) {
          const container = this._controlCorners[corner];
          if (container && container.parentNode) container.parentNode.removeChild(container);
        }
        this._controlCorners = {};
        for (const name in this._handlers) this.removeHandler(name);
        this.fire('unload');
        console.log("[Atlas] Instance destroyed.");
      }
    }
    Object.assign(Atlas.prototype, Evented);
    let atlasInstance = null;
    function initializeAtlas() {
        atlasInstance = new Atlas("map");

        // --- Base Layers ---
        const osmLayer = new TileLayer(`https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png`.replace('{s}', 'a'), LAYERS.OSM);
        const esriSatLayer = new TileLayer(LAYERS.ESRI.tileServers[0] + '/{z}/{y}/{x}', LAYERS.ESRI);

        const baseLayers = {
            "OpenStreetMap": osmLayer,
            "Esri Satellite": esriSatLayer
        };

        // --- Overlay Layers ---
        const cityMarker = new Marker({ lat: 51.5074, lon: -0.1278 }, { draggable: true })
            .bindPopup("A draggable marker in London.");

        const parkPolygon = new GeoJSONLayer({
            type: 'Polygon',
            coordinates: [[
                [-0.17, 51.50], [-0.15, 51.51], [-0.13, 51.50], [-0.17, 51.50]
            ]]
        }, { style: { color: 'green', fillColor: 'rgba(0, 255, 0, 0.5)' } })
            .bindPopup("Click me to toggle editing!");

        parkPolygon.on('click', () => {
            if (parkPolygon.isEditing()) {
                parkPolygon.disableEdit();
            } else {
                parkPolygon.enableEdit();
            }
        });

        const overlays = {
            "City Marker": cityMarker,
            "Park Area": parkPolygon
        };

        // --- Initialize Map ---
        atlasInstance.setBaseLayer(osmLayer); // Set initial base layer
        atlasInstance.addLayer(cityMarker);   // Set initial overlay

        const layerControl = new LayerControl(baseLayers, overlays, { position: 'top-right' });
        atlasInstance.addControl(layerControl);

        atlasInstance.flyTo({ center: { lat: 51.505, lon: -0.09 }, zoom: 13 });
    }
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeAtlas);
    } else {
      initializeAtlas();
    }
  </script>
</body>
</html>